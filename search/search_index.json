{"config": {"lang": ["fr"], "separator": "[\\s\\-]+", "pipeline": ["stopWordFilter"], "fields": {"title": {"boost": 1000.0}, "text": {"boost": 1.0}, "tags": {"boost": 1000000.0}}}, "docs": [{"location": "", "title": "Home", "text": "<p>Bienvenue sur le cours de programmation</p>"}, {"location": "#preface", "title": "Pr\u00e9face", "text": "<p>Cet ouvrage est destin\u00e9 aux \u00e9tudiants de premi\u00e8re ann\u00e9e Bachelor HEIG-VD, d\u00e9partement TIN et fili\u00e8res G\u00e9nie \u00e9lectrique. Il est une introduction \u00e0 la programmation en C. Il couvre la mati\u00e8re vue durant le cycle des cours Info1  et Info2 .</p> <p>Le contenu de ce cours est calqu\u00e9 sur les fiches d'unit\u00e9s de cours et de modules suivantes\u2009:</p> <ul> <li>Module InfoMicro (<code>InfoMicro</code>)</li> <li>Unit\u00e9 Informatique 1 (Info1 )</li> <li>Unit\u00e9 Informatique 2 (Info2 )</li> </ul>"}, {"location": "appendix/bibliography/", "title": "Bibliographie", "text": "<p>Les r\u00e9f\u00e9rences utilis\u00e9es dans cet ouvrage sont\u2009:</p>"}, {"location": "appendix/bibliography/#normes", "title": "Normes", "text": "<ul> <li>Standard ISO norme C 1999 - ISO/IEC 9899:1999</li> </ul>"}, {"location": "appendix/bibliography/#livres", "title": "Livres", "text": "<ul> <li>Le guide complet du langage C - Claude Delanoy, 844 pages (ISBN-13 978-2212140125)</li> <li>Le Langage C 2e \u00e9dition - K&amp;R, 304 pages (ISBN-13 978-2100715770)</li> <li>Cracking the coding interview - Gayle Laakmann, 687 pages (ISBN-13 978-0984782857)</li> <li>C\u2009: The Complete Reference, 4<sup>th</sup> Ed. - Osborne, 2.5 pounds (ISBN-13 978-0070411838)</li> </ul>"}, {"location": "appendix/bibliography/#sites-web", "title": "Sites Web", "text": "<ul> <li>Un r\u00e9sum\u00e9 du langage C - Learn X in Y minutes</li> <li>Encyclop\u00e9die libre - Wikipedia</li> <li>Questions R\u00e9ponses - StackOverflow</li> <li>Bac \u00e0 sable pour expressions r\u00e9guli\u00e8res - Regex101</li> </ul>"}, {"location": "appendix/bibliography/#problemes-en-lignes", "title": "Probl\u00e8mes en lignes", "text": "<ul> <li>CSES, 300 probl\u00e8mes d'algorithmique</li> <li>Exercism</li> </ul>"}, {"location": "appendix/bibliography/#cartes-de-references", "title": "Cartes de r\u00e9f\u00e9rences", "text": "<ul> <li>Carte de r\u00e9f\u00e9rence C HEIG-VD</li> </ul>"}, {"location": "appendix/glossary/", "title": "Glossaire", "text": ":::{glossary} compilateur <p>Programme ex\u00e9cutable permettant de transformer des instructions \u00e9crites dans un langage de programmation en langage machine (assembleur).</p> linker <p>Programme ex\u00e9cutable permettant l'assemblage de diff\u00e9rents modules compil\u00e9s en un seul ex\u00e9cutable.</p> ALU <p>Unit\u00e9 logique de calcul arithm\u00e9tique (Arithmetic logic unit). C'est un composant essentiel d'un microprocesseur ou microcontr\u00f4leur permettant les calculs simples tels que les quatre op\u00e9rations de base.</p> PGCD <p>Plus Grand Commun Diviseur. Le diviseur le plus grand commun \u00e0 2 ou plusieurs nombres. Les nombres 20 et 30 poss\u00e8dent les diviseurs 1, 2, 5 et 10. Le PGCD est donc 10. Il est calculable en utilisant l'algorithme d'Euclide.</p> BPMN <p>Business Process Model and Notation. Un syst\u00e8me de diagrammes pour d\u00e9crire des processus s\u00e9quentiels et parall\u00e8les.</p> UML <p>Unified Modelling Language. Un ensemble de plusieurs m\u00e9thodes pour pr\u00e9senter graphiquement une architecture logicielle.</p> GCC <p>GNU C Compiler. Compilateur libre offert standard sur les syst\u00e8mes POSIX Linux.</p> POSIX <p>Famille de normes techniques d\u00e9finies depuis 1988 et sugg\u00e9r\u00e9es par Richard Stallman permettant de standardiser le fonctionnement des syst\u00e8mes d'exploitation \u00e9ponymes. Il est l'acronyme de Portable Operating System Interface</p> <p>:::</p>"}, {"location": "appendix/grammar/", "title": "Grammaire C", "text": "<p>Yacc (Yet Another COmpiler-Compiler) est un logiciel utilis\u00e9 pour \u00e9crire des analyseurs syntaxiques de code. Il prend en entr\u00e9e une grammaire.</p> <p>Parce que les informaticiens ont de l'humour, Yacc \u00e0 son pendant GNU Bison plus r\u00e9cent (1985) mais toujours activement d\u00e9velopp\u00e9.</p> <p>Voici \u00e0 titre d'information la d\u00e9finition formelle du langage C99 :</p> <pre><code>--8&lt;-- \"docs/assets/src/c99.y\n</code></pre> <p>A partir de cette grammaire, Bison g\u00e9n\u00e8re un fichier <code>c99.tab.c</code> qui contient le code C de l'analyseur syntaxique.</p> <p>Pour la cr\u00e9er vous-m\u00eame, vous pouvez utiliser la commande suivante\u2009:</p> <pre><code>bison -d -o c99.tab.c c99.y\n</code></pre>"}, {"location": "appendix/laboratories/", "title": "Laboratoires", "text": "<p>Les laboratoires sont des travaux pratiques permettant \u00e0 l'\u00e9tudiant d'attaquer des probl\u00e8mes de programmation plus difficiles que les exercices faits en classe.</p>"}, {"location": "appendix/laboratories/#protocole", "title": "Protocole", "text": "<ol> <li>R\u00e9cup\u00e9rer le r\u00e9f\u00e9rentiel du laboratoire en utilisant GitHub Classroom.</li> <li>Prendre connaissance du cahier des charges.</li> <li>R\u00e9diger le code.</li> <li>Le tester.</li> <li>R\u00e9diger votre rapport de test si demand\u00e9.</li> <li>Le soumettre avant la date butoir.</li> </ol>"}, {"location": "appendix/laboratories/#evaluation", "title": "\u00c9valuation", "text": "<p>Une grille d'\u00e9valuation est int\u00e9gr\u00e9e \u00e0 tous les laboratoires. Elle prend la forme d'un fichier <code>criteria.yml</code> que l'\u00e9tudiant peut consulter en tout temps.</p>"}, {"location": "appendix/laboratories/#directives", "title": "Directives", "text": "<ul> <li>La recherche sur internet est autoris\u00e9e et conseill\u00e9e.</li> <li>Le plagiat n'est pas autoris\u00e9, et sanctionn\u00e9 si d\u00e9couvert par la note de 1.0.</li> <li>Le rendu pass\u00e9 la date butoir est sanctionn\u00e9 \u00e0 raison de 1 point puis 1/24 de point par heure de retard.</li> </ul>"}, {"location": "appendix/laboratories/#format-de-rendu", "title": "Format de rendu", "text": "<ul> <li>Fin de lignes\u2009: <code>LF</code> (<code>'\\n'</code>).</li> <li>Encodage\u2009: UTF-8 sans BOM.</li> <li>Code source respectueux de ISO/IEC 9899:1999.</li> <li>Le code doit comporter un exemple d'utilisation et une documentation mise \u00e0 jour dans <code>README.md</code>.</li> <li>Lorsqu'un rapport est demand\u00e9, vous le placerez dans <code>REPORT.md</code>.</li> </ul>"}, {"location": "appendix/laboratories/#anatomie-dun-travail-pratique", "title": "Anatomie d'un travail pratique", "text": "<p>Un certain nombre de fichiers vous sont donn\u00e9s, il est utile de les conna\u00eetre. Un r\u00e9f\u00e9rentiel sera g\u00e9n\u00e9ralement compos\u00e9 des \u00e9l\u00e9ments suivants\u2009:</p> <pre><code>$ tree\n.\n\u251c\u2500\u2500 .clang-format\n\u251c\u2500\u2500 .devcontainer\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Dockerfile\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 devcontainer.json\n\u251c\u2500\u2500 .editorconfig\n\u251c\u2500\u2500 .gitattributes\n\u251c\u2500\u2500 .gitignore\n\u251c\u2500\u2500 .vscode\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 launch.json\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 tasks.json\n\u251c\u2500\u2500 Makefile\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 assets\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 test.txt\n\u251c\u2500\u2500 foo.c\n\u251c\u2500\u2500 foo.h\n\u251c\u2500\u2500 main.c\n\u251c\u2500\u2500 criteria.yml\n\u2514\u2500\u2500 tests\n    \u251c\u2500\u2500 Makefile\n \u00a0\u00a0 \u2514\u2500\u2500 test_foo.c\n</code></pre>"}, {"location": "appendix/laboratories/#readmemd", "title": "README.md", "text": "<p>Il s'agit de la documentation principale de votre r\u00e9f\u00e9rentiel. Elle contient la donn\u00e9e du travail pratique en format Markdown. Ce fichier est \u00e9galement utilis\u00e9 par d\u00e9faut dans GitHub. Il contient notamment le titre du laboratoire, la dur\u00e9e, le d\u00e9lai de rendu et le format individuel ou de groupe\u2009:</p> <pre><code># Laboratoire &lt;!-- omit in toc --&gt;\n- **Dur\u00e9e**: 2 p\u00e9riodes + environ 3h \u00e0 la maison\n- **Date de rendu**: dimanche avant minuit\n- **Format**: travail individuel\n...\n</code></pre>"}, {"location": "appendix/laboratories/#criteriayml", "title": "criteria.yml", "text": "<p>Ce fichier contient les directives d'\u00e9valuation du travail pratique. Il est au format YAML. Pour chaque point \u00e9valu\u00e9 une description est donn\u00e9e avec la cl\u00e9 <code>description</code> et un nombre de points est sp\u00e9cifi\u00e9. Une exigence peut avoir soit un nombre de points positifs soit n\u00e9gatifs. Les points n\u00e9gatifs agissent comme une p\u00e9nalit\u00e9. Ce choix d'avoir des points et des p\u00e9nalit\u00e9s permet de ne pas diluer les exigences au travers d'autres crit\u00e8res importants, mais normalement respect\u00e9s des \u00e9tudiants.</p> <p>Des points bonus sont donn\u00e9s si le programme dispose d'une aide et d'une version et si la fonctionnalit\u00e9 du programme est \u00e9tendue.</p> <pre><code># Crit\u00e8res d'\u00e9valuation du travail pratique\n%YAML 1.2\n---\ntests:\n    build:\n        description: Le programme compile sans erreurs ni warning\n        points: 0/-4\n        test: test_build\n    unit-testing:\n        function_foo:\n        points: 0/10\n        test: test_foo\n        function_bar:\n        points: 0/10\n        test: test_bar\n    functional-testing:\n        arguments:\n        description: La lecture des arguments fonctionne comme demand\u00e9\n        points: 0/7\n        test: test_arguments\n        output-display:\n        description: Affichage sur stdout/stderr comme sp\u00e9cifi\u00e9\n        points: 0/3\n        test: test_output\n        errors:\n        description: Le programme affiche des erreurs si rencontr\u00e9es\n        points: 0/2\n        test: test_errors\nreport:\n    introduction:\n        description: Le rapport de test contient une introduction\n        points: 0/2\n    conclusion:\n        description: Le rapport de test contient une conclusion\n        points: 0/2\n    analysis:\n        description: Le rapport de test contient une analyse du comportement\n        points: 0/3\ncode:\n    specifications:\n        prototypes:\n            description: Les prototypes des fonctions demand\u00e9es sont respect\u00e9s\n            points: 0/3\n        main:\n            description: Le programme principal est minimaliste\n            points: 0/3\n        algorithm:\n            description: L'algorithme de encode/decode est bien pens\u00e9\n            points: 0/5\n    comments:\n        header:\n        description: Un en-t\u00eate programme est clairement d\u00e9fini\n        points: 0/2\n        purpose:\n        description: Les commentaires sont pertinents\n        points: 0/-2\n        commented-code:\n        description: Du code est comment\u00e9\n        points: 0/-2\n    variables:\n        naming:\n        description: Le noms des variables est minimaliste et explicite\n        points: 0/2\n        scope:\n        description: La port\u00e9e des variables est r\u00e9duite au minimum\n        points: 0/2\n        type:\n        description: Le type des variables est appropri\u00e9\n        points: 0/2\n    functions:\n        length:\n        description: La longueur des fonctions est raisonnable\n        points: 0/-4\n    control-flow:\n        description: Les structures de contr\u00f4le sont appropri\u00e9es\n        points: 0/4\n    overall:\n        dry:\n        description: Pas de r\u00e9p\u00e9tition dans le code\n        points: 0/-5\n        kiss:\n        description: Le code est minimaliste et simple\n        points: 0/-5\n        ssot:\n        description: Pas de r\u00e9p\u00e9tition d'information\n        points: 0/-5\n        indentation:\n        description: L'indentation du code est coh\u00e9rente\n        points: 0/-5\nbonus:\n    help:\n        description: Le programme dispose d'une aide\n        bonus: 0/1\n        test: test_help\n    version:\n        description: La version du programme peut \u00eatre affich\u00e9e\n        bonus: 0/1\n        test: test_version\n    extension:\n        description: La fonctionnalit\u00e9 du programme est \u00e9tendue\n        bonus: 0/3\n    english:\n        description: Usage de l'anglais\n        bonus: 0/1\n</code></pre> <p>Ce fichier est utilis\u00e9 par des tests automatique pour faciliter la correction du travail pratique.</p>"}, {"location": "appendix/refcards/", "title": "Cartes de r\u00e9f\u00e9rence", "text": "<p>Des cartes de r\u00e9f\u00e9rences A4 recto-verso ont \u00e9t\u00e9 r\u00e9alis\u00e9es pour diff\u00e9rents sujets d'informatique. Elles sont disponibles en version num\u00e9rique et en version papier \u00e0 la HEIG-VD.</p> <p>Elles sont normalement autoris\u00e9es durant les examens et travaux \u00e9crits.</p>"}, {"location": "appendix/refcards/#carte-de-reference-c", "title": "Carte de r\u00e9f\u00e9rence C", "text": "<p> Carte de r\u00e9f\u00e9rence C</p>"}, {"location": "appendix/refcards/#carte-de-reference-c_1", "title": "Carte de r\u00e9f\u00e9rence C++", "text": "<p> Carte de r\u00e9f\u00e9rence C</p>"}, {"location": "appendix/refcards/#carte-de-reference-programmation-concurrente", "title": "Carte de r\u00e9f\u00e9rence Programmation Concurrente", "text": "<p> Carte de r\u00e9f\u00e9rence Programmation concurrente</p>"}, {"location": "appendix/refcards/#carte-de-reference-python", "title": "Carte de r\u00e9f\u00e9rence Python", "text": "<p> Carte de r\u00e9f\u00e9rence Programmation concurrente</p>"}, {"location": "appendix/refcards/#carte-de-reference-latex", "title": "Carte de r\u00e9f\u00e9rence LaTeX", "text": "<p> Carte de r\u00e9f\u00e9rence Programmation concurrente</p>"}, {"location": "appendix/unit/", "title": "Fiches d'unit\u00e9s de cours", "text": "<p>Les fiches d'unit\u00e9s sont les documents de r\u00e9f\u00e9rence pour les cours d'info1 et d'info2, ici pr\u00e9sent\u00e9es sous forme de donn\u00e9es brutes au format YAML.</p>"}, {"location": "appendix/unit/#informatique-1", "title": "Informatique 1", "text": "<pre><code># Version formelle et \u00e9tendue de la fiche d'unit\u00e9 de cours disponible sur GAPS\n# http://gaps.heig-vd.ch/public/fiches/uv/uv.php?id=5637\n---\ntitle:\n    name: Informatique 1\n    tag: info1\n    id: 6488\ndomain: Ing\u00e9nierie et Architecture\nfili\u00e8re: G\u00e9nie \u00e9lectrique\norientations:\n  ? EAI\n  ? EEM\n  ? MI\nformation: Plein temps\nvalidityDate:\n    - 2021-2022\nauthor: Pierre Bressy\ncharge:\n    academicHours: 150\n    inClassAcademicHours: 96\nplanning:\n    s1:\n        class: # 48\n            - hours: 4\n              chapters:\n                - Introduction.\n                - Aper\u00e7u du fonctionnement de l'ordinateur.\n                - Codage de l'information\n            - hours: 2\n              chapters:\n                - Pr\u00e9sentation du langage C\n            - hours: 12\n              chapters:\n                - Types de donn\u00e9es de base\n                - Variables\n                - Constantes\n                - Op\u00e9rateurs\n                - Entr\u00e9es et sorties console\n            - hours: 8\n              chapters:\n                - Structures de contr\u00f4le\n                - Branchements\n                - Boucles\n            - hours: 6\n              chapters:\n                - Fonctions\n                - Passage par valeur et par adresse\n            - hours: 8\n              chapters:\n                - Tableaux\n                - Cha\u00eenes de caract\u00e8res\n            - hours: 4\n              chapters:\n                - Introduction \u00e0 l'analyse et \u00e0 la conception (d\u00e9coupage du probl\u00e8me)\n            - hours: 4\n              chapters:\n                - Contr\u00f4le continu et corrections\n        laboratory:\n            - hours: 2\n              chapters:\n                - Mise en place de l'environnement de travail.\n            - hours: 2\n              chapters:\n                - Environnement de d\u00e9veloppement int\u00e9gr\u00e9\n                    - Installation\n                    - Configuration\n                    - \u00c9dition\n                    - Compilation\n            - hours: 8\n              chapters:\n                - Dialogues utilisateurs\n            - hours: 10\n              chapters:\n                - Utilisation des structures de contr\u00f4le (if, for, while, do..while, switch).\n            - hours: 8\n              chapters:\n                - Type de donn\u00e9es compos\u00e9s\n            - hours: 8\n              chapters:\n                - Mini projet.\nprerequisites: |\n    L'\u00e9tudiant-e doit conna\u00eetre et savoir utiliser les notions suivantes\n        - utilisation g\u00e9n\u00e9rale d'un syst\u00e8me d'exploitation graphique notamment\n          la gestion de fichiers et les bases des outils de bureautique,\n        - notation binaire, octale et hexad\u00e9cimale et de l\u2019alg\u00e8bre bool\u00e9enne \u00e9l\u00e9mentaire.\ngoals:\n    classroom:\n        - Expliquer les principes g\u00e9n\u00e9raux de repr\u00e9sentation de l\u2019information dans les ordinateurs.\n        - D\u00e9crire la marche \u00e0 suivre et les outils n\u00e9cessaires pour cr\u00e9er un programme ex\u00e9cutable.\n        - Assurer la tra\u00e7abilit\u00e9 du code source de la conception \u00e0 la livraison du programme.\n        - Citer les \u00e9l\u00e9ments syntaxiques du langage C utilis\u00e9 couramment pour \u00e9crire des programmes.\n        - Choisir le type de donn\u00e9es le plus adapt\u00e9 pour repr\u00e9senter une information physique.\n        - Concevoir et programmer un dialogue op\u00e9rateur en mode console.\n        - Formater un affichage sur la sortie standard pour le rendre lisible.\n        - Calculer la valeur d\u2019une expression construite avec diff\u00e9rents op\u00e9rateurs du langage C et en d\u00e9terminer le type de stockage r\u00e9sultant.\n        - Choisir la structure de contr\u00f4le appropri\u00e9e pour r\u00e9soudre un probl\u00e8me algorithmique simple.\n        - Concevoir et impl\u00e9menter un algorithme imbriquant jusqu\u2019\u00e0 trois niveaux de structure de contr\u00f4le.\n        - Cr\u00e9er une fonction impliquant un passage de param\u00e8tre par valeur et par adresse.\n        - Utiliser le \u00ab type tableau \u00bb multidimensionnel et manipuler ses \u00e9l\u00e9ments constituants.\n        - Manipulation simple de cha\u00eenes de caract\u00e8res en utilisant la biblioth\u00e8que standard.\n        - Mettre en \u0153uvre des algorithmes utilisant des fonctions math\u00e9matiques de la biblioth\u00e8que standard.\n        - D\u00e9boguer un programme informatique en utilisant des points d\u2019arr\u00eat.\n        - Interagir avec un programme ex\u00e9cutable via les arguments et les flux d\u2019entr\u00e9es sorties.\n        - Conna\u00eetre les idiomes (patron d\u2019impl\u00e9mentation) de base (SSOT, DRY, KISS).\n    laboratory:\n        - Installer et configurer un environnement de d\u00e9veloppement int\u00e9gr\u00e9 (IDE) pour le langage C.\n        - Cr\u00e9er des programmes avec un IDE et compiler un programme en ligne de commande.\n        - Construire une liste d\u2019arguments.\n        - Cr\u00e9er un programme g\u00e9rant un menu en mode console et affichant des r\u00e9sultats sous forme structur\u00e9e.\n        - Mettre au point it\u00e9rativement un programme pour atteindre un fonctionnement fiable et ergonomique.\n        - Comprendre un cahier des charges, identifier et clarifier les exigences importantes, et s\u2019y conformer.\n        - Analyser de mani\u00e8re autonome les probl\u00e8mes rencontr\u00e9s et proposer une solution impl\u00e9mentable.\n        - Livrer un logiciel en assurant sa tra\u00e7abilit\u00e9 en respectant un d\u00e9lai.\n        - Citer des applications pratiques de la programmation en relation avec ses futurs d\u00e9bouch\u00e9s professionnels.\n        - Chercher des solutions par soi-m\u00eame en utilisant internet.\nplan:\n  - Num\u00e9ration\n    - Bases (syst\u00e8me d\u00e9cimal, hexad\u00e9cimal, octal, binaire)\n    - Conversion de bases\n    - Compl\u00e9ment \u00e0 un\n    - Compl\u00e9ment \u00e0 deux\n    - Arithm\u00e9tique binaire (et, ou, ou exclusif, n\u00e9gation)\n  - Processus de d\u00e9veloppement\n    - Outils\n      - Environnement int\u00e9gr\u00e9 (IDE)\n      - Compilateur (*compiler*)\n      - Cha\u00eene de d\u00e9veloppement (*toolchain*)\n    - Cycle de d\u00e9veloppement\n    - Cycle de compilation\n    - Installation d'un environnement de d\u00e9veloppement\n    - Programmes et processus\n  - G\u00e9n\u00e9ralit\u00e9s du langage C\n    - S\u00e9quences\n    - Embranchements (if, switch)\n    - Boucles (while, do..while, for)\n    - Sauts (break, continue, return, goto)\n  - Types de donn\u00e9es\n    - Typage\n    - Stockage des donn\u00e9es en m\u00e9moire\n    - Entiers naturels\n    - Entiers relatifs\n    - Nombres r\u00e9els (virgule flottante)\n    - Caract\u00e8res\n      - Table ASCII\n    - Cha\u00eenes de caract\u00e8res\n    - Bool\u00e9ens\n  - Interaction utilisateur en mode console\n    - Entr\u00e9e standard\n    - Sortie standard\n    - Sortie d'erreur standard\n    - Questions/R\u00e9ponses avec `printf` et `scanf`\n    - Formater un r\u00e9sultat sous forme tabul\u00e9e et lisible\n    - Menu (choix multiples)\n  - Op\u00e9rateurs\n    - Op\u00e9rateurs du langage C\n    - Priorit\u00e9 des op\u00e9rateurs\n    - Expressions\n    - Promotion et promotion implicite\n  - Conception\n    - Choix des structures de contr\u00f4les adapt\u00e9es \u00e0 des probl\u00e8mes\n    - Algorithmes simple (min, max, moyenne, ...)\n      - Manipulation de cha\u00eenes\n      - Manipulation de tableaux\n      - Manipulation de bits\n  - Algorithmie\n    - Complexit\u00e9 d'un algorithme\n    - Exemples d'algorithmes\n    - Algorithmes de tri (tri \u00e0 bulle)\n  - Fonctions\n    - Passage par valeur et par adresse\n    - Utilisation de la valeur de retour\n    - Prototypes de fonctions\n  - Types de donn\u00e9es compos\u00e9es\n    - Structures\n    - Unions\n    - Tableaux\n    - \u00c9num\u00e9rations\n  - Biblioth\u00e8ques standard\n    - &lt;math.h&gt;\n      - Fonctions trigonom\u00e9triques\n      - Exponentielle\n      - Logarithme\n    - &lt;string.h&gt;\n      - Comparaison de cha\u00eenes de caract\u00e8res\n      - Concat\u00e9nation de cha\u00eenes de caract\u00e8res\n      - Copie de cha\u00eenes de caract\u00e8res\n      - Longueur d'une cha\u00eene de caract\u00e8res\n      - Recherche d'une sous-cha\u00eene dans une cha\u00eene de caract\u00e8res\n    - &lt;stdio.h&gt;\n      - printf\n      - scanf\n      - putchar\n      - getchar\n      - puts\n      - gets\n  - Structure du code\n    - Corriger les erreurs de syntaxes\n    - Corriger les erreurs s\u00e9mantiques\n    - Indentation du code\n    - Commentaires\n</code></pre>"}, {"location": "appendix/unit/#panification-du-semestre-dhiver", "title": "Panification du semestre d'hiver", "text": "Semaine Acad\u00e9mique Cours Labo 38 1 Introduction 00 Familiarisation 39 2 Num\u00e9ration 01 Premier pas en C 40 3 Fondements du C 02 \u00c9quation quadratique 41 4 Variables, op\u00e9rateurs 03 Fl\u00e9chettes 42 5 Types, entr\u00e9es sorties 04 Pneus 43 Vacances d'automne 44 6 Entr\u00e9es sorties 05 Monte-Carlo 45 7 TE1 06 Tables Multiplications 46 8 Structure de contr\u00f4les 07 Cha\u00eenes (par \u00e9quipe) 47 9 Fonctions 08 Nombre d'Armstrong 48 10 Tableaux et structures 09 Sudoku 49 11 Programmes et processus 50 12 Algorithmique Labo Test 51 13 Pointeurs 10 Galton 52 Vacances de No\u00ebl 1 2 14 Ergonomie et dialogues 12 Tableau des scores 3 15 TE2 4 16 Exercices de r\u00e9vision 5 Pr\u00e9paration Examens 6 Examens 7 Rel\u00e2ches"}, {"location": "appendix/unit/#informatique-2", "title": "Informatique 2", "text": "<pre><code># Version formelle et \u00e9tendue de la fiche d'unit\u00e9 de cours disponible sur GAPS\n# https://gaps.heig-vd.ch/consultation/fiches/uv/uv.php?id=6491\n---\ntitle:\n    name: Informatique 2\n    tag: info2\n    id: 6491\ndomain: Ing\u00e9nierie et Architecture\nfili\u00e8re: G\u00e9nie \u00e9lectrique\norientations:\n  ? EAI\n  ? EEM\n  ? MI\nformation: Plein temps\nvalidityDate:\n    - 2021-2022\nauthor: Pierre Bressy\ncharge:\n    academicHours: 120\n    inClassAcademicHours: 80\nplanning:\n    s1:\n        class: # 48\n            - hours: 4\n              chapters:\n                - 'Pr\u00e9processeur (#include, #define, #if, #pragma)'\n            - hours: 4\n              chapters:\n                - Classes de stockage (static, volatile, extern)\n            - hours: 8\n              chapters:\n                - Conception de type de donn\u00e9es abstraits simples\n                - Cr\u00e9ation de biblioth\u00e8ques\n            - hours: 10\n              chapters:\n                - Pointeurs, arithm\u00e9tique de pointeurs\n                - Allocation dynamique\n                - Segments m\u00e9moire (stack, heap)\n            - hours: 6\n              chapters:\n                - Impl\u00e9mentation des listes\n                - Queues et files d'attente bas\u00e9e sur les tableaux\n            - hours: 8\n              chapters:\n                - Type de donn\u00e9es r\u00e9cursifs, queues et files d'attente\n            - hours: 4\n              chapters:\n                - Gestion des flux (stdin, stdout, stderr)\n                - Fichiers binaires et textes\n            - hours: 4\n              chapters:\n                - Contr\u00f4les continus\n        laboratory:\n            - hours: 6\n              chapters:\n                - &gt;\n                  Mise en \u0153uvre de type de donn\u00e9es compos\u00e9es\n                  (structures, tableaux multidimensionnels)\n            - hours: 4\n              chapters:\n                - Lecture et \u00e9criture de fichiers texte et binaire en mode s\u00e9quentiel\n            - hours: 4\n              chapters:\n                - Mise en \u0153uvre de l'allocation dynamique de m\u00e9moire\n            - hours: 2\n              chapters:\n                - Compilation s\u00e9par\u00e9e et impl\u00e9mentation de biblioth\u00e8ques\n            - hours: 4\n              chapters:\n                - Impl\u00e9mentation de types de donn\u00e9es abstraits, type simple, liste tableau\n            - hours: 6\n              chapters:\n                - Impl\u00e9mentation de types de donn\u00e9es abstraits, file, pile\n            - hours: 6\n              chapters:\n                - Mini-projet\nprerequisites: |\n    L'\u00e9tudiant-e doit conna\u00eetre et savoir utiliser les notions suivantes\n        - bases de la programmation en C : types de base, structures\n          de contr\u00f4le et sous-programmes,\n        - utilisation d'un environnement de d\u00e9veloppement,\n          compilation et ex\u00e9cution de programmes.\n    L'unit\u00e9 d'enseignement Informatique 1 permet d'acqu\u00e9rir ces connaissances.\n\ngoals:\n    class:\n        - &gt;\n          D\u00e9composer un algorithme selon l'approche descendante (raffinage successif)\n          et ascendante.\n        - D\u00e9composer une application de complexit\u00e9 moyenne en algorithmes \u00e9l\u00e9mentaires.\n        - Concevoir un type de donn\u00e9es abstrait simple et les fonctions pour le manipuler.\n        - Concevoir une biblioth\u00e8que de fonctions en utilisant la compilation s\u00e9par\u00e9e.\n        - \u00c9crire un programme qui manipule (lecture/\u00e9criture) des fichiers binaires\n        - Lire et g\u00e9n\u00e9rer un fichier de donn\u00e9es tabul\u00e9es (p.ex. csv),\n        - Mettre en \u0153uvre un tableau dynamique avec facteur de croissance,\n        - D\u00e9finir et manipuler un type de donn\u00e9es r\u00e9cursif e.g. liste cha\u00een\u00e9e,\n        - Comprendre le fonctionnement d'un algorithme de tri en O(n log n),\n        - Savoir impl\u00e9menter une recherche dichotomique\n        - Comprendre le fonctionnement du pr\u00e9processeur C\n        - Conna\u00eetre et savoir quand utiliser les diff\u00e9rentes classes de stockage\n        - Conna\u00eetre en d\u00e9tail la notion de pointeur et savoir les utiliser\n        - &gt;\n          Utiliser les fonctions standard de recherche et de manipulation\n          de cha\u00eene de caract\u00e8res (p.ex. strstr, strchr, qsort).\n    laboratory:\n        - R\u00e9unir un ensemble de fonctions dans un module logiciel et l'utiliser\n        - Programmer et mettre au point des algorithmes de complexit\u00e9 moyenne\n        - &gt;\n          R\u00e9aliser une application de taille et de complexit\u00e9 moyennes,\n          m\u00ealants diff\u00e9rents aspects de la programmation\n        - D\u00e9velopper un programme en utilisant un outil de gestion de version\n        - Utiliser un syst\u00e8me de test automatique pour valider le fonctionnement d'un programme.\n\nplan:\n  - Algorithmie\n    - Raffinage successif\n    - D\u00e9composition en \u00e9l\u00e9ments fonctionnels simples\n    - Conception d'algorithmes de complexit\u00e9 moyenne\n  - Types compos\u00e9s\n    - Manipulation d'une structure (struct)\n    - Passage par copie et adresse\n    - Cr\u00e9ation de types (typedef)\n  - Biblioth\u00e8que\n    - Concevoir une biblioth\u00e8que statique\n    - Utilisation d'une biblioth\u00e8que statique dans un programme\n  - Fichiers\n    - Types de fichiers\n      - Binaire\n      - Textes\n      - Donn\u00e9es tabul\u00e9es\n      - Donn\u00e9es index\u00e9es\n    - Syst\u00e8me de fichier\n      - Arborescence\n      - Dossiers\n      - Chemins relatifs et absolus\n    - Manipulation de fichiers\n      - Pointeur de fichier (ftell, fseek)\n      - Lecture (fread, fscanf)\n      - \u00c9criture (fwrite, fprintf)\n  - Gestion de la m\u00e9moire\n    - Pointeurs\n      - R\u00e8gle gauche droite\n      - Arithm\u00e9tique de pointeurs\n      - Types de pointeurs imbriqu\u00e9s (p.ex. int**[])\n    - Allocation dynamique\n      - malloc\n      - calloc\n      - free\n      - Cr\u00e9ation de tableaux dynamiques\n      - Comprendre la diff\u00e9rence entre le stack et le heap\n  - Types de donn\u00e9es r\u00e9cursifs\n    - Liste simplement cha\u00een\u00e9e\n    - Liste doublement cha\u00een\u00e9e\n  - Alignement m\u00e9moire\n    - Unions\n    - Champs de bits\n  - Livraison\n    - Pr\u00e9parer le code \u00e0 la livraison\n    - Construire une biblioth\u00e8que document\u00e9e\n    - Utiliser GitHub pour tracer le d\u00e9veloppement\n    - Utiliser une biblioth\u00e8que de test unitaire\nbibliographie:\n  - author: Jean-Michel L\u00e9ry\n    title: Algorithmique, Applications en C, C++ et Java\n    editor: Pearson\n    year: 2013\n  - standard: ISO/IEC 9899:2011\n    title: Langage de programmation C, ISO/IEC\n    year: 2011\n  - author:\n    ? Brian Kernighan\n    ? Dennis Ritchie\n    title: Le langage C\n    edition: 2nd\n    editor: Dunod\n    year: 2014\n    isbn: 978-2100715770\n  - author: Claude Delannoy\n    title: Programmer en langage C, Cours et exercices corrig\u00e9s\n    editor: Eyrolles\n    year: 2016\n  - author: Stephen Kochan\n    title: Programming in C\n    edition: 4\n    editor: Pearson\n    year: 2014\n    isbn: 978-0321776419\n</code></pre>"}, {"location": "appendix/unit/#panification-du-semestre-de-printemps", "title": "Panification du semestre de printemps", "text": "Semaine Acad\u00e9mique Cours Labo 8 1 Introduction GitHub - WSL 9 2 Fichiers Proust (partie 1) 10 3 Allocation dynamique Proust (partie 2) 11 4 Allocation dynamique M\u00e9t\u00e9o (partie 1) 12 5 Compilation s\u00e9par\u00e9e M\u00e9t\u00e9o (partie 2) 13 6 Pr\u00e9processeur Tableau dynamique (\u00bd) 14 7 Unions, champs de bits Tableau dynamique (2/2) 15 8 Usage biblioth\u00e8ques St\u00e9ganographie 16 Vacances de P\u00e2ques 17 9 TE1 Wave (partie 1) 18 10 Algorithmique Big-O Wave (partie 2) 19 11 Tris Quick-Sort / Merge-Sort 20 12 Queues et piles Tries 21 13 Sockets Labo Test 22 14 TE2 Shunting-yard 23 15 Arbres binaires Tries (partie 1) 24 16 Exercices de r\u00e9vision Tries (partie 2) 25 Pr\u00e9paration Examens 26 Examens"}, {"location": "appendix/unit/#modalites-devaluation-et-de-validation", "title": "Modalit\u00e9s d'\u00e9valuation et de validation", "text": "<p>Le cours se compose de\u2009:</p> <ul> <li>Travaux \u00e9crits not\u00e9s (coefficient 100%)</li> <li>Quiz not\u00e9s ou non (coefficient 10% ou 0%)</li> <li>S\u00e9ries d'exercices</li> <li>Travaux pratiques, 2 \u00e0 3 labos not\u00e9s (laboratoires)</li> <li>Labo test not\u00e9 comptabilis\u00e9 comme un labo</li> </ul> <p>La note finale est donn\u00e9e par l'expression\u2009:</p> FormuleProgramme C \\[ \\text{final} = \\frac{ \\sum\\limits_{t=1}^\\text{T}{\\text{TE}_t} + 10\\% \\cdot \\sum\\limits_{q=1}^\\text{Q}{\\text{Quiz}_q} }{ 4 \\cdot (\\text{T} + 10\\% \\cdot \\text{Q}) } + \\frac{1}{4 L} \\sum\\limits_{l=1}^L \\text{Labo}_l + \\frac{1}{2} \\text{Exam} \\] <pre><code>#define QUIZ_WEIGHT (.1) // Percent\n#define EXAM_WEIGHT (.5) // Percent\n\ntypedef struct notes {\n    size_t size;\n    float values[];\n} Notes;\n\nfloat sum(Notes *notes) {\n    float s = 0;\n    for (int i = 0; i &lt; notes-&gt;size; i++)\n        s += notes-&gt;values[i];\n    return s;\n}\n\nfloat mark(Notes tes, Notes quizzes, Notes labs, float exam) {\n    return (\n    sum(tes) + QUIZ_WEIGHT * sum(quizzes)\n    ) / (\n        (EXAM_WEIGHT / 2.) * (tes.size + QUIZ_WEIGHT * quizzes.size)\n    ) +\n            (EXAM_WEIGHT / 2.) * sum(labs) / labs.size +\n        EXAM_WEIGHT * exam;\n}\n</code></pre>"}, {"location": "appendix/unit/#directives", "title": "Directives", "text": "<ul> <li>En cas d'absence \u00e0 un quiz, la note de 1.0 est donn\u00e9e.</li> <li>En cas de plagiat, le dilemme du prisonnier s'applique.</li> </ul>"}, {"location": "assets/src/grammar/", "title": "Expression", "text": "<p>Does not work yet...</p>"}, {"location": "course-c/00-preface/", "title": "Pr\u00e9face", "text": ""}, {"location": "course-c/00-preface/#a-qui-sadresse-cet-ouvrage", "title": "\u00c0 qui s'adresse cet ouvrage\u2009?", "text": "<p>Con\u00e7u comme un r\u00e9sum\u00e9 du savoir n\u00e9cessaire \u00e0 l'ing\u00e9nieur pour s'initier \u00e0 la programmation et prendre en main le langage C, cet ouvrage n'est pas un manuel de r\u00e9f\u00e9rence. Il se r\u00e9f\u00e8re \u00e0 de nombreuses ressources internet et livres que le lecteur pourra consulter au besoin pour approfondir certains concepts.</p> <p>Chaque chapitre est compos\u00e9 d'exercices, mais \u00e0 des fins p\u00e9dagogiques, l'int\u00e9gralit\u00e9 des solutions ne sont pas fournies\u2009; certains exercices sont destin\u00e9s \u00e0 \u00eatre faits en \u00e9tudes.</p> <p>Cet ouvrage est destin\u00e9 \u00e0 des \u00e9tudiants ing\u00e9nieurs de premi\u00e8re ann\u00e9e n'ayant aucune exp\u00e9rience en programmation.</p> <p>Le contenu concerne principalement les cours d'informatique 1 et 2 de l'enseignement de base du d\u00e9partement des technologies industrielles (TIN) de la HEIG-VD.</p>"}, {"location": "course-c/00-preface/#cours-dinformatique-cursus-bachelor", "title": "Cours d'informatique cursus bachelor", "text": "<p>Ce cours d'informatique \u00e0 la HEIG-VD est donn\u00e9 par le d\u00e9partement TIN dans les cours du cursus Bachelor en G\u00e9nie \u00e9lectrique. Il concerne tout particuli\u00e8rement les \u00e9tudiants des cours suivants\u00a0:</p> <ul> <li>Informatique 1 (INFO1) - 101 Premi\u00e8re ann\u00e9e</li> <li>Informatique 2 (INFO2) - 102 Premi\u00e8re ann\u00e9e</li> <li>Microinformatique (MICROINFO) - 101 Premi\u00e8re ann\u00e9e</li> </ul>"}, {"location": "course-c/00-preface/#quel-programmeur-etes-vous", "title": "Quel programmeur \u00eates-vous\u2009?", "text": "<p>Les \u00e9tudes en \u00e9coles d'ing\u00e9nieurs sont souvent cloisonn\u00e9es. On observe, entre les diff\u00e9rentes facult\u00e9s (\u00e9lectronique, informatique, etc.), que l'enseignement de l'informatique s'inscrit dans une culture distincte avec un langage sp\u00e9cifique. Les informaticiens, dot\u00e9s d'un esprit d'abstraction remarquable, acqui\u00e8rent des connaissances approfondies du fonctionnement interne des syst\u00e8mes d'exploitation et poss\u00e8dent une expertise \u00e9tendue en programmation. N\u00e9anmoins, ils manquent parfois d'une exp\u00e9rience pratique avec le mat\u00e9riel \u00e9lectronique et les contraintes impos\u00e9es par des architectures mat\u00e9rielles l\u00e9g\u00e8res (syst\u00e8mes embarqu\u00e9s, microcontr\u00f4leurs, etc.). Les \u00e9lectroniciens, quant \u00e0 eux, disposent d'une compr\u00e9hension approfondie des syst\u00e8mes \u00e0 bas niveau. Ils ont une vision pragmatique des syst\u00e8mes et des contraintes mat\u00e9rielles. Cependant, ils manquent souvent de connaissances pouss\u00e9es en programmation et en algorithmique.</p> <p>Ces deux profils, bien que compl\u00e9mentaires, ont souvent du mal \u00e0 se comprendre. Les informaticiens per\u00e7oivent les \u00e9lectroniciens comme trop terre-\u00e0-terre, tandis que les \u00e9lectroniciens jugent les informaticiens trop abstraits. Des divergences d'opinions peuvent \u00e9merger de ces diff\u00e9rences culturelles, notamment dans des notions communes dont les d\u00e9finitions varient. Par exemple, la notion de temps r\u00e9el diff\u00e8re pour un informaticien et un \u00e9lectronicien. Pour un informaticien, le temps r\u00e9el d\u00e9signe un syst\u00e8me qui r\u00e9pond dans un d\u00e9lai d\u00e9termin\u00e9 pour un utilisateur (environ 100 ms). Pour un \u00e9lectronicien, le temps r\u00e9el d\u00e9signe un syst\u00e8me qui r\u00e9pond dans un d\u00e9lai d\u00e9termin\u00e9 et qui est d\u00e9terministe (environ 100 \u00b5s).</p> <p>Un autre exemple est la complexit\u00e9 algorithmique. Pour un informaticien, la complexit\u00e9 algorithmique mesure la performance d'un algorithme en termes g\u00e9n\u00e9raux. Un acc\u00e8s \u00e0 un dictionnaire est en \\(O(1)\\), m\u00eame s'il implique le calcul d'un <code>sha256</code>, une op\u00e9ration triviale sur un ordinateur. Pour un \u00e9lectronicien, il est impossible de r\u00e9aliser un <code>sha256</code> sur un microcontr\u00f4leur 8 bits, ce qui l'incite \u00e0 rechercher des optimisations profondes de l'algorithme, quitte \u00e0 le rendre moins g\u00e9n\u00e9rique et modulaire.</p> <p>Cet ouvrage a pour objectif de rapprocher ces deux cultures en fournissant aux \u00e9lectroniciens les bases de la v\u00e9ritable informatique, de la programmation et de sa culture, en rendant accessibles des concepts complexes tels que les arbres et les graphes.</p>"}, {"location": "course-c/00-preface/#organisation-de-louvrage", "title": "Organisation de l'ouvrage", "text": ""}, {"location": "course-c/00-preface/#raccourcis-clavier", "title": "Raccourcis clavier", "text": "<p>Pour am\u00e9liorer votre navigation sur ce site, voici quelques raccourcis clavier que vous pouvez utiliser\u2009:</p> F, S, / <p>Ouvre la barre de recherche</p> P, , <p>Va \u00e0 la page pr\u00e9c\u00e9dente</p> N, . <p>Va \u00e0 la page suivante</p> B <p>Afficher/cacher les tables des mati\u00e8res</p> M <p>Afficher/cacher le menu</p> H <p>Afficher/cacher la table des mati\u00e8res</p>"}, {"location": "course-c/00-preface/#conventions-decriture", "title": "Conventions d'\u00e9criture", "text": ""}, {"location": "course-c/00-preface/#encodage-de-caractere", "title": "Encodage de caract\u00e8re", "text": "<p>Il sera souvent fait mention dans cet ouvrage la notation du type 1F4A9, il s'agit d'une notation Unicode qui ne d\u00e9pend pas d'un quelconque encodage. Parler du caract\u00e8re ASCII 234 est incorrect, car cela d\u00e9pend de la table d'encodage utilis\u00e9e\u2009; en revanche, la notation Unicode est plus pr\u00e9cise.</p> <p>La notation est cliquable et vous redirigera vers le site symbl.cc.</p>"}, {"location": "course-c/00-preface/#expressions-regulieres", "title": "Expressions r\u00e9guli\u00e8res", "text": "<p>Les expressions r\u00e9guli\u00e8res sont utilis\u00e9es pour d\u00e9crire des motifs de texte. Elles sont utilis\u00e9es pour rechercher, remplacer ou valider des cha\u00eenes de caract\u00e8res. Les expressions r\u00e9guli\u00e8res sont utilis\u00e9es dans de nombreux langages de programmation, d'outils de recherche et de traitement de texte.</p> <p>Aussi dans cet ouvrage, les expressions r\u00e9guli\u00e8res sont mises en \u00e9vidence avec /regex/. Le lien m\u00e8ne au site regex101.com. Pour tester les expressions r\u00e9guli\u00e8res, il vous suffit alors d'ajouter votre propre texte pour tester l'exemple donn\u00e9.</p>"}, {"location": "course-c/00-preface/#symbole-degalite", "title": "Symbole d'\u00e9galit\u00e9", "text": "<p>Nous verrons que le signe d'\u00e9galit\u00e9 <code>=</code> peut ais\u00e9ment \u00eatre confondu avec l'op\u00e9rateur d'affectation du langage C qui s'\u00e9crit de la m\u00eame mani\u00e8re. Dans certains exemples o\u00f9 l'on montre une \u00e9galit\u00e9 entre diff\u00e9rentes \u00e9critures, le signe d'\u00e9galit\u00e9 triple 2261 sera utilis\u00e9 pour dissiper toute ambigu\u00eft\u00e9 \u00e9ventuelle\u2009:</p> <pre><code>'a' \u2261 0b1100001 \u2261 97 \u2261 0x61 \u2261 00141\n</code></pre>"}, {"location": "course-c/00-preface/#symbole-de-remplissage", "title": "Symbole de remplissage", "text": "<p>Dans les exemples qui seront donn\u00e9s, on pourra voir <code>while (condition) { \u301c }</code> ou le caract\u00e8re <code>\u301c</code> 3030 indique une continuit\u00e9 logique d'op\u00e9ration. Le symbole exprime ainsi <code>...</code> (points de suspension ou ellipsis). Or, pour ne pas confondre avec le symbole C <code>...</code> utilis\u00e9 dans les fonctions \u00e0 arguments variables tels que <code>printf</code>.</p>"}, {"location": "course-c/00-preface/#types-de-donnees", "title": "Types de donn\u00e9es", "text": "<p>Les conventions C s'appliquent \u00e0 la mani\u00e8re d'exprimer les grandeurs suivantes\u2009:</p> <ul> <li><code>0xABCD</code> pour les valeurs hexad\u00e9cimales /0x[0-9a-f]+/i</li> <li><code>00217</code> pour les valeurs octales /0[0-7]+/</li> <li><code>'c'</code> pour les caract\u00e8res /'([^']|\\\\[nrftvba'])'/</li> <li><code>123</code> pour les grandeurs enti\u00e8res /-?[1-9][0-9]*/</li> <li><code>12.</code> pour les grandeurs r\u00e9elles en virgule flottante</li> </ul>"}, {"location": "course-c/00-preface/#encadres", "title": "Encadr\u00e9s", "text": "<p>Des encadr\u00e9s sont utilis\u00e9s pour mettre en avant des informations compl\u00e9mentaires ou des astuces. Ils sont \u00e9galement utilis\u00e9s pour donner des informations sur des concepts avanc\u00e9s ou des d\u00e9tails techniques.</p> <p>Info</p> <p>Fait historique o\u00f9 information compl\u00e9mentaire pour ceux qui voudraient en savoir plus.</p> <p>Avertissement</p> <p>Point important \u00e0 faire attention qui source d'erreur fr\u00e9quente.</p> <p>Danger</p> <p>Note importante qui comporte des risques \u00e0 consid\u00e9rer.</p> <p>Exemple</p> <p>Exemple pratique pour illustrer un concept.</p> <p>Note</p> <p>Corollaire \u00e0 retenir.</p> <p>Astuce</p> <p>Truc ou Astuce pour faciliter la compr\u00e9hension.</p> <p>Bogue</p> <p>Limitations ou bugs possibles d'une m\u00e9thode propos\u00e9e.</p> <p>Exercise\u2009: Quelle ic\u00f4ne\u2009?</p> <p>Quelle ic\u00f4ne est utilis\u00e9e pour les exercices\u2009?</p>"}, {"location": "course-c/00-preface/#anglicismes", "title": "Anglicismes", "text": "<p>Parler l'informatique ou de technologies sans utiliser d'anglicismes est un exercice difficile. Il est parfois moins lourd de parler de hardware que de mat\u00e9riel informatique. Certains termes n'ont pas de traduction en fran\u00e7ais. Par exemple, le terme set appliqu\u00e9 \u00e0 un ensemble de donn\u00e9es n'a pas de traduction cr\u00e9dible en fran\u00e7ais. La table  quelques termes qui seront utilis\u00e9s dans cet ouvrage\u2009:</p>  Anglicismes Anglais Fran\u00e7ais Pr\u00e9f\u00e9rence hardware mat\u00e9riel informatique hardware software logiciel informatique software byte octet byte set ensemble set pipe tube pipe stream flux de donn\u00e9es stream listing extrait de code listing process processus processus seekable positionnable seekable <p></p> <p>Notons que byte et octet ne sont pas exactement synonymes. Un byte est un ensemble g\u00e9n\u00e9ralement admis de 8 bits mais dont la taille a pu varier selon les ann\u00e9es, alors qu'un octet est un ensemble de 8 bits sans exception. En pratique, les deux termes sont souvent utilis\u00e9s de mani\u00e8re interchangeable. En anglais il n'existe pas de mot pour octet.</p> <p>Les termes anglais sont g\u00e9n\u00e9ralement indiqu\u00e9s en italique.</p>"}, {"location": "course-c/00-preface/#copyright-et-references", "title": "Copyright et r\u00e9f\u00e9rences", "text": "<p>Le contenu de ce livre est sous licence Creative Commons. Vous \u00eates libre de partager et d'adapter ce contenu pour toute utilisation, m\u00eame commerciale, \u00e0 condition de citer l'auteur et de partager vos travaux d\u00e9riv\u00e9s sous la m\u00eame licence.</p> <p>De nombreuses r\u00e9f\u00e9rences et sources de ce livre sont issues de Wikipedia, de la documentation officielle de la norme C, de StackOverflow, de forums de discussion et de blogs.</p>"}, {"location": "course-c/00-preface/#comment-contribuer", "title": "Comment contribuer\u2009?", "text": "<p>Vous avez remarqu\u00e9 une erreur, une faute de frappe ou une information manquante\u2009? Vous auriez d\u00e9sir\u00e9 une explication plus d\u00e9taill\u00e9e sur un sujet\u2009? Vous pouvez contribuer \u00e0 l'am\u00e9lioration de ce livre en soumettant une issue. Alternativement, vous pouvez faire un fork du projet et proposer une pull request.</p>"}, {"location": "course-c/00-preface/#colophon", "title": "Colophon", "text": "<p>Ce livre est \u00e9crit en Markdown et g\u00e9n\u00e9r\u00e9 en HTML par MkDocs. Le th\u00e8me utilis\u00e9 est Material for MkDocs. Les sources sont disponibles sur GitHub et l'h\u00e9bergement est assur\u00e9 par GitHub Pages.</p> <p>La plupart des illustrations sont r\u00e9alis\u00e9es avec Draw.io, un outil de dessin vectoriel en ligne. Les sch\u00e9mas sont rendus dans le navigateur avec <code>GraphViewer</code>. Les diagrammes utilisent la technologie Mermaid. Les autres sources d'images sont issues en grande partie de Wikimedia Commons et Wikipedia.</p> <p>La g\u00e9n\u00e9ration de l'ouvrage en PDF est utilise son propre convertisseur vers LaTeX. Les extraits de code sources sont color\u00e9s avec Pygments en utilisant le paquet minted.</p> <p>L'orthographe et la grammaire ont \u00e9t\u00e9 revues avec Antidote.</p>"}, {"location": "course-c/05-introduction/c-lang/", "title": "Le langage C", "text": "C is quirky, flawed, and an enormous success.Dennis Ritchie <p>Le langage C est l'un des premiers langages de programmation dit de haut niveau. Il est tr\u00e8s proche de l'assembleur\u2009: le langage de bas niveau des processeurs. Le C permet de programmer des applications tr\u00e8s performantes. Il est utilis\u00e9 dans de nombreux domaines de l'informatique, de l'embarqu\u00e9 \u00e0 la programmation de syst\u00e8me complexe \u00e0 la simple machine \u00e0 caf\u00e9.</p> <p>M\u00eame s'il est tr\u00e8s ancien (1972), il continue d'\u00eatre utilis\u00e9 et enseign\u00e9, car il est tr\u00e8s efficace et permet de comprendre les bases de la programmation.</p> <p>\u00c0 vrai dire, en 2024, il n'y a pas d'alternative viable au C pour programmer des applications embarqu\u00e9es, des syst\u00e8mes d'exploitation ou des applications n\u00e9cessitant des performances \u00e9lev\u00e9es.</p> <p></p>"}, {"location": "course-c/05-introduction/c-lang/#historique", "title": "Historique", "text": "<p>En 1964 na\u00eet, d'une collaboration avec les laboratoires Bell (Bell Telephone Laboratories), General Electric et le MIT, le projet Multics (Multiplexed Information and Computing Service), qui vise le d\u00e9veloppement d'un nouveau syst\u00e8me d'exploitation.</p> <p>Malheureusement, la fin de la d\u00e9cennie est assez tumultueuse car les laboratoires Bell, ne croyant plus aux promesses de Multics, d\u00e9cid\u00e8rent de se retirer du projet pour cr\u00e9er leur propre syst\u00e8me d'exploitation. Un groupe informel, dirig\u00e9 notamment par Ken Thompson et Dennis Ritchie, souhaitait revoir et am\u00e9liorer certains concepts de Multics qu'ils n'appr\u00e9ciaient pas. Notamment le langage de programmation PL/I (Programming Language number 1), pourtant alors dominant pour l'\u00e9criture de syst\u00e8mes d'exploitation. Ken Thompson avait d\u00e9velopp\u00e9 le langage B, largement inspir\u00e9 de BCPL, mais dans lequel il supprima tout ce qu'il ne pensait pas \u00eatre essentiel pour pouvoir \u00eatre utilis\u00e9 sur de petits ordinateurs. L'un comme l'autre n'avaient qu'un seul type de donn\u00e9e, \u00e0 savoir le \u00ab\u2009mot\u2009\u00bb (word).</p> <p>BCPL, qui fut con\u00e7u par Martin Richards au milieu des ann\u00e9es 1960 pendant qu'il \u00e9tait en visite au MIT, n'est autre que le grand-p\u00e8re de B et l'arri\u00e8re-grand-p\u00e8re de C. Dennis Ritchie, alors coll\u00e8gue de Ken Thompson, retravailla B pour y ajouter la gestion des types de donn\u00e9es.</p> <p>Ce syst\u00e8me d'exploitation que Ken Thompson et Dennis Ritchie d\u00e9veloppaient au sein des laboratoires Bell se nommait initialement UNICS, en contradiction de Multics, l\u00e0 o\u00f9 Multiplexed fut remplac\u00e9 par Uniplexed. Le nom fut ensuite modifi\u00e9 en UNIX, qui fut central dans l'histoire de l'informatique.</p> <p>Par la suite, Brian Kernighan aida \u00e0 populariser ce nouveau langage. Il est le principal auteur du livre \u00ab\u2009The C Programming Language\u2009\u00bb, tandis que Dennis Ritchie s'est davantage occup\u00e9 des annexes.</p> <p>Les \u00e9volutions continuerons plus tard avec Bjarne Stroustrup qui d\u00e9cidera d'\u00e9tendre C en apportant une saveur nouvelle\u2009: la programmation orient\u00e9e objet (OOP), qui fait l'objet d'un autre cours.</p> <p> Les p\u00e8res fondateurs du C</p> <p>Il faut attendre 1989 pour que le langage C fasse l'objet d'une normalisation par l'ANSI (American National Standards Institute). L'ann\u00e9e suivante le comit\u00e9 ISO (International Organization for Standardization) ratifie le standard ISO/IEC 9899:1990 commun\u00e9ment appel\u00e9 C90. D\u00e8s lors, le langage C est devenu un standard international et devient le langage dominant dans le monde de l'informatique.</p> <p></p><pre><code>%% Influences des langages de programmation\nflowchart LR\n    COBOL --&gt; PLI[\"PL/I\"]\n    FORTRAN --&gt; ALGOL\n    ALGOL --&gt; CPL\n    CPL --&gt; BCPL\n    ALGOL --&gt; SIMULA\n    ALGOL --&gt; PASCAL\n    FORTRAN --&gt; PASCAL\n    FORTRAN --&gt; PLI\n    BCPL --&gt; B\n    ALGOL --&gt; PLI\n    PLI --&gt; C(\"C\")\n    B --&gt; C</code></pre> Les ann\u00e9es se succ\u00e8dent et le standard \u00e9volue pour soit corriger certaines de ses faiblesses soit pour apporter de nouvelles fonctionnalit\u00e9s. <p>Cinquante ans plus tard, C est toujours l'un des langages de programmation les plus utilis\u00e9s par les ing\u00e9nieurs, car il allie une bonne vision de haut niveau tout en permettant des manipulations de tr\u00e8s bas niveau, de fait il est un langage de choix pour les applications embarqu\u00e9es \u00e0 microcontr\u00f4leurs, ou lorsque l'optimisation du code est n\u00e9cessaire pour obtenir de bonnes performances telles que les noyaux des syst\u00e8mes d'exploitation comme le noyau Linux (Kernel) ou le noyau Windows.</p> <p>Il faut retenir que C est un langage simple et efficace. Votre machine \u00e0 caf\u00e9, votre voiture, vos \u00e9couteurs Bluetooth ont tr\u00e8s probablement \u00e9t\u00e9 programm\u00e9s en C.</p>"}, {"location": "course-c/05-introduction/c-lang/#standardisation", "title": "Standardisation", "text": "<p>Le langage C poss\u00e8de un grand historique, et il a fallu attendre pr\u00e8s de 20 ans apr\u00e8s sa cr\u00e9ation pour voir appara\u00eetre la premi\u00e8re standardisation internationale.</p> <p>Le standard le plus couramment utilis\u00e9 en 2024 est encore C99. C11 le remplace peu \u00e0 peu dans l'industrie, mais la saga continue avec C17, C18 et C23 qui sont des \u00e9volutions.</p>  Normes internationales du langage C Notation courte Standard international Date C n/a 1972 K&amp;R C n/a 1978 C89 (ANSI C) ANSI X3.159-1989 1989 C90 ISO/IEC 9899:1990 1990 C99 ISO/IEC 9899:1999 1999 C11 ISO/IEC 9899:2011 2011 C17/C18 ISO/IEC 9899:2018 2018 C23 ISO/IEC 9899:2023 2023 <p>En substance, C18 n'apporte pas de nouvelles fonctionnalit\u00e9s au langage, mais vise \u00e0 clarifier de nombreuses zones d'ombres laiss\u00e9es par C11.</p> <p>C11 apporte peu de grands changements fondamentaux pour le d\u00e9veloppement sur microcontr\u00f4leur.</p> <p>Info</p> <p>Vous entendrez ou lirez souvent des r\u00e9f\u00e9rences \u00e0 ANSI C ou K&amp;R, pr\u00e9f\u00e9rez plut\u00f4t une compatibilit\u00e9 avec C99 au minimum.</p> <p>Le standard est lourd, difficile \u00e0 lire et avec 552 pages pour C99, vous n'aurez probablement jamais le moindre plaisir \u00e0 y plonger les yeux qui se rempliront de larmes \u00e0 chaque lecture.</p> <p>Armez-vous de mouchoirs, car l'investissement est pourtant parfois n\u00e9cessaire pour comprendre certaines subtilit\u00e9s du langage qui sont rarement expliqu\u00e9es dans les livres. Pourquoi diable \u00e9crire un livre qui d\u00e9taille l'impl\u00e9mentation C alors qu'il existe d\u00e9j\u00e0\u2009?</p> <p>Vous vous demandez probablement\u2009: \u00ab\u2009pourquoi l'industrie a-t-elle autant de retard sur le dernier standard\u2009?\u2009\u00bb Lorsque Apple annonce sa derni\u00e8re mouture d'iOS, chacun s'empresse de l'installer. En revanche, dans le milieu industriel, les machines et les processus sont r\u00e9gl\u00e9s par des validations strictes qui d\u00e9crivent les standards utilis\u00e9s. Migrer vers un standard plus r\u00e9cent est une aventure. Il faut mettre \u00e0 jour le code, faire des tests, encore et tests, et toujours plus de tests pour s'assurer que la fus\u00e9e qu'on enverra sur Mars n'aura pas d'issue fatale. Ces validations sont longues et fastidieuses autant administrativement que techniquement. Ce qui est long est cher et bien souvent, les entreprises pr\u00e9f\u00e8rent rester fid\u00e8les \u00e0 un ancien standard.</p> <p>Exercise</p> <p>Ouvrez le standard C99 et cherchez la valeur maximale possible de la constante <code>ULLONG_MAX</code>. Que vaut-elle\u2009?</p> Solution <p>Au paragraphe \u00a75.2.4.2.1-1 on peut lire que <code>ULLONG_MAX</code> est encod\u00e9 sur 64-bits et donc que sa valeur est \\(2^{64}-1\\) donc <code>18'446'744'073'709'551'615</code>.</p>"}, {"location": "course-c/05-introduction/c-lang/#le-c-et-les-autres", "title": "Le C et les autres...", "text": "<p>Si ce cours se concentre sur le C, ce n'est pas le seul langage de programmation et surtout ce n'est certainement pas le seul que vous apprendrez.</p> <p>Voici une liste non exhaustive de langages de programmation et de leur ann\u00e9e de cr\u00e9ation. Cette liste est int\u00e9ressante pour comprendre l'\u00e9volution des langages de programmation et leur utilisation\u2009:</p>  Langages de programmation et leur ann\u00e9e de cr\u00e9ation Langage de programmation Ann\u00e9e Utilisation Fortran 1957 Calcul scientifique Lisp 1958 Intelligence artificielle Cobol 1959 Finance, banque Basic 1964 Enseignement Pascal 1970 Enseignement C 1972 Syst\u00e8mes embarqu\u00e9s C++ 1985 Applications lourdes Perl 1987 Scripts Python 1991 Ing\u00e9nierie, sciences Ruby 1995 Scripts, Web Java 1995 Applications lourdes PHP 1995 Web C# 2000 Applications graphiques Go 2009 Syst\u00e8mes distribu\u00e9s Rust 2010 Syst\u00e8mes embarqu\u00e9s Swift 2014 Applications mobiles Zig 2016 Syst\u00e8mes embarqu\u00e9s <p>L'index TIOBE est un bon indicateur de la popularit\u00e9 des langages de programmation. Il est mis \u00e0 jour chaque mois et permet de suivre l'\u00e9volution de la popularit\u00e9 des langages de programmation.</p> <p>En 2024, le top 10 des langages de programmation les plus populaires est le suivant\u2009:</p>  Top 10 des langages de programmation en 2024 Top 10 Langage de programmation 1 Python 2 C++ 3 C 4 Java 5 C# 6 JavaScript 7 Go 8 SQL 9 Visual Basic 10 Fortran <p>Python est un langage de tr\u00e8s haut niveau, simple \u00e0 apprendre, mais \u00e9loign\u00e9 du mat\u00e9riel. C++ est un langage de programmation orient\u00e9e objet, tr\u00e8s puissant, mais complexe \u00e0 apprendre. C est un excellent compromis entre les deux, il est simple, mais permet de comprendre les bases de la programmation et de la manipulation du mat\u00e9riel. C'est pour cela que ce cours est bas\u00e9 sur le langage C. J'esp\u00e8re avoir r\u00e9ussi \u00e0 vous convaincre.</p> <p></p>"}, {"location": "course-c/05-introduction/c-lang/#programmation-texte-structuree", "title": "Programmation texte structur\u00e9e", "text": "<p>Le C comme la plupart des langages de programmation utilise du texte structur\u00e9, c'est-\u00e0-dire que le langage peut \u00eatre d\u00e9fini par un vocabulaire, une grammaire et se compose d'un alphabet.</p> <p>\u00c0 l'inverse des langages naturels comme le Fran\u00e7ais, un langage de programmation est un langage formel et se veut exact dans sa grammaire et son vocabulaire, il n'y a pas de cas particuliers ni d'ambigu\u00eft\u00e9s possibles dans l'\u00e9criture.</p> <p>Les compilateurs sont ainsi construits autour d'une grammaire du langage qui est r\u00e9duite au minimum par souci d'\u00e9conomie de m\u00e9moire, pour taire les ambigu\u00eft\u00e9s et accro\u00eetre la productivit\u00e9 du d\u00e9veloppeur.</p> <p></p> <p>L'exemple suivant est un pseudo-code utilisant une grammaire simple\u2009:</p> <pre><code>POUR CHAQUE oeuf DANS le panier :\n    jaune, blanc \ud83e\udc14 CASSER(oeuf)\n    omelette \ud83e\udc14 MELANGER(jaune, blanc)\n    omelette_cuite \ud83e\udc14 CUIRE(omelette)\n\nSERVIR(omelette_cuite)\n</code></pre> <p>La structure de la phrase permettant de traiter tous les \u00e9l\u00e9ments d'un ensemble d'\u00e9l\u00e9ments peut alors s'\u00e9crire\u2009:</p> <pre><code>POUR CHAQUE \u301c DANS \u301c:\n    \u301c\n</code></pre> <p>O\u00f9 les <code>\u301c</code> sont des marques substitutives (placeholder) qui seront remplac\u00e9es par le d\u00e9veloppeur par ce qui convient.</p> <p>Les grammaires des langages de programmation sont souvent formalis\u00e9es \u00e0 l'aide d'un m\u00e9talangage, c'est-\u00e0-dire un langage qui permet de d\u00e9crire un langage. La grammaire du langage C utilis\u00e9 dans ce cours peut ainsi s'exprimer en utilisant la forme Backus-Naur ou BNF disponible en annexe.</p> <p></p>"}, {"location": "course-c/05-introduction/c-lang/#les-paradigmes-de-programmation", "title": "Les paradigmes de programmation", "text": "<p>Chaque langage de programmation que ce soit C, C++, Python, ADA, COBOL et Lisp sont d'une mani\u00e8re g\u00e9n\u00e9rale assez proche les uns des autres. Nous citions par exemple le langage B, pr\u00e9curseur du C (c.f. [thompson]{c-history}). Ces deux langages, et bien que leurs syntaxes soient diff\u00e9rentes, ils demeurent assez proches, comme l'espagnol et l'italien qui partagent des racines latines. En programmation on dit que ces langages partagent le m\u00eame paradigme de programmation.</p> <p>Certains paradigmes sont plus adapt\u00e9s que d'autres \u00e0 la r\u00e9solution de certains probl\u00e8mes et de nombreux langages de programmation sont dit multi-paradigmes, c'est-\u00e0-dire qu'ils supportent diff\u00e9rents paradigmes.</p> <p>Nous citions plus haut le C++ qui permet la programmation orient\u00e9e objet, laquelle est un paradigme de programmation qui n'existe pas en C.</p> <p>Ce qu'il est essentiel de retenir c'est qu'un langage de programmation peut ais\u00e9ment \u00eatre substitu\u00e9 par un autre pour autant qu'ils s'appuient sur les m\u00eames paradigmes.</p> <p>Le langage C r\u00e9pond aux paradigmes suivants\u2009:</p> Imp\u00e9ratif <p>programmation en s\u00e9quences de commandes, qui se lisent de haut en bas.</p> Structur\u00e9 <p>programmation imp\u00e9rative avec des structures de contr\u00f4le imbriqu\u00e9es, comme les boucles et les conditions.</p> Proc\u00e9dural <p>programmation imp\u00e9rative avec appels de proc\u00e9dures qui regroupent des instructions.</p> <p>Le C++ quant \u00e0 lui apporte les paradigmes suivants \u00e0 C\u2009:</p> Fonctionnel <p>programmation bas\u00e9e sur l'appel de fonction. Utilis\u00e9 dans les langages Lisp, Haskell, Erlang.</p> Orient\u00e9 objet <p>programmation bas\u00e9e sur la d\u00e9finition de classes et d'objets. Utilis\u00e9 dans les langages C++, Java, Python. Une classe associe des donn\u00e9es a des actions qui manipulent ces donn\u00e9es.</p> <p>Des langages de plus haut niveau comme Python ou C# apportent davantage de paradigmes comme la programmation r\u00e9flective.</p> <p>Ce que nous devons retenir c'est que le langage C est imp\u00e9ratif et proc\u00e9dural, c'est-\u00e0-dire qu'il est bas\u00e9 sur des s\u00e9quences d'instructions qui se lisent de haut en bas, lesquelles peuvent \u00eatre regroup\u00e9es en proc\u00e9dures. Si nous reprenons notre exemple de l'omelette, si nous souhaitons r\u00e9aliser une p\u00e2te \u00e0 cr\u00eapes nous pourrions \u00e9crire\u2009:</p> <pre><code>POUR REALISER un oeuf:\n    CHERCHER poule\n    oeuf \ud83e\udc14 PONDRE(poule)\n\nPOUR REALISER du lait:\n    CHERCHER vache\n    lait \ud83e\udc14 TRAITRE(vache)\n\nPOUR REALISER de la farine:\n    PLANTER bl\u00e9\n    ATTENDRE 6 mois\n    moisson \ud83e\udc14 MOISSONNER(bl\u00e9)\n    farine \ud83e\udc14 MOUDRE(moisson)\n\nPOUR REALISER une p\u00e2te \u00e0 cr\u00e8pes:\n    oeuf \ud83e\udc14 REALISER(oeuf)\n    jaune, blanc \ud83e\udc14 CASSER(oeuf)\n    oeuf-liquide \ud83e\udc14 MELANGER(jaune, blanc)\n    farine \ud83e\udc14 REALISER(farine)\n    lait \ud83e\udc14 REALISER(lait)\n    p\u00e2te \ud83e\udc14 MELANGER(oeuf-liquide, farine, lait)\n</code></pre> <p>On a regroup\u00e9 des instructions en proc\u00e9dures pour r\u00e9aliser une p\u00e2te \u00e0 cr\u00eapes. C'est ce que l'on appelle la programmation proc\u00e9durale.</p>"}, {"location": "course-c/05-introduction/c-lang/#cycle-de-developpement", "title": "Cycle de d\u00e9veloppement", "text": "<p>Le cycle de d\u00e9veloppement logiciel comprend la suite des \u00e9tapes menant de l'\u00e9tude et l'analyse d'un probl\u00e8me jusqu'\u00e0 la r\u00e9alisation d'un programme informatique ex\u00e9cutable. Dans l'industrie, il existe de nombreux mod\u00e8les comme le Cycle en V ou le mod\u00e8le en cascade. Quel que soit le mod\u00e8le utilis\u00e9, il comprendra les \u00e9tapes suivantes\u2009:</p> <ol> <li>\u00c9tude et analyse du probl\u00e8me</li> <li>\u00c9criture d'un cahier des charges (sp\u00e9cifications)</li> <li>\u00c9criture de tests \u00e0 r\u00e9aliser pour tester le fonctionnement du programme</li> <li>Conception d'un algorithme</li> <li>Transcription de cet algorithme en utilisant le langage C</li> <li>Compilation du code et g\u00e9n\u00e9ration d'un ex\u00e9cutable</li> <li>Test de fonctionnement</li> <li>V\u00e9rification que le cahier des charges est respect\u00e9</li> <li>Livraison du programme</li> </ol> <p>Mis \u00e0 part la derni\u00e8re \u00e9tape o\u00f9 il n'y a pas de retour en arri\u00e8re possible, les autres \u00e9tapes sont it\u00e9ratives. Il est tr\u00e8s rare d'\u00e9crire un programme juste du premier coup. Durant tout le cycle de d\u00e9veloppement logiciel, des it\u00e9rations successives sont faites pour permettre d'optimiser le programme, de r\u00e9soudre des bogues, d'affiner les sp\u00e9cifications, d'\u00e9crire davantage de tests pour renforcer l'assurance d'un bon fonctionnement du programme et \u00e9viter une coul\u00e9e de lave .</p> <p>Le mod\u00e8le en cascade suivant r\u00e9sume le cycle de d\u00e9veloppement d'un programme. Il s'agit d'un mod\u00e8le simple, mais qu'il faut garder \u00e0 l'esprit que ce soit pour le d\u00e9veloppement d'un produit logiciel que durant les travaux pratiques li\u00e9s \u00e0 ce cours.</p> <p> Mod\u00e8le en cascade</p>"}, {"location": "course-c/05-introduction/c-lang/#cycle-de-compilation", "title": "Cycle de compilation", "text": "<p>Le langage C \u00e0 une particularit\u00e9 que d'autres langages n'ont pas, c'est-\u00e0-dire qu'il comporte une double grammaire. Le processus de compilation s'effectue donc en deux passes.</p> <ol> <li>Pr\u00e9processeur qui enl\u00e8ve les commentaires et inclut les fichiers n\u00e9cessaires.</li> <li>Compilation du code source en fichiers objet.</li> </ol> <p>Vient ensuite la phase d'\u00e9dition des liens ou linkage lors de laquelle l'ex\u00e9cutable binaire est cr\u00e9\u00e9.</p> <p> Cycle de compilation illustr\u00e9</p> <p>Voyons plus en d\u00e9tail chacune de ces \u00e9tapes.</p>"}, {"location": "course-c/05-introduction/c-lang/#preprocesseur-pre-processing", "title": "Pr\u00e9processeur (pre-processing)", "text": "<p>La phase de preprocessing permet de g\u00e9n\u00e9rer un fichier interm\u00e9diaire en langage C dans lequel toutes les instructions n\u00e9cessaires \u00e0 la phase suivante sont pr\u00e9sentes. Le preprocessing r\u00e9alise\u2009:</p> <ul> <li>Le remplacement des d\u00e9finitions par leurs valeurs (<code>#define</code>),</li> <li>Le remplacement des fichiers inclus par leurs contenus (<code>#include</code>),</li> <li>La conservation ou la suppression des zones de compilation conditionnelles (<code>#if</code>, <code>#ifdef</code>, <code>#elif</code>, <code>#else</code>, <code>#endif</code>).</li> <li>La suppression des commentaires (<code>/* ... */</code>, <code>// ...</code>)</li> </ul> <p>Avec <code>gcc</code> il est possible de demander que l'ex\u00e9cution du pr\u00e9processeur en utilisant l'option <code>-E</code>.</p> <p> Processus de pr\u00e9pressing</p>"}, {"location": "course-c/05-introduction/c-lang/#compilation-build", "title": "Compilation (build)", "text": "<p>La phase de compilation consiste en une analyse syntaxique du fichier \u00e0 compiler puis en sa traduction en langage assembleur pour le processeur cible. Le fichier g\u00e9n\u00e9r\u00e9 est un fichier binaire (extension <code>.o</code> ou <code>.obj</code>) qui sera utilis\u00e9 pour la phase suivante. Lors de la compilation, des erreurs peuvent survenir et emp\u00eacher le d\u00e9roulement complet de la g\u00e9n\u00e9ration de l'ex\u00e9cutable final. L\u00e0 encore, la correction des erreurs passe toujours par un examen minutieux des messages d'erreur, en commen\u00e7ant toujours par le premier.</p> <p>Avec <code>gcc</code> il est possible de ne demander que l'assemblage d'un code avec l'option <code>-S</code>.</p> <p> Assemblage d'un programme C pr\u00e9-process\u00e9 en assembleur</p> <p> Traduction d'un programme C pr\u00e9-process\u00e9 en objet binaire</p>"}, {"location": "course-c/05-introduction/c-lang/#edition-de-liens-link", "title": "\u00c9dition de liens (link)", "text": "<p>La phase d'\u00e9dition de liens permet de rassembler le fichier binaire issu de la compilation et les autres fichiers binaires n\u00e9cessaires au programme pour former un ex\u00e9cutable complet. Les autres fichiers binaires sont appel\u00e9s des librairies. Elles peuvent appartenir au syst\u00e8me (install\u00e9e avec l'environnement de d\u00e9veloppement) ou provenir d'autres applications avec lesquelles votre programme doit interagir. Lors de l'\u00e9dition de liens, des erreurs peuvent survenir et emp\u00eacher le d\u00e9roulement complet de g\u00e9n\u00e9ration de l'ex\u00e9cutable final. L\u00e0 encore, la correction des erreurs passe toujours par un examen minutieux des messages d'erreur, en commen\u00e7ant toujours par le premier.</p> <p> \u00c9dition des liens de plusieurs objets</p> <p></p>"}, {"location": "course-c/05-introduction/c-lang/#hello-world_1", "title": "Hello World\u2009!", "text": "<p>Il est traditionnellement coutume depuis la publication en 1978 du livre The C Programming Language de reprendre l'exemple de Brian Kernighan comme premier programme.</p> Exercise\u2009: hello.c<pre><code>#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    printf(\"hello, world\\n\");\n    return 0;\n}\n</code></pre> <p>Ce programme est compos\u00e9 de deux parties. L'inclusion de la library standard d'entr\u00e9es sorties (STandarD Inputs Outputs) qui d\u00e9finit la fonction <code>printf</code>, et le programme principal nomm\u00e9 <code>main</code>. Tout ce qui se situe \u00e0 l'int\u00e9rieur des accolades <code>{ }</code> appartient au programme <code>main</code>.</p> <p>L'ensemble que d\u00e9finit <code>main</code> et ses accolades est appel\u00e9 une fonction, et la t\u00e2che de cette fonction est ici d'appeler une autre fonction <code>printf</code> dont le nom vient de print formatted.</p> <p>L'appel de <code>printf</code> prend en param\u00e8tre le texte <code>Hello world!\\n</code> dont le <code>\\n</code> repr\u00e9sente un retour \u00e0 la ligne.</p> <p>Une fois le code \u00e9crit, il faut le compiler. Pour bien comprendre ce que l'on fait, utilisons la ligne de commande\u2009; plus tard, l'IDE se chargera de l'op\u00e9ration automatiquement.</p> <p>Une console lanc\u00e9e ressemble \u00e0 ceci, c'est intimidant si l'on n\u2019en a pas l'habitude, mais vraiment puissant.</p> <pre><code>$\n</code></pre> <p>La premi\u00e8re \u00e9tape est de s'assurer que le fichier <code>test.c</code> contient bien notre programme. Pour ce faire on utilise un autre programme [cat]https://fr.wikipedia.org/wiki/Cat_(Unix)) qui ne fait rien d'autre que lire le fichier pass\u00e9 en argument et de l'afficher sur la console\u2009:</p> <pre><code>$ cat hello.c\n#include &lt;stdio.h&gt;\n\nint main( )\n{\n    printf(\"hello, world\");\n}\n</code></pre> <p>\u00c0 pr\u00e9sent on peut utiliser notre compilateur par d\u00e9faut\u2009: <code>cc</code> pour C Compiler. Ce compilateur prend en argument un fichier C et sans autre option, il g\u00e9n\u00e8rera un fichier a.out pour assembler output. C'est un fichier ex\u00e9cutable que l'on peut donc ex\u00e9cuter.</p> <pre><code>$ gcc hello.c\n</code></pre> <p>Il ne s'est rien pass\u00e9, c'est une bonne nouvelle. La philosophie Unix est qu'un programme soit le plus discret possible, comme tout s'est bien pass\u00e9, inutile d'informer l'utilisateur.</p> <p>On s'attend donc \u00e0 trouver dans le r\u00e9pertoire courant, notre fichier source ainsi que le r\u00e9sultat de la compilation. Utilisons le programme ls pour le v\u00e9rifier.</p> <pre><code>$ ls\nhello.c       a.out\n</code></pre> <p>Tr\u00e8s bien\u2009! \u00c0 pr\u00e9sent, ex\u00e9cutons le programme en prenant soin de pr\u00e9fixer le nom par, <code>./</code> car \u00e9tant un programme local <code>a.out</code> ne peut pas \u00eatre acc\u00e9d\u00e9 directement. Imaginons qu'un fourbe hackeur ait d\u00e9cid\u00e9 de cr\u00e9er dans ce r\u00e9pertoire un programme nomm\u00e9 <code>ls</code> qui efface toutes vos donn\u00e9es. La ligne de commande ci-dessus aurait eu un effet d\u00e9sastreux. Pour rem\u00e9dier \u00e0 ce probl\u00e8me de s\u00e9curit\u00e9, tout programme local doit \u00eatre explicitement nomm\u00e9.</p> <pre><code>$ ./a.out\nhello, world\n</code></pre> <p>F\u00e9licitations, le programme s'est ex\u00e9cut\u00e9.</p> <p>Pouvons-nous en savoir plus sur ce programme\u2009? On pourrait s'int\u00e9resser \u00e0 la date de cr\u00e9ation de ce programme ainsi qu'\u00e0 sa taille sur le disque. Une fois de plus <code>ls</code> nous sera utile, mais cette fois-ci avec l'option <code>l</code>:</p> <pre><code>$ ls -l a.out\n-rwxr-xr-- 1 ycr iai 8.2K Jul 24 09:50 a.out*\n</code></pre> <p>D\u00e9cortiquons tout cela\u2009:</p> <pre><code>-             Il s'agit d'un fichier\nrwx           Lisible (r), \u00c9ditable (w) et Ex\u00e9cutable (x) par le propri\u00e9taire\nr-x           Lisible (r) et Ex\u00e9cutable (x) par le groupe\nr--           Lisible (r) par les autres utilisateurs\n1             Nombre de liens mat\u00e9riels pour ce fichier\nycr           Nom du propri\u00e9taire\niai           Nom du groupe\n8.2K          Taille du fichier, soit 8200 bytes soit 65'600 bits\nJul 24 09:50  Date de cr\u00e9ation du fichier\na.out         Nom du fichier\n</code></pre> <p>Note</p> <p>Les puristes peuvent se demander s'il faut \u00e9crire <code>hello, world</code>, <code>hello, world!</code> ou <code>Hello, world!\\n</code>. Dans son livre, Brian Kernighan a choisi <code>hello, world\\n</code> et c'est ce que nous avons repris ici.</p> <p>Outre le caract\u00e8re pinailleur de cette remarque qui pr\u00eate attention aux d\u00e9tails, il peut \u00eatre not\u00e9 que la casse des caract\u00e8res est importante en informatique. <code>Hello</code> n'est pas la m\u00eame chose que <code>hello</code>, le stockage en m\u00e9moire n'est pas le m\u00eame, et donc le r\u00e9sultat de l'ex\u00e9cution d'un programme peut \u00eatre diff\u00e9rent.</p> <p>Il est donc essentiel d'avoir l'oeil sur ces d\u00e9tails, vous le verrez par la suite, vous d\u00e9velopperez une certaine facilit\u00e9 \u00e0 rep\u00e9rer les <code>;</code> manquants, les <code>{}</code> mal plac\u00e9es, les <code>==</code> qui devraient \u00eatre <code>=</code>, etc.</p> <p>Mais avant tout, c'est la coh\u00e9rence de l'ensemble qui doit primer. Si vous avez choisi d'\u00e9crire <code>Hello, World!</code>, alors \u00e9crivez-le partout de la m\u00eame mani\u00e8re, dans tous vos exemples, dans tous vos commentaires, dans toute votre documentation.</p>"}, {"location": "course-c/05-introduction/c-lang/#exercices-de-revision", "title": "Exercices de R\u00e9vision", "text": "<p>Exercise\u2009: Hello World</p> <p>Pouvez-vous \u00e9crire, puis compiler votre premier programme en C\u2009? R\u00e9diger le programme <code>hello.c</code> qui affiche <code>Hello, World!</code> \u00e0 l'\u00e9cran.</p> <p>Ex\u00e9cutez le programme et v\u00e9rifiez que le message s'affiche bien.</p> <p>Exercise\u2009: Auteurs</p> <p>Qui a invent\u00e9 le C\u2009?</p> <ul> <li>     Ken Thompson </li> <li>     Brian Kernighan </li> <li>     Bjarne Stroustrup </li> <li>     Linus Torvalds </li> <li>     Dennis Ritchie </li> <li>     Guido van Rossum </li> </ul> <p>Exercise\u2009: Standardisation</p> <p>Quel est le standard C \u00e0 utiliser dans l'industrie en 2024 et pourquoi\u2009?</p> <ul> <li>     C89 </li> <li> C99 </li> <li>     C11 </li> <li>     C17 </li> <li>     C23 </li> </ul> Solution <p>Le standard industriel, malgr\u00e9 que nous soyons en 2024 est toujours ISO/IEC 9899:2017, car peu de changements majeurs ont \u00e9t\u00e9 apport\u00e9s au langage depuis et les entreprises pr\u00e9f\u00e8rent migrer sur C++ plut\u00f4t que d'adopter un standard plus r\u00e9cent qui n'apporte que peu de changements.</p> <p>Exercise\u2009: Paradigmes</p> <p>Quels est le paradigme de programmation support\u00e9s par C\u2009?</p> <ul> <li>     Fonctionnel </li> <li>     Orient\u00e9 objet </li> <li>     R\u00e9flectif </li> <li>     Imp\u00e9ratif </li> <li>     D\u00e9claratif </li> </ul> Solution <p>C supporte les paradigmes imp\u00e9ratifs, structur\u00e9s et proc\u00e9dural.</p> <p>Exercise\u2009: Langage imp\u00e9ratif</p> <p>Pourriez-vous d\u00e9finir ce qu'est la programmation imp\u00e9rative\u2009?</p> Solution <p>La programmation imp\u00e9rative consiste en des s\u00e9quences de commandes ordonn\u00e9es. C'est-\u00e0-dire que les s\u00e9quences sont ex\u00e9cut\u00e9es dans un ordre d\u00e9finis les unes \u00e0 la suite d\u2019autres.</p> <p>Exercise\u2009: Coul\u00e9e de lave</p> <p>Qu'est-ce qu'une coul\u00e9e de lave en informatique\u2009?</p> Solution <p>Lorsqu'un code immature est mis en production, l'industriel qui le publie risque un retour de flamme d\u00fb aux bogues et m\u00e9contentement des clients. Afin d'\u00e9viter une coul\u00e9e de lave il est important qu'un programme soit test\u00e9 et soumis \u00e0 une \u00e9quipe de beta-testing qui s'assure qu'outre le respect des sp\u00e9cifications initiales, le programme soit utilisable facilement par le public cible. Il s'agit aussi d'\u00e9tudier l'ergonomie du programme.</p> <p>Un programme peut respecter le cahier des charges, \u00eatre convenablement test\u00e9, fonctionner parfaitement, mais \u00eatre difficile \u00e0 l'utilisation, car certaines fonctionnalit\u00e9s sont peu ou pas document\u00e9es. La surcharge du service de support par des clients perdus peut \u00e9galement \u00eatre assimil\u00e9e \u00e0 une coul\u00e9e de lave.</p> <p>Exercise\u2009: Cat</p> <p>Qu'est-ce que <code>cat</code>?</p> <ul> <li>     Un programme de chat </li> <li>     Un programme de compilation </li> <li>     Un programme d'affichage de fichiers </li> <li>     Un programme de copie de fichiers </li> <li>     Un programme de recherche de fichiers </li> </ul> Solution <p><code>cat</code> est un programme normalis\u00e9 POSIX prenant en entr\u00e9e un fichier et l'affichant \u00e0 l'\u00e9cran. Il est utilis\u00e9 notamment dans cet ouvrage pour montrer que le contenu du fichier <code>hello.c</code> est bel et bien celui attendu.</p>"}, {"location": "course-c/05-introduction/code-of-conduct/", "title": "\u00catre d\u00e9veloppeur", "text": "<p>\u00catre d\u00e9veloppeur logiciel que ce soit professionnellement ou comme loisir, ce n'est pas simplement \u00e9crire du code. Il y a l'art et la mani\u00e8re de le faire, il y a des r\u00e8gles \u00e0 respecter, des consensus \u00e0 suivre et de bonnes pratiques \u00e0 adopter.</p> <p>J'ai vu trop souvent dans le milieu acad\u00e9mique et professionnel, des soi-disant experts ou professeurs qui inculquent \u00e0 leurs \u00e9l\u00e8ves ou coll\u00e8gues des pratiques dogmatiques bas\u00e9es sur des croyances personnelles ou des habitudes anciennes. L'informatique est une discipline vivante bas\u00e9e avant tout sur la collaboration, l'\u00e9coute et l'introspection. Il est donc essentiel d'avoir l'esprit ouvert, et de faire preuve d'humilit\u00e9.</p> <p>On ne d\u00e9veloppe pas sur des acquis et des croyances fig\u00e9es, mais sur des principes et des valeurs qui \u00e9voluent avec le temps et qui d\u00e9pendent du milieu. Un d\u00e9veloppeur web ne d\u00e9veloppera pas de la m\u00eame mani\u00e8re qu'un scientifique en Python ou un d\u00e9veloppeur embarqu\u00e9.</p> <p>Pour des projets personnels, vous d\u00e9veloppez dans votre coin, mais dans une entreprise, vous faites partie d'une \u00e9quipe. Le code que vous \u00e9crivez doit survivre \u00e0 votre d\u00e9part, il doit \u00eatre lisible, maintenable, testable, \u00e9volutif. Il doit \u00eatre conforme aux standards de l'entreprise, aux conventions de codage, aux bonnes pratiques, aux r\u00e8gles de s\u00e9curit\u00e9, aux normes de qualit\u00e9. Il doit \u00eatre document\u00e9, comment\u00e9, versionn\u00e9, archiv\u00e9. Il doit pouvoir \u00eatre partag\u00e9, diffus\u00e9, \u00e9chang\u00e9. Pour cela il existe des m\u00e9thodes de travail bien rod\u00e9es que nous allons voir dans ce cours.</p> <p>N\u00e9anmoins, les valeurs humaines fondamentales d'un d\u00e9veloppement logiciel sont bien loin des consid\u00e9rations techniques et m\u00e9thodologiques. Elles sont les m\u00eames que celles qui r\u00e9gissent la soci\u00e9t\u00e9 humaine depuis des mill\u00e9naires. Elles sont les m\u00eames que celles qui ont permis \u00e0 l'humanit\u00e9 de survivre et de prosp\u00e9rer. On peut citer parmi ces valeurs\u2009: l'ouverture d'esprit, l'humilit\u00e9, la curiosit\u00e9, la rigueur, la patience, la pers\u00e9v\u00e9rance, l'\u00e9coute, l'entraide et le partage.</p>"}, {"location": "course-c/05-introduction/code-of-conduct/#les-regles-evoluent", "title": "Les r\u00e8gles \u00e9voluent", "text": "<p>En 1750 av. J.-C., le roi Hammurabi de Babylone a promulgu\u00e9 le premier code de lois connu de l'histoire de l'humanit\u00e9. Ce code, grav\u00e9 sur une st\u00e8le de basalte, contient 282 lois qui r\u00e9gissent la vie quotidienne des habitants de la M\u00e9sopotamie. Il est consid\u00e9r\u00e9 comme l'un des premiers exemples de justice \u00e9quitable et de respect des droits de l'homme.</p> <p> Code d'Hammurabi (1750 av. J.-C.)</p> <p>N\u00e9anmoins, le terme \u00e9quitable est \u00e0 prendre avec des pincettes, car les lois de l'\u00e9poque \u00e9taient souvent tr\u00e8s s\u00e9v\u00e8res et punissaient les contrevenants par des ch\u00e2timents corporels, des mutilations, des esclavages ou des ex\u00e9cutions. La loi du talion, \u00ab\u2009\u0153il pour \u0153il, dent pour dent\u2009\u00bb, \u00e9tait souvent appliqu\u00e9e pour punir les criminels.</p> <p>Ce que l'on doit retenir c'est que comme conventions sociales, les r\u00e8gles et les consensus de l'informatique \u00e9voluent avec le temps et les bonnes pratiques d'aujourd'hui seront tout autre demain.</p> <p>En d'autres termes, ce que je vous transmet aujourd'hui dans ce cours, n'est pas une v\u00e9rit\u00e9 absolue, elle d\u00e9pend de mon contexte, de mes exp\u00e9riences et de mes valeurs. Vous devez donc les prendre avec du recul, les remettre en question et faire preuve d'esprit critique.</p>"}, {"location": "course-c/05-introduction/code-of-conduct/#langlais", "title": "L'Anglais", "text": "<p> La langue une barri\u00e8re</p> <p>En programmation, quel que soit le langage utilis\u00e9, la langue anglaise est omnipr\u00e9sente. D'une part, les mots cl\u00e9s des langages de programmation sont majoritairement emprunt\u00e9s \u00e0 l'anglais, mais souvent les outils de d\u00e9veloppement ne sont disponibles qu'en anglais. Il existe une raison \u00e0 cela. Un article de journal publi\u00e9 dans une revue locale sera certainement lu par madame Machin et monsieur Bidule, mais n'aura aucun int\u00e9r\u00eat pour les habitants de l'antipode n\u00e9o-z\u00e9landais. En programmation, le code se veut r\u00e9utilisable pour \u00e9conomiser des co\u00fbts de d\u00e9veloppement.</p> <p>On r\u00e9utilise ainsi volontiers des algorithmes \u00e9crits par un v\u00e9n\u00e9rable japonais, ou une biblioth\u00e8que de calcul matriciel d\u00e9velopp\u00e9e en Am\u00e9rique du Sud. Pour faciliter la mise en commun de ces diff\u00e9rents blocs logiciels et surtout pour que chacun puisse d\u00e9panner le code des autres, il est essentiel qu'une langue commune soit choisie et l'anglais est le choix le plus naturel.</p> <p>Aussi dans cet ouvrage, l'anglais sera privil\u00e9gi\u00e9 dans les exemples de code et les noms des symboles (variables, constantes ...), les termes techniques seront traduits lorsqu'il existe un consensus \u00e9tabli sinon l'anglicisme sera pr\u00e9f\u00e9r\u00e9. Il m'est d'ailleurs difficile, bien que ce cours soit \u00e9crit en fran\u00e7ais de parler de feu d'alerte en lieu et place de warning, car si l'un est la traduction ad hoc de l'autre, la terminologie n'a rien \u00e0 voir et pr\u00e9f\u00e8re, au risque d'un affront avec l'Acad\u00e9mie, pr\u00e9server les us et coutumes des d\u00e9veloppeurs logiciels.</p> <p>Un autre point m\u00e9ritant d'\u00eatre mentionn\u00e9 est la constante interaction d'un d\u00e9veloppeur avec internet pour y puiser des exemples, chercher des conseils, ou de l'aide pour utiliser des outils d\u00e9velopp\u00e9s par d'autres. De nombreux sites internet, la vaste majorit\u00e9 en anglais, sont d'une aide pr\u00e9cieuse pour le d\u00e9veloppeur.</p> <p>Apprenez les langues</p> <p>Ne n\u00e9gligez pas les cours de langue. Partez \u00e0 l'\u00e9tranger, lisez des livres en anglais, regardez des films en version originale, \u00e9coutez des podcasts, des conf\u00e9rences, des tutoriels en anglais\u2009: ceci vous ouvrira les portes de la connaissance.</p> <p>En outre, sans cet atout, il vous sera plus difficile de trouver un emploi, les entreprises \u00e9tant souvent internationales et les \u00e9quipes de d\u00e9veloppement multiculturelles.</p>"}, {"location": "course-c/05-introduction/code-of-conduct/#apprendre-a-pecher", "title": "Apprendre \u00e0 p\u00eacher", "text": "<p> Un p\u00e8re et son fils p\u00eachant</p> <p>Un jeune homme s'en va \u00e0 la mer avec son p\u00e8re et lui demande\u2009: \u00ab\u2009papa, j'ai faim, comment ram\u00e8nes-tu du poisson\u2009?\u2009\u00bb Le p\u00e8re, fier, lance sa ligne \u00e0 la mer et lui ram\u00e8ne un beau poisson. Plus tard, alors que le jeune homme revient d'une balade sur les estrans, il demande \u00e0 son p\u00e8re\u2009: \u00ab\u2009papa, j'ai faim, me ram\u00e8nerais-tu du poisson\u2009?\u2009\u00bb Le p\u00e8re, sort de son \u00e9tui sa plus belle canne et l'\u00e9quipant d'un bel hame\u00e7on, lance sa ligne \u00e0 la mer et ram\u00e8ne un gros poisson. Durant longtemps, le jeune homme mange ainsi \u00e0 sa faim cependant que le p\u00e8re ram\u00e8ne du poisson pour son fils.</p> <p>Un jour, alors que le fils invective son p\u00e8re l'estomac vide, le p\u00e8re annonce. \u00ab\u2009Fils, il est temps pour toi d'apprendre \u00e0 p\u00eacher, je peux te montrer encore longtemps comment je ram\u00e8ne du poisson, mais ce ne serait pas t'aider, voici donc cette canne et cet hame\u00e7on.\u2009\u00bb</p> <p>Le jeune homme tente de r\u00e9p\u00e9ter les gestes de son p\u00e8re, mais il ne parvient pas \u00e0 ramener le poisson qui le rassasierait. Il demande \u00e0 son p\u00e8re de l'aide que ce dernier refuse. \u00ab\u2009Fils, c'est par la pratique et avec la faim au ventre que tu parviendras \u00e0 prendre du poisson, pers\u00e9v\u00e8re et tu deviendras meilleur p\u00eacheur que moi, la lign\u00e9e sera ainsi assur\u00e9e de toujours manger \u00e0 sa faim\u2009\u00bb.</p> <p>La morale de cette histoire est plus que jamais applicable en programmation, confier aux exp\u00e9riment\u00e9s l'\u00e9criture d'algorithmes compliqu\u00e9s, ou se contenter d'observer les r\u00e9ponses des exercices pour se dire\u2009: j'ai compris ce n'est pas si compliqu\u00e9, est une erreur, car p\u00eacher ou expliquer comment p\u00eacher n'est pas la m\u00eame chose.</p> <p>Aussi, cet ouvrage se veut \u00eatre un guide pour apprendre \u00e0 apprendre le d\u00e9veloppement logiciel et non un guide exhaustif du langage, car le standard C99/C11 est disponible sur internet ainsi que le K&amp;R qui reste l'ouvrage de r\u00e9f\u00e9rence pour apprendre le C. Il est donc inutile de paraphraser les exemples donn\u00e9s quand internet apporte toutes les r\u00e9ponses, pour tous les publics du profane r\u00e9serv\u00e9 au hacker passionn\u00e9.</p>"}, {"location": "course-c/05-introduction/code-of-conduct/#une-affaire-de-consensus", "title": "Une affaire de consensus", "text": "<p>En informatique comme dans la soci\u00e9t\u00e9 humaine, il y a les religieux, les pros\u00e9lytes, les dogmatiques, les fanatiques, les contestataires et les maximalistes. Le plus souvent les motifs de f\u00e2cheries concernent les outils que ces derniers utilisent et ceux dont on doit taire le nom. Ils se portent parfois sur les conventions de codage \u00e0 respecter, l'encodage des fichiers, le choix de l'EOL, l'interdiction du <code>goto</code>, le respect inconditionnel des r\u00e8gles MISRA. Il existe ainsi de longues guerres de croyances, parfois vieilles de plusieurs g\u00e9n\u00e9rations et qui perdurent souvent par manque d'ouverture d'esprit et surtout parce que la bonne attitude \u00e0 adopter n'est pas enseign\u00e9e dans les \u00e9coles sup\u00e9rieures l\u00e0 o\u00f9 les dogmes s'\u00e9tablissent et p\u00e9n\u00e8trent les esprits dociles, faute au biais d'ancrage mental. L'enseignant devrait \u00eatre sensible \u00e0 ces aspects fondamentaux et devrait viser l'impartialit\u00e9 en visant l'ouverture l'esprit et le culte du bon sens de l'ing\u00e9nieur.</p> <p>Citons par exemple les guerres d'\u00e9diteurs qui date des ann\u00e9es 1970 et qui opposent les d\u00e9fenseurs de l'\u00e9diteur <code>vi</code> aux inconditionnels d'<code>emacs</code>. Il s'agit de deux \u00e9diteurs de texte tr\u00e8s puissants et \u00e0 la courbe d'apprentissage raide qui s\u00e9parent les opinions tant leur paradigme de fonctionnement est apor\u00e9tique. Ces guerres sont d'abord entretenues par le plaisir de l'amusement, mais les foules de convertis ne s'aper\u00e7oivent pas toujours de l'envergure \u00e9motionnelle que prend l'affaire dans son ensemble et force est de constater qu'avec le temps ils ne parviennent plus \u00e0 percevoir le monde tel qu'il est, \u00e0 force d'habitudes.</p> <p>S'enterrer dans une zone de confort renforce le biais du Marteau de Maslow, car lorsque l'on est un marteau, on ne voit plus les probl\u00e8mes qu'en forme de clou. Cette zone de confort devient un ennemi et barre l'acc\u00e8s au regard critique et au pragmatisme qui devrait pr\u00e9valoir. Car accepter l'existence de diff\u00e9rentes approches possibles d'un probl\u00e8me donn\u00e9 est essentiel, car plus que dans tout autre domaine technique, le d\u00e9veloppement logiciel est avant tout une aventure collaborative qui ne devrait jamais \u00eatre sous le joug d'une quelconque emprise \u00e9motionnelle.</p> <p>Un programme se doit d'\u00eatre le plus neutre possible, impartial et minimaliste. Il n'est pas important de se pr\u00e9occuper des affaires cosm\u00e9tiques telles que la position des accolades dans un programme, le choix d'utiliser des espaces versus des tabulations horizontales, ou le besoin d'utiliser tel ou tel outil de d\u00e9veloppement parce qu'il est jug\u00e9 meilleur qu'un autre.</p> <p>La cl\u00e9 de la bonne attitude c'est d'\u00eatre \u00e0 l'\u00e9coute du consensus et de ne pas sombrer au biais d'attention. Il faut non seulement \u00eatre sensible au consensus local direct\u2009: son entreprise, son \u00e9cole, son \u00e9quipe de travail, mais surtout au consensus plan\u00e9taire dont l'acc\u00e8s ne peut se faire que par l'interaction directe avec la communaut\u00e9 de d\u00e9veloppeurs, soit par les forums de discussions (Reddit, stackoverflow), soit par le code lui-m\u00eame. Vous avez un doute sur la bonne m\u00e9thode pour \u00e9crire tel algorithme ou sur la fa\u00e7on dont votre programme devrait \u00eatre structur\u00e9\u2009? Plongez-vous dans le code des autres, multipliez vos exp\u00e9riences, observez les disparit\u00e9s et les oppositions, et apprenez \u00e0 ne pas y \u00eatre sensible.</p> <p>Vous verrez qu'au d\u00e9but, un programme ne vous semble lisible que s'il respecte vos habitudes, la taille de vos indentations pr\u00e9f\u00e9r\u00e9es, la police de caract\u00e8re qui vous sied le mieux, l'\u00e9diteur qui supporte les ligatures...</p> <p>Par la suite, et \u00e0 la relecture de cette section, vous apprendrez \u00e0 faire fi de cette zone de confort qui vous \u00e9tait si cher et que l'important n'est plus la forme, mais le fond. Vous aurez comme N\u00e9o, lib\u00e9r\u00e9 votre esprit et serez capable de voir la matrice sans filtre ni biais.</p> <p>En somme, restez ouvert aux autres points de vue, cherchez \u00e0 adopter le consensus majoritaire qui dynamise au mieux votre \u00e9quipe de d\u00e9veloppement, qui s'encadre le mieux dans votre strat\u00e9gie de croissance et de collaboration et surtout, abreuvez-vous de code, faites-en des indigestions, r\u00eavez-en la nuit. Vous tradez du Bitcoin, allez lire le code source, vous aimez Linux, plongez-vous dans le code source du kernel, certains coll\u00e8gues ou amis vous ont parl\u00e9 de Git, allez voir ses entrailles... Oui, tous ces projets sont \u00e9crits en C, n'est-ce pas merveilleux\u2009?</p>"}, {"location": "course-c/05-introduction/code-of-conduct/#lopen-source", "title": "L'open source", "text": "<p>Au d\u00e9but de l'informatique, les programmes \u00e9taient distribu\u00e9s avec leur code source, car les ordinateurs \u00e9taient rares et co\u00fbteux et que les utilisateurs \u00e9taient souvent des d\u00e9veloppeurs. Avec l'arriv\u00e9e des ordinateurs personnels, les \u00e9diteurs de logiciels ont commenc\u00e9 \u00e0 distribuer des programmes compil\u00e9s, car les utilisateurs n'\u00e9taient plus des d\u00e9veloppeurs et que le code source \u00e9tait devenu un secret industriel mon\u00e9tisable. C'est ainsi que le logiciel propri\u00e9taire est n\u00e9. Les \u00e9diteurs de logiciels ont tir\u00e9 parti de cette situation pour verrouiller leurs clients dans un \u00e9cosyst\u00e8me propri\u00e9taire, les emp\u00eachant de modifier le logiciel, de le partager ou de le vendre.</p> <p>Dans les ann\u00e9es 1980, Richard Stallman, un informaticien am\u00e9ricain, a lanc\u00e9 le projet GNU pour cr\u00e9er un syst\u00e8me d'exploitation libre, c'est-\u00e0-dire un syst\u00e8me d'exploitation dont le code source est librement accessible, modifiable et redistribuable. N\u00e9anmoins la licence GPL (GNU Public License) qui prot\u00e8ge le code source de GNU est tr\u00e8s contraignante et ne permet pas de cr\u00e9er des logiciels propri\u00e9taires bas\u00e9s sur du code source GPL. C'est un frein pour les entreprises qui souhaitent prot\u00e9ger leur propri\u00e9t\u00e9 intellectuelle.</p> <p>En 1991, Linus Torvalds, un \u00e9tudiant finlandais, a cr\u00e9\u00e9 le noyau Linux, qui est devenu le noyau du syst\u00e8me d'exploitation GNU/Linux. Depuis lors, de nombreux logiciels libres ont \u00e9t\u00e9 d\u00e9velopp\u00e9s, notamment le navigateur web Firefox, le serveur web Apache, le syst\u00e8me de gestion de base de donn\u00e9es MySQL, le langage de programmation Python, le syst\u00e8me de gestion de versions Git, etc.</p> <p>Cette philosophie du logiciel libre a \u00e9t\u00e9 popularis\u00e9e par le hacker am\u00e9ricain Eric Raymond dans son essai \u00ab\u2009La cath\u00e9drale et le bazar\u2009\u00bb qui d\u00e9crit deux mod\u00e8les de d\u00e9veloppement logiciel\u2009: le mod\u00e8le de la cath\u00e9drale, o\u00f9 le code source est d\u00e9velopp\u00e9 en interne par une \u00e9quipe restreinte, et le mod\u00e8le du bazar, o\u00f9 le code source est d\u00e9velopp\u00e9 de mani\u00e8re collaborative par une communaut\u00e9 de d\u00e9veloppeurs.</p> <p>L'expression open source s'est largement impos\u00e9e dans le monde de l'informatique pour d\u00e9signer les logiciels libres, car elle est plus neutre et moins id\u00e9ologique que l'expression logiciel libre. De grandes soci\u00e9t\u00e9s comme Google, Facebook, Microsoft, IBM, Oracle, etc., ont adopt\u00e9 la philosophie du logiciel libre et contribuent activement \u00e0 de nombreux projets open source. Par exemple, Google a d\u00e9velopp\u00e9 le syst\u00e8me d'exploitation Android, qui est bas\u00e9 sur le noyau Linux, et qui est utilis\u00e9 par la plupart des smartphones dans le monde. Facebook a d\u00e9velopp\u00e9 le framework React, qui est utilis\u00e9 par de nombreux sites web pour cr\u00e9er des interfaces utilisateur interactives. Microsoft a rachet\u00e9 GitHub, la plateforme de d\u00e9veloppement collaboratif la plus populaire au monde, et a ouvert le code source de nombreux projets, notamment le framework .NET. IBM a rachet\u00e9 Red Hat, l'\u00e9diteur de la distribution Linux Red Hat Enterprise Linux, et contribue activement \u00e0 de nombreux projets open source.</p> <p>Mettre un logiciel ou une partie de logiciel en open source c'est permettre \u00e0 d'autres d\u00e9veloppeurs de contribuer au projet, de corriger des bogues, d'ajouter des fonctionnalit\u00e9s, de traduire le logiciel dans d'autres langues, etc. C'est aussi un moyen de faire conna\u00eetre son travail, de se faire un nom dans la communaut\u00e9 des d\u00e9veloppeurs, de trouver un emploi, de cr\u00e9er une entreprise, etc. Mais c'est aussi un moyen de partager ses connaissances, de contribuer \u00e0 l'\u00e9ducation, \u00e0 la recherche, \u00e0 la culture, \u00e0 l'humanit\u00e9.</p> <p>L'open source est devenu un mod\u00e8le \u00e9conomique viable pour de nombreuses entreprises, qui vendent des services autour de logiciels open source, comme le support, la formation, la personnalisation, l'h\u00e9bergement, etc. C'est aussi un moyen de r\u00e9duire les co\u00fbts de d\u00e9veloppement, de mutualiser les efforts, de partager les risques, de favoriser l'innovation et de promouvoir la transparence.</p> <p>Pourquoi ne pas faire d'open source\u2009? C'est une question que vous vous poserez t\u00f4t ou tard dans votre carri\u00e8re de d\u00e9veloppeur. Vous avez peut-\u00eatre peur de la concurrence, de la critique, du piratage, de la perte de contr\u00f4le, de la complexit\u00e9, de l'engagement, de la responsabilit\u00e9, de la r\u00e9putation, de la l\u00e9galit\u00e9, de la s\u00e9curit\u00e9, de la confidentialit\u00e9, de la propri\u00e9t\u00e9 intellectuelle, etc. De nombreuses soci\u00e9t\u00e9s ont fait le choix de prot\u00e9ger leur propri\u00e9t\u00e9 intellectuelle en gardant leur code source secret, mais cela \u00e0 un co\u00fbt. Les logiciels doivent \u00eatre prot\u00e9g\u00e9s par des licences, des brevets, le code doit \u00eatre crypt\u00e9, les serveurs doivent \u00eatre s\u00e9curis\u00e9s, les employ\u00e9s doivent \u00eatre surveill\u00e9s, les clients doivent \u00eatre contr\u00f4l\u00e9s, etc. C'est un cercle vicieux qui peut conduire \u00e0 la parano\u00efa, \u00e0 la m\u00e9fiance.</p>"}, {"location": "course-c/05-introduction/code-of-conduct/#la-communaute", "title": "La communaut\u00e9", "text": "<p>Se passionner pour le d\u00e9veloppement logiciel c'est aussi se passionner pour la communaut\u00e9 des d\u00e9veloppeurs. Avant internet, les d\u00e9veloppeurs se rencontraient dans des clubs d'informatique, des associations d'utilisateurs, des conf\u00e9rences, des salons, des formations, des hackathons, des meetups, etc. Moi-m\u00eame, \u00e0 douze ans, je suis rentr\u00e9 au Mac Club de Gen\u00e8ve. Un club d'informatique pour les passionn\u00e9s de Macintosh. J'ai fait mes premiers pas sur internet avec des modem rudimentaires.</p> <p>Avec internet, les d\u00e9veloppeurs se rencontrent maintenant sur des forums (Stack Overflow, Reddit...), des listes de diffusion, des chats, des blogs, des r\u00e9seaux sociaux, des plateformes de d\u00e9veloppement collaboratif, etc.</p> <p>GitHub a \u00e9t\u00e9 cr\u00e9\u00e9 en 2008 par Tom Preston-Werner, Chris Wanstrath, PJ Hyett et Scott Chacon pour faciliter le d\u00e9veloppement collaboratif de logiciels open source. GitHub est devenu la plateforme de d\u00e9veloppement collaboratif la plus populaire au monde, avec plus de 100 millions de d\u00e9p\u00f4ts de code source, plus de 40 millions de d\u00e9veloppeurs. On y trouve de tout, il suffit de chercher.</p> <p>Pour les questions techniques, il y a Stack Overflow, un site de questions-r\u00e9ponses cr\u00e9\u00e9 en 2008 par Jeff Atwood et Jo\u00ebl Spolsky. Stack Overflow est devenu le site de questions-r\u00e9ponses le plus populaire au monde, avec plus de 10 millions de questions, plus de 20 millions de r\u00e9ponses, plus de 10 millions de membres. Je vous encourage personnellement \u00e0 y contribuer, cela commence par cr\u00e9er un compte, poser des questions, r\u00e9pondre \u00e0 des questions, voter pour des questions, voter pour des r\u00e9ponses.</p> <p>Voici quelques liens utiles\u2009:</p> Stack Overflow <p>Aujourd'hui le plus grand portail de questions/r\u00e9ponses d\u00e9di\u00e9 \u00e0 la programmation logicielle</p> GitHub <p>Un portail de partage de code</p> Google Scholar <p>Un point d'entr\u00e9e essentiel pour la recherche d'articles scientifiques</p> Man Pages <p>La documentation (man pages) des commandes et outils les plus utilis\u00e9s dans les environnements macOS/Linux/Unix et POSIX compatible.</p>"}, {"location": "course-c/05-introduction/code-of-conduct/#la-revue-de-code", "title": "La revue de code", "text": "<p>Enfin, je voudrais terminer cette introduction par un point essentiel du d\u00e9veloppement logiciel\u2009: la revue de code, qui est trop souvent n\u00e9glig\u00e9e.</p> <p>La revue de code est une pratique essentielle pour am\u00e9liorer la qualit\u00e9 du code source, la productivit\u00e9 des d\u00e9veloppeurs, la s\u00e9curit\u00e9 des logiciels, la satisfaction des clients. La revue de code consiste \u00e0 examiner le code source d'un d\u00e9veloppeur par un autre d\u00e9veloppeur pour d\u00e9tecter des erreurs, des anomalies, des incoh\u00e9rences, des inefficacit\u00e9s, des non-conformit\u00e9s, des risques, des opportunit\u00e9s. La revue de code peut \u00eatre formelle ou informelle, manuelle ou automatique, individuelle ou collective, interne ou externe, syst\u00e9matique ou al\u00e9atoire, planifi\u00e9e ou impromptue, etc.</p> <p>Dans les entreprises c'est un des plus gros probl\u00e8mes. Les d\u00e9veloppeurs n'aiment pas qu'on critique leur code, les chefs de projet n'aiment pas perdre du temps \u00e0 examiner le code, les clients n'aiment pas payer pour la revue de code, les managers n'aiment pas les conflits entre d\u00e9veloppeurs, les commerciaux n'aiment pas les retards de livraison, les juristes n'aiment pas les risques de litige. Les gens manquent d'humilit\u00e9 et d'ouverture d'esprit. Pourtant, s'ouvrir \u00e0 la critique, cela permet de s'am\u00e9liorer et d'apprendre.</p>"}, {"location": "course-c/05-introduction/code-of-conduct/#conclusion", "title": "Conclusion", "text": "<p>En r\u00e9sum\u00e9, devenir d\u00e9veloppeur logiciel, que ce soit en tant que professionnel ou par passion, est bien plus qu\u2019une simple question d'\u00e9criture de code. C'est un art qui demande une compr\u00e9hension profonde des principes, des bonnes pratiques et des valeurs fondamentales qui r\u00e9gissent cette discipline en constante \u00e9volution. Trop souvent, les dogmes acad\u00e9miques et les habitudes obsol\u00e8tes polluent l'apprentissage et la pratique, au d\u00e9triment de l'esprit collaboratif et critique indispensable \u00e0 la r\u00e9ussite dans ce domaine.</p> <p>Le d\u00e9veloppement logiciel ne repose pas sur des acquis immuables, mais sur des principes adaptatifs et des valeurs humaines intemporelles telles que l'ouverture d'esprit, l'humilit\u00e9, la curiosit\u00e9, la rigueur, la patience, la pers\u00e9v\u00e9rance, l'\u00e9coute, l'entraide et le partage. Ces valeurs, qui ont permis \u00e0 l'humanit\u00e9 de prosp\u00e9rer, sont tout aussi essentielles dans le monde du d\u00e9veloppement logiciel.</p> <p>Il est crucial de comprendre que le code que vous \u00e9crivez aujourd'hui doit pouvoir \u00eatre compris, maintenu et \u00e9volu\u00e9 par d'autres demain. Ainsi, il doit respecter les standards de l'entreprise, les conventions de codage, les bonnes pratiques et les r\u00e8gles de s\u00e9curit\u00e9. Cela n\u00e9cessite un engagement envers des m\u00e9thodes de travail \u00e9prouv\u00e9es, mais aussi une attitude de remise en question constante et d'ouverture \u00e0 l'innovation.</p> <p>L'anglais, langue universelle de la programmation, est un outil indispensable pour naviguer dans cet univers globalis\u00e9. Il permet de partager des connaissances, d'acc\u00e9der \u00e0 des ressources et de collaborer avec des d\u00e9veloppeurs du monde entier. Ne sous-estimez pas l'importance de ma\u00eetriser cette langue pour votre carri\u00e8re.</p> <p>Apprendre \u00e0 p\u00eacher plut\u00f4t qu'\u00e0 se faire donner du poisson est une le\u00e7on cl\u00e9 dans l'apprentissage du d\u00e9veloppement logiciel. La pratique, la pers\u00e9v\u00e9rance et l'exp\u00e9rimentation personnelle sont indispensables pour acqu\u00e9rir les comp\u00e9tences n\u00e9cessaires et devenir autonomes.</p> <p>L'informatique est aussi une affaire de consensus. Les guerres de croyances et les dogmes ne font que limiter la croissance et l'innovation. Adopter une attitude pragmatique et ouverte, en se basant sur le consensus de la communaut\u00e9 mondiale des d\u00e9veloppeurs, est essentiel pour progresser et s'\u00e9panouir dans ce m\u00e9tier.</p> <p>L'open source incarne parfaitement l'esprit de partage et de collaboration qui est au c\u0153ur du d\u00e9veloppement logiciel. Il permet non seulement de contribuer \u00e0 des projets d'envergure mondiale, mais aussi de se faire un nom, d'apprendre des autres et de donner en retour.</p> <p>Enfin, la communaut\u00e9 des d\u00e9veloppeurs est une ressource inestimable. Participer activement \u00e0 des forums, des plateformes collaboratives, des conf\u00e9rences et des meetups enrichit non seulement vos comp\u00e9tences, mais aussi votre r\u00e9seau professionnel.</p>"}, {"location": "course-c/05-introduction/me-and-my-computer/", "title": "Mon ordinateur et moi", "text": "<p>Vous \u00eates devant votre ordinateur, vous avez en th\u00e9orie un clavier devant vous, une souris \u00e0 droite de votre clavier, et un ou plusieurs \u00e9crans devant vous. Votre ordinateur d\u00e9marre et vous verrez appara\u00eetre tr\u00e8s probablement soit\u2009:</p> <ul> <li>une pomme croqu\u00e9e (Apple);</li> <li>une fen\u00eatre \u00e0 carreaux (Windows);</li> <li>un manchot Ad\u00e9lie (Linux).</li> </ul> <p>C'est votre syst\u00e8me d'exploitation et peu importe lequel vous avez, la bonne nouvelle c'est que vous pourrez \u00e9crire vos premiers programmes avec n'importe lequel de ces syst\u00e8mes.</p>"}, {"location": "course-c/05-introduction/me-and-my-computer/#systeme-dexploitation", "title": "Syst\u00e8me d'exploitation", "text": "<p>Dans cet ouvrage, la plupart des exemples seront donn\u00e9s sous Linux. Linux pr\u00e9sente l'avantage d'\u00eatre normalis\u00e9 et de suivre les standards POSIX, lesquels sont communs, du moins en partie avec macOS. Windows, quant \u00e0 lui, est un peu \u00e0 part, mais il est possible d'installer un sous-syst\u00e8me Linux pour Windows (WSL2), ce qui permet d'ex\u00e9cuter des programmes Linux sur Windows.</p> <p>Le syst\u00e8me d'exploitation c'est aussi un programme qui offre une couche d'abstraction entre le mat\u00e9riel et les autres programmes. On peut le voir comme le chef d'orchestre de votre ordinateur. Il permet de g\u00e9rer les ressources mat\u00e9rielles, de lancer des programmes, de g\u00e9rer les fichiers, de g\u00e9rer les utilisateurs, etc.</p>"}, {"location": "course-c/05-introduction/me-and-my-computer/#editeur-de-code-source", "title": "\u00c9diteur de code source", "text": "<p>Pour \u00e9crire un programme, vous aurez besoin d'un \u00e9diteur de code, c'est un programme (oui, lui aussi) qui vous permet d'\u00e9crire du texte et de le sauvegarder dans un fichier. Il en existe des centaines\u2009!</p> <p>Si vous prenez une Dolor\u00e9ane munie d'un convecteur temporel, et que vous d\u00e9passez les 88 miles \u00e0 l'heure, avec une \u00e9nergie de 2.21 Gigot-Watt vous pouvez vous rendre en 1973 et utiliser un \u00e9diteur de code qui s'appelle <code>ed</code> (prononc\u00e9 \u00ab\u2009idi\u2009\u00bb) \u00e9crit par Ken Thompson (un des cr\u00e9ateurs d'Unix et du langage C, mais nous reviendrons sur lui).</p> <p>C'est un \u00e9diteur qui a \u00e9t\u00e9 \u00e9crit \u00e0 l'\u00e9poque des t\u00e9l\u00e9types et qui, curieusement a travers\u00e9 les \u00e2ges car il est encore int\u00e9gr\u00e9 au standard POSIX. Il est par cons\u00e9quent toujours disponible sur nos syst\u00e8mes d'exploitation modernes. Il faut noter qu'\u00e0 cette \u00e9poque il n'y avait pas d'\u00e9cran, et que l'on utilisait des imprimantes pour afficher le texte. L'\u00e9diteur n'est donc pas tr\u00e8s interactif, mais il a le m\u00e9rite d'exister.</p> <p>C'est un des premier \u00e9diteur modale, son utilisation est assez d\u00e9routante car il n'y a pas de retour visuel imm\u00e9diat. Il faut taper des commandes pour \u00e9crire du texte, pour sauvegarder, pour quitter, etc. Voici l'exemple pour \u00e9diter <code>hello.c</code> :</p> <pre><code>$ ed\na\nvoid main() {\n    printf(\"hello, world\"); }\n.\n1\nvoid main() {\ns/void/int/\n1i\n#include &lt;stdio.h&gt;\n.\nw hello.c\n62\nq\n</code></pre> <p>Dans les \u00e9tapes ci-dessus, nous avons\u2009: (1) lanc\u00e9 l'\u00e9diteur <code>ed</code>, (2) \u00e9crit <code>a</code> pour passer en mode \u00e9dition, (3) \u00e9crit le code, puis (4) saisi <code>.</code> pour revenir en mode commande. Nous avons (5) entr\u00e9 <code>1</code> pour afficher la premi\u00e8re ligne (qui comporte une erreur) puis (6) saisi <code>s/void/int/</code> pour remplacer <code>void</code> par <code>int</code>. Nous avons (7) tap\u00e9 <code>1i</code> pour ins\u00e9rer une ligne avant la premi\u00e8re ligne puis (8) \u00e9crit <code>#include &lt;stdio.h&gt;</code> que l'on a oubli\u00e9 et (9) entr\u00e9 <code>.</code> pour revenir en mode commande. Enfin (10) \u00e9crit <code>w hello.c</code> pour sauvegarder le fichier et (11) <code>q</code> pour quitter l'\u00e9diteur.</p> <p>Rappelons que ce programme est \u00e9crit en C. Donc le plus amusant, c'est que vous pouvez le compiler, le modifier et m\u00eame ajouter des fonctionnalit\u00e9s. On trouve bien entendu le code source sur GitHub.</p> <p>Tr\u00e8ve de plaisanteries, vous n'allez probablement pas utiliser <code>ed</code> mais conna\u00eetre son existence permet de mieux saisir le contexte g\u00e9n\u00e9ral. Je vous propose de continuer un peu notre voyage spatio-temporel...</p> <p>En 1991 na\u00eet un \u00e9diteur de code qui va r\u00e9volutionner le monde de la programmation, il s'appelle <code>vim</code>. C'est un \u00e9diteur de code qui est tr\u00e8s puissant, mais qui a une courbe d'apprentissage assez velue. Il est toujours tr\u00e8s utilis\u00e9 de nos jours, et il est disponible sur tous les syst\u00e8mes d'exploitation. Vous seriez surpris de constater le nombre de programmeurs qui l'utilisent encore. Comme <code>ed</code>, c'est un \u00e9diteur modal\u2009: un mode pour \u00e9crire du texte, un mode pour \u00e9diter du texte, un mode pour naviguer dans le texte, etc.</p> <p>Puisque nous nommons Vim, nous devons aussi nommer Emacs. Le rival de Vim. Emacs est un \u00e9diteur de code qui est aussi tr\u00e8s puissant mais il semble moins utilis\u00e9 de nos jours. Vim comme Emacs sont disponibles sur tous les syst\u00e8mes d'exploitation.</p> <p> Guerre d'\u00e9diteurs</p> <p>Nous ferons l'impasse sur d'autres \u00e9diteurs qui ont \u00e9t\u00e9 populaires en leurs temps, mais qui sont technologiquement d\u00e9pass\u00e9s\u2009: TextPad, UltraEdit, Sublime Text, Atom, NotePad++... Le grand gagnant de ces derni\u00e8res ann\u00e9es est Visual Studio Code, un \u00e9diteur de code qui est tr\u00e8s puissant, qui est tr\u00e8s utilis\u00e9 de nos jours, et qui est aussi disponible sur tous les syst\u00e8mes d'exploitation.</p> <p>Le r\u00e9sultat de l'\u00e9tude annuelle 2023 de Stackoverflow donne une id\u00e9e de la popularit\u00e9 des \u00e9diteurs et IDE les plus utilis\u00e9s par les d\u00e9veloppeurs\u2009:</p> <pre><code>%% Utilisation des \u00e9diteurs de code\npie\n    \"Visual Studio Code\" : 73.3\n    \"Visual Studio\" : 28.4\n    \"IntelliJ IDEA\" : 26.8\n    \"Notepad++\": 24.5\n    \"Vim\": 22.3\n    \"Emacs\": 4.69\n    \"Eclipse\": 9.9\n    \"Nano\": 8.98</code></pre>"}, {"location": "course-c/05-introduction/me-and-my-computer/#fonctionnalites-attendues", "title": "Fonctionnalit\u00e9s attendues", "text": "Coloration Synatxique (syntax highlighting) <p>L'\u00e9diteur de code colore les mots-cl\u00e9s du langage de programmation que vous utilisez. Cela permet de mieux visualiser la structure du code.</p> Correspondance des parenth\u00e8ses (brace matching) <p>L'\u00e9diteur de code vous permet de voir la correspondance des parenth\u00e8ses, accolades, crochets, etc. Cela permet de voir en un tournemain si vous avez oubli\u00e9 une parenth\u00e8se.</p> Indentation automatique (auto-indent) <p>L'\u00e9diteur de code vous permet d'indenter automatiquement votre code. Cela permet de voir la structure du code. Il est consensuellement admis qu' une r\u00e9gion de code s\u00e9lectionn\u00e9e peut \u00eatre indent\u00e9e avec Tab et d\u00e9sindent\u00e9e avec Shift+Tab.</p> Repli de code (code folding) <p>L'\u00e9diteur de code vous permet de replier le code. En cliquant sur une petite fl\u00e8che \u00e0 gauche du code, vous pouvez replier le code pour ne voir que les en-t\u00eates des fonctions, des boucles, des conditions, etc.</p> Structure du code (outline) <p>L'\u00e9diteur de code vous permet de voir dans une fen\u00eatre s\u00e9par\u00e9e les \u00e9l\u00e9ments de votre code. Cela permet de naviguer rapidement dans votre code.</p> Navigation hi\u00e9rarchique (go to definition) <p>L'\u00e9diteur de code vous permet de naviguer rapidement dans votre code. En cliquant sur un mot-cl\u00e9, vous pouvez vous rendre \u00e0 la d\u00e9finition de ce mot-cl\u00e9. Habituellement Alt+Left vous permet de revenir en arri\u00e8re l\u00e0 o\u00f9 vous \u00e9tiez.</p> Expressions r\u00e9guli\u00e8res (regular expressions) <p>L'\u00e9diteur de code vous permet de rechercher ou remplacer des \u00e9l\u00e9ments en utilisant des expressions r\u00e9guli\u00e8res. Par exemple si vous voulez inverser l'ordre des mots \u00e9crits, vous activez le mode regex (\u25aa\u20f0 dans vscode). Vous pouvez alors utiliser l'expression r\u00e9guli\u00e8re suivante\u2009:</p> <pre><code>/(M.|Mme.)\\s+([^ ]+)\\s+([^ ]+)/\\1 \\3 \\2/\n\nQui permet d'inverser le pr\u00e9nom et le nom.\n\nM. Yves Chevallier` --&gt; M. Chevallier Yves\n</code></pre> Multicurseurs (multi-cursor) <p>L'\u00e9diteur de code vous permet de placer plusieurs curseurs dans votre code. Cela permet de modifier plusieurs lignes en m\u00eame temps.</p> Compl\u00e9tion automatique (auto-completion) <p>L'\u00e9diteur de code vous permet de compl\u00e9ter automatiquement le code en utilisant la touche Tab. Il utilise une technologie nomm\u00e9e IntelliSense qui, en ayant connaissance des mots-cl\u00e9s du langage de programmation et de ce que vous avez d\u00e9j\u00e0 \u00e9crit, vous propose les possibilit\u00e9s de compl\u00e9tion.</p> Intelligence artificielle (AI) <p>L'\u00e9diteur de code vous permet de compl\u00e9ter automatiquement le code en utilisant une intelligence artificielle.</p> Gestion d'extensions (extensions) <p>L'\u00e9diteur de code vous permet d'ajouter des extensions permettant d'ajouter des fonctionnalit\u00e9s \u00e0 votre \u00e9diteur de code.</p> Int\u00e9gration du terminal (terminal integration) <p>L'\u00e9diteur de code vous permet d'int\u00e9grer un terminal (TTY) dans votre \u00e9diteur de code pour lancer directement des commandes.</p> Int\u00e9gration de Git (git integration) <p>L'\u00e9diteur de code vous permet d'int\u00e9grer Git dans votre \u00e9diteur de code pour g\u00e9rer les versions de votre code.</p>"}, {"location": "course-c/05-introduction/me-and-my-computer/#compilateur", "title": "Compilateur", "text": "<p>Un compilateur est un programme qui permet de transformer un programme \u00e9crit dans un langage de programmation en un programme ex\u00e9cutable. Il existe de nombreux compilateurs, et chaque langage de programmation a son propre compilateur.</p> <p>En C, les compilateurs les plus populaires et qui respectent les normes sont GCC et CLANG.</p> GCC <p>Un compilateur open-source utilis\u00e9 sous Linux et macOS. Il est sous licence GPL.</p> CLANG <p>Un compilateur open-source gagnant en popularit\u00e9, une alternative \u00e0 GCC. Il est sous licence Apache et utilise la biblioth\u00e8que LLVM.</p>"}, {"location": "course-c/05-introduction/me-and-my-computer/#ide", "title": "IDE", "text": "<p>Un IDE est un Integrated Development Environment, c'est un environnement de d\u00e9veloppement int\u00e9gr\u00e9. C'est un programme qui vous permet d'\u00e9crire du code, de le compiler, de le d\u00e9boguer, de le tester, de le d\u00e9ployer, etc.</p> <p>Tous les \u00e9diteurs ne sont pas des IDE, mais tous les IDE sont des \u00e9diteurs. En fin de compte, un IDE est un \u00e9diteur qui a des fonctionnalit\u00e9s suppl\u00e9mentaires telles que\u2009:</p> <ul> <li>Un compilateur</li> <li>Un d\u00e9bogueur avec des points d'arr\u00eat</li> <li>Gestion de param\u00e8tres par projet</li> <li>Gestion de d\u00e9pendances logicielles</li> <li>Gestion de versions</li> </ul> <p>Un autre composant essentiel de l'environnement de d\u00e9veloppement est le compilateur. Il s'agit g\u00e9n\u00e9ralement d'un ensemble de programmes qui permettent de convertir le code \u00e9crit en un programme ex\u00e9cutable. Ce programme peut-\u00eatre par la suite int\u00e9gr\u00e9 dans un smartphone, dans un syst\u00e8me embarqu\u00e9 sur un satellite, sur des cartes de prototypage comme un Raspberry PI, ou encore sur un ordinateur personnel.</p> <p>L'ensemble des outils n\u00e9cessaire \u00e0 cr\u00e9er un produit logiciel est appel\u00e9 cha\u00eene de compilation, plus commun\u00e9ment appel\u00e9e toolchain.</p> <p> Repr\u00e9sentation graphique des notions de compilateur, IDE, toolchain...</p> <p>Exercise\u2009: Eclipse</p> <p>Un ami vous parle d'un outil utilis\u00e9 pour le d\u00e9veloppement logiciel nomm\u00e9 Eclipse. De quel type d'outil s'agit-il\u2009?</p> Solution <p>Eclipse est un IDE. Il n'int\u00e8gre donc pas de cha\u00eene de compilation et donc aucun compilateur.</p> <p>Exercise\u2009: Stack Overflow</p> <p>Combien y a-t-il eu de questions pos\u00e9es en C sur le site Stack Overflow\u2009?</p> Solution <p>Il suffit pour cela de se rendre sur le site de Stackoverflow et d'acc\u00e9der \u00e0 la liste des tags. En 2019/07 il y eut 307'669 questions pos\u00e9es.</p> <p>Seriez-vous capable de r\u00e9pondre \u00e0 une question pos\u00e9e\u2009?</p>"}, {"location": "course-c/05-introduction/programming/", "title": "Programmation", "text": "La programmation, c'est l'art d'organiser la complexit\u00e9.E. Dijkstra <p>La programmation aussi nomm\u00e9e codage est la branche de l'informatique qui consiste en l'\u00e9criture de programmes agenc\u00e9s en s\u00e9quences d'instructions qui refl\u00e8tent des ordres donn\u00e9s \u00e0 l'ordinateur. Un programme est donc une succession d'\u00e9tapes respectant un algorithme.</p> <p>L'essentiel pour le programmeur est la traduction d'algorithmes en un langage formel compr\u00e9hensible par une machine. La programmation est donc une activit\u00e9 de communication entre un humain et une machine. Elle est un art, une science et une technique.</p> <p>Dans un cursus acad\u00e9mique, on parle souvent de cours d'Algorithmique et Programmation. Nous allons donc \u00e9claircir ces deux termes.</p> <p> L'un des premiers ordinateurs\u2009: l'Eniac</p>"}, {"location": "course-c/05-introduction/programming/#algorithmique", "title": "Algorithmique", "text": "<p>L'algorithmique (n.f.) et non l'algorithmie (qui n'est pas fran\u00e7ais), est la science qui \u00e9tudie la production de r\u00e8gles et techniques impliqu\u00e9es dans la d\u00e9finition et la conception d'algorithmes. Nous verrons l'algorithmique plus en d\u00e9tail dans le chapitre algorithmes. Retenons pour l'heure que l'algorithmique est un domaine bien plus vaste que celui appliqu\u00e9 aux ordinateurs\u2009; elle intervient tous les jours dans\u2009:</p> <ul> <li>une recette de cuisine,</li> <li>le tissage de tapis persans,</li> <li>les casse-t\u00eate (Rubik's Cube),</li> <li>les tactiques sportives,</li> <li>les proc\u00e9dures administratives.</li> </ul>"}, {"location": "course-c/05-introduction/programming/#algorithme-deuclide", "title": "Algorithme d'Euclide", "text": "<p>Dans le contexte math\u00e9matique et scientifique qui nous int\u00e9resse ici, citons l'algorithme d'Euclide datant probablement de 300 av. J.-C.</p> <p>Il est un algorithme permettant de d\u00e9terminer le plus grand commun diviseur (PGCD). Voici la description de l'algorithme sous forme d'un diagramme de flux\u2009:</p> <p> Algorithme de calcul du PGCD d'Euclide.</p> <p>Souvent, les informaticiens et ing\u00e9nieurs aiment utiliser des diagrammes pour synth\u00e9tiser leurs id\u00e9es. Le diagramme de flux est un outil de communication visuelle permettant de repr\u00e9senter des processus. Ici on observe des formes g\u00e9om\u00e9triques et des fl\u00e8ches. Les fl\u00e8ches indiquent le sens de lecture du processus. Les formes g\u00e9om\u00e9triques sont des bo\u00eetes de texte contenant des instructions. Les formes de d\u00e9but et de fin sont par convention des ovales. Les formes de traitement sont des rectangles et les formes de d\u00e9cision sont quant \u00e0 elles des losanges. Une forme de d\u00e9cision contient une question et deux fl\u00e8ches de sortie, une pour chaque r\u00e9ponse possible. G\u00e9n\u00e9ralement une fl\u00e8che de sortie est \u00e9tiquet\u00e9e avec la r\u00e9ponse attendue. On le verra plus tard, mais un processus de traitement d'information dispose toujours d'une entr\u00e9e et d'une sortie.</p> <p>Si l'on souhaite trouver le plus grand diviseur commun de 42 et 30, il suffit d'applique l'algorithme d'Euclide du d\u00e9but \u00e0 la fin :</p>  Exemple de calcul du PGCD entre 42 et 30 \u00c9tape \\(a\\) \\(b\\) \\(r\\) Prendre deux entiers naturels \\(a\\) et \\(b\\) 42 30 non d\u00e9fini Est-ce que \\(b\\) est nul\u2009? non\u2009! 42 30 non d\u00e9fini Calculer le reste de la division euclidienne de \\(a\\) par \\(b\\) 42 30 12 Remplacer \\(a\\) par \\(b\\) 30 30 12 Remplacer \\(b\\) par \\(r\\) 30 12 12 Est-ce que \\(b\\) est nul\u2009? non\u2009! 30 12 12 Calculer le reste de la division euclidienne de \\(a\\) par \\(b\\) 30 12 6 Remplacer \\(a\\) par \\(b\\) 12 12 6 Remplacer \\(b\\) par \\(r\\) 12 6 6 Est-ce que \\(b\\) est nul\u2009? non\u2009! 12 6 6 Calculer le reste de la division euclidienne de \\(a\\) par \\(b\\) 12 6 0 Remplacer \\(a\\) par \\(b\\) 6 6 0 Remplacer \\(b\\) par \\(r\\) 6 0 0 Est-ce que \\(b\\) est nul\u2009? oui\u2009! 6 0 0 Le PGCD de 42 et 30 est 6 6 0 0 <p>Exercise\u2009: Algorithme d'Euclide</p> <p>Appliquer l'algorithme d'Euclide aux entr\u00e9es \\(a\\) et \\(b\\) suivantes.</p> <p>Que vaut \\(a, b\\) et \\(r\\) \u00e0 la fin de l'algorithme, et quel est le plus grand diviseur commun\u2009?</p> \\[a = 1260, b = 630\\]"}, {"location": "course-c/05-introduction/programming/#tri-a-bulles", "title": "Tri \u00e0 bulles", "text": "<p>Un autre algorithme c\u00e9l\u00e8bre est l'algorithme de tri de Bulles. Il s'agit d'un algorithme de tri simple qui consiste \u00e0 comparer les \u00e9l\u00e9ments adjacents et \u00e0 les permuter si n\u00e9cessaire.</p> <p>Dans la vie de tous les jours, imaginez que vous ayez un jeu de 54 cartes \u00e0 jouer m\u00e9lang\u00e9 et vous souhaitez trier le jeu par valeurs (As, 2, 3, ..., 10, Valet, Dame, Roi). Vous commencez par d\u00e9poser les cartes les unes \u00e0 c\u00f4t\u00e9 des autres et pour trier le jeu vous vous allez intervertir deux cartes jusqu'\u00e0 ce que le jeu soit tri\u00e9.</p> <p>Voici un diagramme de flux de l'algorithme de tri \u00e0 bulles\u2009:</p> <p> Algorithme de tri \u00e0 bulles.</p> <p>Soit un tableau de \\(N = 5\\) valeurs \u00e0 trier\u2009:</p> \\[T = {5, 3, 8, 4, 2}\\] <p>Le cycle se r\u00e9p\u00e8te jusqu'\u00e0 ce que le tableau soit tri\u00e9. Si \\(s\\) est \u00e9gal \u00e0 0, il n'y a pas eu d'\u00e9change lors du parcours du tableau et le tableau est donc tri\u00e9.</p> <p> \u00c9tape par \u00e9tape du tri \u00e0 bulles.</p> <p>Pour les cycles \\(3\\) et \\(4\\), nous ne montrons pas les \u00e9tapes ou il n'y a pas eu d'\u00e9change. Au cinqi\u00e8me cycle, aucun \u00e9change n'est n\u00e9cessaire, l'algorithme se termine.</p> <p>On peut compter le nombre de cycles assez facilement. Pour ce tableau de \\(N = 5\\) valeurs, il y a \\(5\\) cycles. Durant un cycle, il faut regarder \\(N - 1\\) paires d'\u00e9l\u00e9ments. Donc pour un tableau de \\(N\\) valeurs, il y a \\(N^2 - N\\) comparaisons. Ce type d'algorithme est dit de complexit\u00e9 \\(O(N^2)\\). Cela signifie que le nombre d'op\u00e9rations \u00e0 effectuer est proportionnel au carr\u00e9 du nombre d'\u00e9l\u00e9ments \u00e0 trier. Nous verrons plus tard que la complexit\u00e9 d'un algorithme est un crit\u00e8re important. Nous verrons comment le calculer.</p>"}, {"location": "course-c/05-introduction/programming/#conclusion", "title": "Conclusion", "text": "<p>Les algorithmes, il y en a de toutes sortes, des plus simples aux plus complexes. Ils sont utilis\u00e9s dans de nombreux domaines, de la cryptographie \u00e0 la bio-informatique en passant par la finance et la robotique.</p> <p>En tant que d\u00e9veloppeur vous devrez souvent \u00e9crire des algorithmes pour r\u00e9soudre des probl\u00e8mes. Souvent, la meilleure approche est de prendre une feuille de papier, un crayon et de faire chauffer vos neurones. Il est crucial de bien comprendre le probl\u00e8me avant de se lancer dans l'\u00e9criture d'un algorithme. Les jeunes d\u00e9veloppeurs vont souvent au combat sans une reflexion pr\u00e9alable et passent leur temps \u00e0 touiller leur code \u00e0 la vaudoise. Prenez votre temps, r\u00e9fl\u00e9chissez, imaginez des exemples, faites des tests et vous verrez que la programmation deviendra un jeu d'enfant.</p>"}, {"location": "course-c/05-introduction/programming/#programmation_1", "title": "Programmation", "text": "<p>Parlons couture\u2009! La machine Jacquard est un m\u00e9tier \u00e0 tisser mis au point par Joseph Marie Jacquard en 1801. Il constitue le premier syst\u00e8me m\u00e9canique programmable avec cartes perfor\u00e9es.</p> <p> M\u00e9canisme Jacquard au Mus\u00e9e des arts et m\u00e9tiers de Paris.</p> <p>Les cartes perfor\u00e9es, ici des rouleaux de papier, contiennent donc la suite des actions guidant les crochets permettant de tisser des motifs complexes. Elles sont donc le programme de la machine et dont le format (largeur, dimension des trous, etc.) est sp\u00e9cifique \u00e0 la machine. En termes informatiques, on dirait que les cartes perfor\u00e9es sont \u00e9crites en langage machine.</p> <p>La r\u00e9volte des canuts</p> <p>L'av\u00e8nement de la machine Jacquard a r\u00e9volutionn\u00e9 l'industrie textile mais a aussi eu des cons\u00e9quences sociales. L'automatisation d'un travail qui jadis \u00e9tait effectu\u00e9 manuellement causa une vague de ch\u00f4mage menant \u00e0 la R\u00e9volte des canuts en 1831.</p> <p>La programmation d\u00e9finit toute activit\u00e9 menant \u00e0 l'\u00e9criture de programmes. En informatique, un programme est d\u00e9fini comme un ensemble ordonn\u00e9 d'instructions cod\u00e9es avec un langage donn\u00e9 et d\u00e9crivant les \u00e9tapes menant \u00e0 la r\u00e9solution d'un probl\u00e8me. Comme nous l'avons vu, il s'agit le plus souvent d'une \u00e9criture formelle d'un algorithme par l'interm\u00e9diaire d'un langage de programmation.</p> <p>Les informaticiens-tisserands responsables de la cr\u00e9ation des cartes perfor\u00e9es auraient pu se poser la question de comment simplifier leur travail en cr\u00e9ant un langage formel pour cr\u00e9er des motifs complexes et dont les composants de base se r\u00e9p\u00e8tent d'un travail \u00e0 l'autre. Prenons par exemple un ouvrier sp\u00e9cialis\u00e9 en h\u00e9raldique et devant cr\u00e9er des motifs complexes de blasons.</p> <p> Armoiries des ducs de Mayenne</p> <p>Nul n'est sans savoir que l'h\u00e9raldique a son langage parfois obscur et celui qui le ma\u00eetrise voudrait par exemple l'utiliser au lieu de manuellement percer les cartes pour chaque point de couture. Ainsi l'anachronique informaticien-tisserand souhaitant tisser le motif des armoiries duc de Mayenne aurait sans doute r\u00e9dig\u00e9 un programme informatique en utilisant sa langue. Le programme aurait pu ressembler \u00e0 ceci\u2009:</p> <pre><code>\u00c9cartel\u00e9, en 1 et 4 :\n    coup\u00e9 et parti en 3,\n        au premier fasc\u00e9 de gueules et d'argent,\n        au deuxi\u00e8me d'azur sem\u00e9 de lys d'or\n            et au lambel de gueules,\n        au troisi\u00e8me d'argent \u00e0 la croix potenc\u00e9e d'or,\n            cantonn\u00e9e de quatre croisettes du m\u00eame,\n        au quatri\u00e8me d'or aux quatre pals de gueules,\n        au cinqui\u00e8me d'azur sem\u00e9 de lys d'or\n            et \u00e0 la bordure de gueules,\n        au sixi\u00e8me d'azur au lion contourn\u00e9 d'or,\n            arm\u00e9,\n            lampass\u00e9 et couronn\u00e9 de gueules,\n        au septi\u00e8me d'or au lion de sable,\n            arm\u00e9,\n            lampass\u00e9 de gueules,\n        au huiti\u00e8me d'azur sem\u00e9 de croisettes d'or\n            et aux deux bar d'or.\n    Sur le tout d'or \u00e0 la bande de gueules\n        charg\u00e9 de trois al\u00e9rions d'argent\n    Le tout bris\u00e9 d'un lambel de gueules ;\nEn 2 et 3 contre-\u00e9cartel\u00e9 :\n    en 1 et 4 d'azur,\n        \u00e0 l'aigle d'argent, becqu\u00e9e,\n        langu\u00e9e et couronn\u00e9e d'or et en 2 et 3 d'azur,\n        \u00e0 trois fleurs de lys d'or,\n        \u00e0 la bordure endent\u00e9e de gueules et d'or.\n</code></pre> <p></p> <p>Tout l'art est de pouvoir traduire ce texte compr\u00e9hensible par tout h\u00e9raldiste en un programme en langage machine compr\u00e9hensible par un m\u00e9tier \u00e0 tisser. Cette traduction est le r\u00f4le du compilateur que nous verrons plus tard. Quant au texte, et bien qu'il nous viens tout droit du moyen-\u00e2ge, il partage avec les langages de programmation modernes des caract\u00e9ristiques communes\u2009:</p> Lexique <p>le texte est compos\u00e9 de mots et de symboles qui ont un sens pr\u00e9cis, les couleurs (\u00e9maux) ont des termes sp\u00e9cifiques (gueules pour le rouge, azur pour le bleu, sable pour le noir etc.), les figures (meubles) aussi (lys, croix, lion, aigle, etc.). </p> Syntaxe <p>le texte suit une structure grammaticale pr\u00e9cise, le fond (champ) est toujours mentionn\u00e9es en premier, les figures en second suivi de leurs attributs. </p> S\u00e9mantique <p>les termes peuvent adopter une certaine morphologie, par exemple le lion peut \u00eatre lampass\u00e9 (langue de couleur diff\u00e9rente), couronn\u00e9 (avec une couronne), arm\u00e9 (avec des griffes et des dents de couleur diff\u00e9rente). Cette s\u00e9mantique implique l'adjonction de pr\u00e9fixes ou de suffixes. </p> Grammaire <p>le texte est organis\u00e9 en phrases, les phrases sont organis\u00e9es en paragraphes, les paragraphes en sections, les symboles vont \u00eatre interpr\u00e9t\u00e9s en fonction de leur position dans le texte, de leur contexte. </p> <p>De gueules</p> <p>Notons que gueules signifie rouge. Le drapeau suisse est donc de gueules, \u00e0 la croix al\u00e9s\u00e9e d'argent.</p>", "tags": ["semantique", "langage-machine", "mayenne-duc-de", "morphologie", "lexique", "compilateur", "heraldique", "grammaire", "syntaxe"]}, {"location": "course-c/05-introduction/programming/#langage-de-programmation", "title": "Langage de programmation", "text": "<p>Traduire un algorithme en une suite d'ordres compr\u00e9hensibles par une machine est donc le travail du programmeur. Il existe de nombreux langages de programmation, mais la plupart se regroupent en deux cat\u00e9gories\u2009:</p> <ol> <li>Les langages textuels qui utilisent du texte pour d\u00e9crire les instructions.</li> <li>Les langages visuels qui utilisent des \u00e9l\u00e9ments graphiques pour d\u00e9crire les instructions.</li> </ol> <p>L'\u00eatre humain a appris depuis des mill\u00e9naires \u00e0 communiquer avec des symboles, il stocke son savoir dans des livres ou feu une \u00e9poque sur des tablettes de cire. Au d\u00e9but de l'\u00e8re de l'informatique, l'ordinateur ne pouvait communiquer que par du texte. Les premiers langages de programmation \u00e9taient donc textuels. Avec l'av\u00e8nement des interfaces graphiques, les langages visuels ont vu le jour, mais ils sont davantage r\u00e9serv\u00e9s pour enseigner la programmation aux enfants ou pour faciliter la programmation de robots ou de jeux vid\u00e9os.</p> Scratch <p>Scratch est un langage de programmation visuel d\u00e9velopp\u00e9 par le MIT. Il est utilis\u00e9 pour enseigner les bases de la programmation aux enfants. Il permet de cr\u00e9er des animations, des jeux et des histoires interactives. </p> <p> Interface de scratch</p> LabView <p>LabView est un langage de programmation visuel d\u00e9velopp\u00e9 par National Instruments. Il est utilis\u00e9 pour la programmation de syst\u00e8mes de mesure et de contr\u00f4le. Il est tr\u00e8s utilis\u00e9 dans l'industrie et la recherche. </p> <p> Interface de LabView</p> <p>Son interface est compos\u00e9e de blocs graphiques que l'on relie entre eux pour cr\u00e9er un programme.</p> Common Lisp <p>Common Lisp est un langage de programmation invent\u00e9 en 1984. C'est un langage de programmation textuel de type fonctionnel. Voici un exemple de programme en Common Lisp pour r\u00e9soudre le probl\u00e8me des tours de Hano\u00ef :</p> <pre><code>(defun hanoi (n source target auxiliary)\n  (when (&gt; n 0)\n    (hanoi (- n 1) source auxiliary target)\n    (format t \"~%Move disk from ~A to ~A\" source target)\n    (hanoi (- n 1) auxiliary target source)))\n\n(defun solve-hanoi (n)\n  (hanoi n 'A 'C 'B))\n\n(solve-hanoi 3)\n</code></pre> <p>Pour ce cours, et pour l'enseignement de la programmation en g\u00e9n\u00e9ral, nous utiliserons des langages textuels.</p>", "tags": ["scratch", "labview", "lisp"]}, {"location": "course-c/05-introduction/programming/#calculateur", "title": "Calculateur", "text": "<p>Un calculateur du latin calculare: calculer avec des cailloux, originellement appel\u00e9s abaque, \u00e9tait un dispositif permettant de faciliter les calculs math\u00e9matiques.</p> <p>Les os d'Ishango dat\u00e9s de 20'000 ans sont des art\u00e9facts arch\u00e9ologiques attestant la pratique de l'arithm\u00e9tique dans l'histoire de l'humanit\u00e9.</p> <p>Si les anglophones ont d\u00e9tourn\u00e9 le verbe compute (calculer) en un nom computer, un ordinateur est g\u00e9n\u00e9ralement plus qu'un simple calculateur, car m\u00eame une calculatrice de poche doit g\u00e9rer en plus des calculs un certain nombre de p\u00e9riph\u00e9riques comme\u2009:</p> <ul> <li>l'interface de saisie (pav\u00e9 num\u00e9rique);</li> <li>l'affichage du r\u00e9sultat (\u00e9cran \u00e0 cristaux liquides).</li> </ul> <p>Notons qu'\u00e0 l'instar de notre diagramme de flux, un calculateur dispose aussi d'une entr\u00e9e, d'une sortie et d'\u00e9tats internes.</p>", "tags": ["calculateur"]}, {"location": "course-c/05-introduction/programming/#ordinateur", "title": "Ordinateur", "text": "<p>Le terme ordinateur est tr\u00e8s r\u00e9cent, il daterait de 1955, cr\u00e9\u00e9 par Jacques Perret \u00e0 la demande d'IBM France (c.f. 2014\u2009: 100 ans d'IBM en France).  Voici la lettre de Jacques Perret \u00e0 IBM France\u2009:</p> <p>\u00ab Le 16 IV 1955, Cher Monsieur,</p> <p>Que diriez-vous d\u2019ordinateur? C\u2019est un mot correctement form\u00e9, qui se trouve m\u00eame dans le Littr\u00e9 comme adjectif d\u00e9signant Dieu qui met de l\u2019ordre dans le monde. Un mot de ce genre a l\u2019avantage de donner ais\u00e9ment un verbe ordiner, un nom d\u2019action ordination. L\u2019inconv\u00e9nient est que ordination d\u00e9signe une c\u00e9r\u00e9monie religieuse\u2009; mais les deux champs de signification (religion et comptabilit\u00e9) sont si \u00e9loign\u00e9s et la c\u00e9r\u00e9monie d\u2019ordination connue, je crois, de si peu de personnes que l\u2019inconv\u00e9nient est peut-\u00eatre mineur. D\u2019ailleurs votre machine serait ordinateur (et non-ordination) et ce mot est tout \u00e0 fait sorti de l\u2019usage th\u00e9ologique. Syst\u00e9mateur serait un n\u00e9ologisme, mais qui ne me para\u00eet pas offensant\u2009; il permet syst\u00e9matis\u00e9\u2009; \u2014 mais syst\u00e8me ne me semble gu\u00e8re utilisable \u2014 Combinateur a l\u2019inconv\u00e9nient du sens p\u00e9joratif de combine\u2009; combiner est usuel donc peu capable de devenir technique\u2009; combination ne me para\u00eet gu\u00e8re viable \u00e0 cause de la proximit\u00e9 de combinaison. Mais les Allemands ont bien leurs combinats (sorte de trusts, je crois), si bien que le mot aurait peut-\u00eatre des possibilit\u00e9s autres que celles qu\u2019\u00e9voque combine.</p> <p>Congesteur, digesteur \u00e9voquent trop congestion et digestion. Synth\u00e9tiseur ne me para\u00eet pas un mot assez neuf pour d\u00e9signer un objet sp\u00e9cifique, d\u00e9termin\u00e9 comme votre machine.</p> <p>En relisant les brochures que vous m\u2019avez donn\u00e9es, je vois que plusieurs de vos appareils sont d\u00e9sign\u00e9s par des noms d\u2019agent f\u00e9minins (trieuse, tabulatrice). Ordinatrice serait parfaitement possible et aurait m\u00eame l\u2019avantage de s\u00e9parer plus encore votre machine du vocabulaire de la th\u00e9ologie. Il y a possibilit\u00e9 aussi d\u2019ajouter \u00e0 un nom d\u2019agent un compl\u00e9ment\u2009: ordinatrice d\u2019\u00e9l\u00e9ments complexes ou un \u00e9l\u00e9ment de composition, par exemple\u2009: s\u00e9lecto-syst\u00e9mateur. S\u00e9lecto-ordinateur a l\u2019inconv\u00e9nient de deux o en hiatus, comme \u00e9lectro-ordonnatrice.</p> <p>Il me semble que je pencherais pour ordonnatrice \u00e9lectronique. Je souhaite que ces suggestions stimulent, orientent vos propres facult\u00e9s d\u2019invention. N\u2019h\u00e9sitez pas \u00e0 me donner un coup de t\u00e9l\u00e9phone si vous avez une id\u00e9e qui vous paraisse requ\u00e9rir l\u2019avis d\u2019un philologue.</p> <p>V\u00f4tre, Jacques Perret \u00bb</p>", "tags": ["ordinateur", "jacques-perret"]}, {"location": "course-c/05-introduction/programming/#la-machine-de-turing", "title": "La machine de Turing", "text": "<p>Comment pourrait-on introduire les notions d'ordinateur, de programmes et d'algorithmes sans \u00e9voquer la machine de Turing\u2009? Alan Turing est un math\u00e9maticien britannique qui a jou\u00e9 un r\u00f4le majeur dans la cr\u00e9ation de l'informatique. Il est notamment connu pour avoir cass\u00e9 le code de la machine Enigma utilis\u00e9e par les forces allemandes pendant la Seconde Guerre mondiale.</p> <p>La machine de Turing est un mod\u00e8le th\u00e9orique d'un ordinateur. Elle est compos\u00e9e d'une bande infinie divis\u00e9e en cases, d'une t\u00eate de lecture/\u00e9criture et d'un ensemble fini d'\u00e9tats. La machine de Turing est capable de lire et d'\u00e9crire des symboles sur la bande, de se d\u00e9placer \u00e0 gauche ou \u00e0 droite et de changer d'\u00e9tat. Elle est capable de simuler n'importe quel algorithme. La machine de Turing est un mod\u00e8le abstrait qui a permis de d\u00e9finir la notion de calculabilit\u00e9 et de d\u00e9montrer des r\u00e9sultats fondamentaux en informatique th\u00e9orique.</p> <p>Lorsque l'on parle d'un ordinateur Turing complet, on fait r\u00e9f\u00e9rence \u00e0 un ordinateur capable de simuler n'importe quel algorithme. Tous les ordinateurs modernes sont Turing complets. Selon le mod\u00e8le, ces ordinateurs se composent d'un programme et d'une m\u00e9moire. Le programme est une suite d'instructions qui sont ex\u00e9cut\u00e9es par le processeur. La m\u00e9moire est un espace de stockage qui contient les donn\u00e9es et les instructions du programme.</p> <p>Prenons l'exemple d'un programme visant \u00e0 additionner <code>1</code> \u00e0 un nombre <code>n</code> en binaire. L'algorithme peut \u00eatre exprim\u00e9 comme suit\u2009:</p> <p> Algorithme d'addition binaire</p> <p>On commence par l'\u00e9tat de gauche, on lit un symbole sur la bande. Tant que ce symbole est <code>0</code> ou <code>1</code> on avance \u00e0 droite. Lorsque l'on rencontre une case vide, on se d\u00e9place \u00e0 gauche et on entre dans le second \u00e9tat. Tant qu\u2019on lit un <code>1</code>, on le remplace par un <code>0</code> et on avance \u00e0 gauche. Lorsqu\u2019on lit un <code>0</code> ou une case vide, on le remplace par un <code>1</code> et on se d\u00e9place \u00e0 gauche. On revient \u00e0 l'\u00e9tat initial et on continue jusqu'\u00e0 ce que l'on rencontre une case vide.</p> <p>Sur la figure ci-dessous, on peut voir l'ex\u00e9cution de l'algorithme sur une bande apr\u00e8s chaque \u00e9tape. La case centrale est celle sous la t\u00eate de lecture/\u00e9criture. On voit bien qu'au d\u00e9but on a le nombre <code>101</code> (5) et \u00e0 la fin on obtient le nombre <code>110</code> (6). L'algorithme a bien fonctionn\u00e9.</p> <p> Ex\u00e9cution de l'algorithme sur une bande</p> <p>On peut essayer de traduire cet algorithme dans un langage formel\u2009:</p> Pseudo codeLangage formel de TuringC <pre><code>d\u00e9but:\n    lire symbole\n    si symbole = 0 ou 1 alors\n        avancer \u00e0 droite\n        aller \u00e0 d\u00e9but\n    sinon si symbole = vide alors\n        se d\u00e9placer \u00e0 gauche\n        aller retenue\nretenue:\n    lire symbole\n    si symbole = 1 alors\n        \u00e9crire 0\n        se d\u00e9placer \u00e0 gauche\n        aller \u00e0 retenue\n    sinon si symbole = 0 ou vide alors\n        \u00e9crire 1\n        se d\u00e9placer \u00e0 gauche\n</code></pre> <pre><code>input: '101'\ntable:\n  right:\n    [1,0]: R\n    ' '  : {L: carry}\n  carry:\n    1      : {write: 0, L}\n    [0,' ']: {write: 1, L: done}\ndone:\n</code></pre> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#define BAND_SIZE 1000\n\nint main() {\n    char tape[BAND_SIZE] = {0};\n    int head = BAND_SIZE / 2; // Position au milieu de la bande\n\n    scanf(\"%s\", tape + head); // Saisie du nombre d'entr\u00e9e\n\n    // Algorithme d'addition\n    char c = tape[head];\n    while (c == '0' || c == '1')\n        c = tape[++head];\n    c =  tape[--head];\n    while (c == '1') {\n        tape[head--] = '0';\n        c = tape[head];\n    }\n    tape[head] = '1';\n\n    // Recherche de la position du premier symbole non nul\n    while (tape[head]) head--;\n    head++;\n    printf(\"%s\\n\", tape + head);\n}\n</code></pre> <p></p>"}, {"location": "course-c/05-introduction/programming/#lordinateur-dantan", "title": "L'ordinateur d'antan", "text": "<p> T\u00e9l\u00e9scripteur Siemens T100</p> <p>Le t\u00e9l\u00e9scripteur Siemens T100 est un exemple d'ordinateur des ann\u00e9es 1960. Il \u00e9tait utilis\u00e9 pour la transmission de messages t\u00e9l\u00e9graphiques. Il \u00e9tait compos\u00e9 d'un clavier et d'une imprimante. Il \u00e9tait capable de lire et d'\u00e9crire des messages sur une bande de papier. Il \u00e9tait programm\u00e9 en utilisant des cartes perfor\u00e9es.</p> <p>On les appelait aussi t\u00e9l\u00e9type ou abr\u00e9g\u00e9 TTY. Ce terme est rest\u00e9 aujourd'hui pour d\u00e9signer une console de terminal.</p>"}, {"location": "course-c/05-introduction/programming/#lordinateur-moderne", "title": "L'ordinateur moderne", "text": "<p>Les ordinateurs modernes sont des machines complexes qui contiennent plusieurs composants. Les composants principaux d'un ordinateur sont\u2009:</p> Le processeur (CPU) <p>c'est le cerveau de l'ordinateur. Il ex\u00e9cute les ordres du programme.</p> La m\u00e9moire (RAM) <p>c'est l'espace de stockage temporaire des donn\u00e9es et des instructions du programme.</p> Le disque dur (HDD/SSD) <p>c'est l'espace de stockage permanent des donn\u00e9es.</p> Les p\u00e9riph\u00e9riques d'entr\u00e9e/sortie <p>ce sont les interfaces qui permettent \u00e0 l'ordinateur de communiquer avec l'utilisateur (clavier, souris, \u00e9cran, imprimante, etc.).</p> <p>Contrairement \u00e0 la machine de Turing, les ordinateurs sont \u00e9quip\u00e9s d'une m\u00e9moire \u00e0 acc\u00e8s al\u00e9atoire qui permet d'acc\u00e9der n'importe quel \u00e9l\u00e9ment de la m\u00e9moire sans avoir \u00e0 parcourir toute la bande. \u00c9galement, ces ordinateurs disposent d'un processeur capable de calculer des op\u00e9rations arithm\u00e9tiques et logiques en un temps tr\u00e8s court. Ces processeurs peuvent m\u00eame calculer des fonctions trigonom\u00e9triques, exponentielles et logarithmiques facilement. En reprenant notre programme d'addition binaire, il est beaucoup plus facile de l'\u00e9crire en C\u00a0:</p> <pre><code>#include &lt;stdio.h&gt;\nint main() {\n    int n;\n    scanf(\"%d\", &amp;n);\n    printf(\"%d\", n + 1);\n}\n</code></pre> <p>N\u00e9anmoins, il est important de comprendre que ce programme est traduit en langage machine par un programme appel\u00e9 compilateur. Une \u00e9tape interm\u00e9diaire est la traduction du programme en langage assembleur. Le langage assembleur est un langage de plus bas niveau qui permet de contr\u00f4ler directement le processeur. Ce sont les instructions primitives du processeur. Le programme ci-dessus sera converti en assembleur X86 comme suit\u2009:</p> <pre><code>.LC0:\n  .string \"%d\"\nmain:\n  sub     rsp, 24\n  mov     edi, OFFSET FLAT:.LC0\n  xor     eax, eax\n  lea     rsi, [rsp+12]\n  call    scanf\n  mov     eax, DWORD PTR [rsp+12]\n  mov     edi, OFFSET FLAT:.LC0\n  lea     esi, [rax+1]\n  xor     eax, eax\n  call    printf\n  xor     eax, eax\n  add     rsp, 24\n  ret\n</code></pre> <p>Ce programme assembleur peut ensuite \u00eatre converti en langage machine binaire qui est le langage compris par le processeur.</p> <pre><code>48 83 ec 18\nbf 00 00 00 00\n31 c0\n48 8d 74 24 0c\ne8 00 00 00 00\n8b 44 24 0c\nbf 00 00 00 00\n48 8d 70 01\n31 c0\ne8 00 00 00 00\n31 c0\n48 83 c4 18\nc3\n</code></pre> <p>In fine, ce programme sera \u00e9crit en m\u00e9moire avec des 1 et des 0\u2009:</p> <pre><code>01001000100000111110110000011000101111110000000000000000000000000000000000110001\n11000000010010001000110101110100001001000000110011101000000000000000000000000000\n00000000100010110100010000100100000011001011111100000000000000000000000000000000\n01001000100011010111000000000001001100011100000011101000000000000000000000000000\n0000000000110001110000000100100010000011110001000001100011000011\n</code></pre> <p> </p>"}, {"location": "course-c/05-introduction/programming/#les-systemes-a-microcontroleurs", "title": "Les syst\u00e8mes \u00e0 microcontr\u00f4leurs", "text": "<p>Les microcontr\u00f4leurs sont des ordinateurs complets int\u00e9gr\u00e9s dans un seul circuit int\u00e9gr\u00e9. Ils sont omnipr\u00e9sents dans notre vie quotidienne. Que ce soit la t\u00e9l\u00e9vision, le t\u00e9l\u00e9phone portable, les machines \u00e0 caf\u00e9, les voitures, les jouets, les montres ou les appareils \u00e9lectrom\u00e9nagers, ils contiennent tous un ou plusieurs microcontr\u00f4leurs.</p> <p>Ces derniers sont aussi programm\u00e9s en impl\u00e9mentant des algorithmes. Le plus souvent ces algorithmes sont \u00e9crits en langage C car c'est un langage de programmation tr\u00e8s proche du langage machine. Les microcontr\u00f4leurs sont souvent utilis\u00e9s pour contr\u00f4ler des syst\u00e8mes en temps r\u00e9el. Ils sont capables de lire des capteurs, de contr\u00f4ler des actionneurs et de communiquer avec d'autres syst\u00e8mes.</p> <p> Machine \u00e0 caf\u00e9 Citiz de Nespresso</p> <p>Prenons l'exemple de cette machine \u00e0 caf\u00e9. C'est une machine qui co\u00fbte environ 100 CHF. Elle est \u00e9quip\u00e9e d'un microcontr\u00f4leur \u00e0 30 centimes qui contr\u00f4le le chauffage, la pompe \u00e0 eau et les leds. Le microcontr\u00f4leur est programm\u00e9 pour lire les boutons de commande, contr\u00f4ler les actionneurs et afficher des messages \u00e0 l'utilisateur.</p> <p> Sch\u00e9ma bloc de la machine \u00e0 caf\u00e9 Citiz</p> <p>Derri\u00e8re se cache un programme, bien complexe. Si vous avez une de ces machines mettez l\u00e0 en service, vous verrez que s'il manque de l'eau vous aurez un message d'erreur. Au d\u00e9marrage, les LEDs clignotent le temps que la machine chauffe. Une fois en temp\u00e9rature, vous pouvez l'utiliser. Ce sont des algorithmes qui sont derri\u00e8re tout cela.</p>"}, {"location": "course-c/05-introduction/programming/#historique", "title": "Historique", "text": "<p> Historique</p> <p>Pour mieux se situer dans l'histoire de l'informatique, voici quelques dates cl\u00e9s\u2009:</p> 87 av. J.-C. <p>La machine d'Anticyth\u00e8re consid\u00e9r\u00e9 comme le premier calculateur analogique pour positions astronomiques permettant de pr\u00e9dire des \u00e9clipses. Cette machine encore si myst\u00e9rieuse \u00e0 inspir\u00e9 de nombreux sc\u00e9narios comme le film Indiana Jones et le Cadran de la destin\u00e9e. Elle a \u00e9t\u00e9 d\u00e9couverte en 1901 dans une \u00e9pave au large de l'\u00eele d'Anticyth\u00e8re. Gr\u00e2ce aux techniques modernes de radiographie, on a pu reconstruire une partie de son m\u00e9canisme.</p> 1642 <p>La Pascaline: machine d'arithm\u00e9tique de Blaise Pascal, premi\u00e8re machine \u00e0 calculer. Elle permettait d'effectuer des additions et des soustractions en utilisant des roues dent\u00e9es.</p> 1801 <p>M\u00e9tier \u00e0 tisser Jacquard programmable avec des cartes perfor\u00e9es.</p> 1837 <p>Machine \u00e0 calculer programmable de Charles Babbage. Charles Babbage est consid\u00e9r\u00e9 comme le p\u00e8re de l'informatique. Il a con\u00e7u la machine analytique qui est consid\u00e9r\u00e9e comme le premier ordinateur programmable. Ada Lovelace, fille de Lord Byron, est consid\u00e9r\u00e9e comme la premi\u00e8re programmeuse de l'histoire.</p> 1936 <p>La machine de Turing est un mod\u00e8le th\u00e9orique d'un ordinateur capable de simuler n'importe quel algorithme. Elle a \u00e9t\u00e9 invent\u00e9e par Alan Turing.</p> 1937 <p>l'ASCC (Automatic Sequence Controlled Calculator Mark I) d'IBM, le premier grand calculateur num\u00e9rique. Il \u00e9tait constitu\u00e9 de 765'000 pi\u00e8ces, dont des interrupteurs, des relais, des arbres m\u00e9caniques et des embrayages. Les ordres \u00e9taient lus \u00e0 partir d'une bande perfor\u00e9e. Une seconde bande perfor\u00e9e contenait les donn\u00e9es d'entr\u00e9e. Les instructions \u00e9tant simples, pour r\u00e9p\u00e9ter un algorithme en boucle comme l'algorithme d'Euclide, on pouvait typiquement cr\u00e9er une boucle dans la bande perfor\u00e9e.</p> <ul> <li>4500 kg</li> <li>6 secondes par multiplication \u00e0 23 chiffres d\u00e9cimaux</li> <li>Cartes perfor\u00e9es</li> </ul> 1945 <p>L'ENIAC, de Presper Eckert et John William Mauchly. C'est le premier ordinateur Turing-complet enti\u00e8rement \u00e9lectronique et fonctionnant avec des diodes et des tubes \u00e0 vide. Il \u00e9tait programm\u00e9 en branchant des c\u00e2bles et en changeant des interrupteurs. Il \u00e9tait utilis\u00e9 pour des calculs balistiques.</p> <ul> <li>160 kW</li> <li>100 kHz</li> <li>Tubes \u00e0 vide</li> <li>100'000 additions/seconde</li> <li>357 multiplications/seconde</li> </ul> 1965 <p>Premier ordinateur \u00e0 circuits int\u00e9gr\u00e9s, le PDP-8</p> <ul> <li>12 bits</li> <li>m\u00e9moire de 4096 mots</li> <li>Temps de cycle de 1.5 \u00b5s</li> <li>Fortran et BASIC</li> </ul> 2018 <p>Le Behold Summit est un superordinateur construit par IBM.</p> <ul> <li>200'000'000'000'000'000 multiplications par seconde</li> <li>simple ou double pr\u00e9cision</li> <li>14.668 GFlops/watt</li> <li>600 GiB de m\u00e9moire RAM</li> </ul> 2022 <p>Le Frontier ou OLCF-5 est le premier ordinateur exaflopique du monde.</p> <ul> <li>1,714,810,000,000,000,000 multiplications par seconde (1.1 exaflops)</li> <li>9472 processeurs Trento \u00e0 64 c\u0153urs de 2 GHz (606 208 c\u0153urs)</li> <li>37888 processeurs graphiques MI250x (8 335 360 coeurs)</li> <li>22.7 MW (5 locomotives \u00e9lectriques ou 56'750 foyers europ\u00e9ens)</li> <li>62.68 GFlops/watt</li> </ul>"}, {"location": "course-c/05-introduction/programming/#conclusion_1", "title": "Conclusion", "text": "<p>Les algorithmes existent depuis fort longtemps et sont utilis\u00e9s dans de nombreux domaines. Ils sont la base de la programmation et de l'informatique.</p> <p>Les hommes ont cherch\u00e9 \u00e0 pouvoir automatiser leurs t\u00e2ches, d'abord avec des machines m\u00e9caniques comme le m\u00e9tier \u00e0 tisser Jacquard. Puis, apr\u00e8s l'invention de la micro\u00e9lectronique, il a \u00e9t\u00e9 possible de complexifier ces machines pour en faire des ordinateurs.</p> <p>Pour les contr\u00f4ler, les informaticiens \u00e9crivent des programmes qui impl\u00e9mentent des algorithmes. Ces programmes sont ensuite traduits en langage machine par un compilateur.</p> <p>Aujourd'hui, les superordinateurs sont capables de r\u00e9aliser des milliards de milliards d'op\u00e9rations par seconde, mais ils sont toujours programm\u00e9s de la m\u00eame mani\u00e8re\u2009: avec du texte.</p>"}, {"location": "course-c/05-introduction/programming/#exercices-de-revision", "title": "Exercices de r\u00e9vision", "text": "<p>Exercise\u2009: Ordinateur</p> <p>Quelle est l'\u00e9tymologie du mot ordinateur ?</p> <ul> <li>     calculateur </li> <li>     ordonnateur </li> <li>     syst\u00e9mateur </li> <li>     ordiner </li> </ul> <p>Exercise\u2009: Machine de Turing</p> <p>Qu'est-ce que la machine de Turing\u2009?</p> <ul> <li>     Une bombe r\u00e9alis\u00e9e pour casser le code de la machine Enigma. </li> <li>     Un mod\u00e8le th\u00e9orique d'un ordinateur capable de simuler n'importe quel algorithme. </li> <li>     Le premier ordinateur \u00e9lectronique. </li> <li>     Un mod\u00e8le th\u00e9orique d'un ordinateur ne pouvant pas simuler n'importe quel algorithme. </li> </ul>"}, {"location": "course-c/10-numeration/bases/", "title": "Bases", "text": "Il y a 10 types de personnes dans le monde, celles qui comprennent le binaire, et celles qui ne le comprennent pas.M\u00e8me internet <p>Une base d\u00e9signe la valeur dont les puissances successives interviennent dans l'\u00e9criture des nombres dans la num\u00e9ration positionnelle, laquelle est un proc\u00e9d\u00e9 par lequel l'\u00e9criture des nombres est compos\u00e9e de chiffres ou symboles reli\u00e9s \u00e0 leur position voisine par un multiplicateur, appel\u00e9 base du syst\u00e8me de num\u00e9ration.</p> <p>Sans cette connaissance \u00e0 priori du syst\u00e8me de num\u00e9ration utilis\u00e9, il vous est impossible d'interpr\u00e9ter ces nombres\u2009:</p> <pre><code>69128\n11027\nj4b12\n&gt;&gt;!!0\n\u4e5d\u5343\u5341\u516b\n\u4e5d\u5343 \u96f6\u5341\u516b\n</code></pre> <p>Outre la position des symboles (l'ordre dans lequel ils apparaissent de gauche \u00e0 droite) la base du syst\u00e8me de num\u00e9ration utilis\u00e9 est essentielle pour d\u00e9coder ces nombres. Cette base d\u00e9finit combien de symboles diff\u00e9rents possibles peuvent \u00eatre utilis\u00e9s pour coder une position.</p> <p>Exercise\u2009: Symboles binaires</p> <p>Dans la notation binaire, compos\u00e9s de 1 et de 0, combien de symboles existent et combien de positions y-a-t-il dans le nombre <code>11001</code> ?</p> Solution <p>Le nombre <code>11001</code> est compos\u00e9 de 5 positions et de deux symboles possibles par position\u2009: <code>1</code> et <code>0</code>. La quantit\u00e9 d'information est donc e 5 bits.</p>", "tags": ["base"]}, {"location": "course-c/10-numeration/bases/#systeme-decimal", "title": "Syst\u00e8me d\u00e9cimal", "text": "<p>Le syst\u00e8me d\u00e9cimal est le syst\u00e8me de num\u00e9ration utilisant la base dix et le plus utilis\u00e9 par les humains au vingt et uni\u00e8me si\u00e8cle, ce qui n'a pas toujours \u00e9t\u00e9 le cas. Par exemple, les anciennes civilisations de M\u00e9sopotamie (Sumer ou Babylone) utilisaient un syst\u00e8me positionnel de base sexag\u00e9simale (60), la civilisation maya utilisait un syst\u00e8me de base 20 de m\u00eame que certaines langues celtiques dont il reste aujourd'hui quelques traces en fran\u00e7ais avec la d\u00e9nomination quatre-vingts.</p> <p>L'exemple suivant montre l'\u00e9criture de 1506 en \u00e9criture hi\u00e9roglyphique de\u2009:</p> \\[ 1000+100+100+100+100+100+1+1+1+1+1+1\\] <p>Il s'agit d'une num\u00e9ration additive.</p> <p> 1506 en \u00e9criture hi\u00e9roglyphique</p> <p>Notre syst\u00e8me de repr\u00e9sentation des nombres d\u00e9cimaux est le syst\u00e8me de num\u00e9ration indo-arabe qui emploie une notation positionnelle et dix chiffres (ou symboles) allant de z\u00e9ro \u00e0 neuf\u2009:</p> <pre><code>0 1 2 3 4 5 6 7 8 9\n</code></pre> <p>Un nombre peut \u00eatre d\u00e9compos\u00e9 en puissance successive\u2009:</p> \\[ 1506_{10} = 1 \\cdot 10^{3} + 5 \\cdot 10^{2} + 0 \\cdot 10^{1} + 6 \\cdot 10^{0} \\] <p>La base dix n'est pas utilis\u00e9e dans les ordinateurs, car elle n\u00e9cessite la manipulation de dix \u00e9tats, ce qui est difficile avec les syst\u00e8mes logiques \u00e0 deux \u00e9tats\u2009; le stockage d'un bit en m\u00e9moire \u00e9tant g\u00e9n\u00e9ralement assur\u00e9 par des transistors.</p> <p>Exercise\u2009: Deux mains</p> <p>Un dessin repr\u00e9sentant deux mains humaines (compos\u00e9es chacune de cinq doigts) est utilis\u00e9 pour repr\u00e9senter un chiffre. Les doigts peuvent \u00eatre soit lev\u00e9s, soit baiss\u00e9s mais un seul doigt peut \u00eatre lev\u00e9. Quelle est la base utilis\u00e9e\u2009?</p> Solution <p>Deux mains de cinq doigts forment une paire compos\u00e9e de 10 doigts. Il existe donc dix possibilit\u00e9s, la base est donc d\u00e9cimale\u2009: 10.</p> <p>Si plusieurs doigts peuvent \u00eatre lev\u00e9s \u00e0 la fois, il faut r\u00e9duire le syst\u00e8me \u00e0 l'unit\u00e9 de base \u00ab\u2009le doigt\u2009\u00bb pouvant prendre deux \u00e9tats\u2009: lev\u00e9 ou baiss\u00e9. Avec dix doigts (dix positions) et 2 symboles par doigts, un ombre binaire est ainsi repr\u00e9sent\u00e9.</p>", "tags": ["sexagesimale", "systeme-decimal", "indo-arabe"]}, {"location": "course-c/10-numeration/bases/#systeme-binaire", "title": "Syst\u00e8me binaire", "text": "<p>Le syst\u00e8me binaire est similaire au syst\u00e8me d\u00e9cimal, mais utilise la base deux. Les symboles utilis\u00e9s pour exprimer ces deux \u00e9tats possibles sont d'ailleurs emprunt\u00e9s au syst\u00e8me indo-arabe\u2009:</p> \\[ \\begin{bmatrix} 0\\\\ 1 \\end{bmatrix} = \\begin{bmatrix} \\text{true}\\\\ \\text{false} \\end{bmatrix} = \\begin{bmatrix} T\\\\ F \\end{bmatrix} \\] <p>En termes techniques ces \u00e9tats sont le plus souvent repr\u00e9sent\u00e9s par des signaux \u00e9lectriques dont souvent l'un des deux \u00e9tats est dit r\u00e9cessif tandis que l'autre est dit dominant. Par exemple si l'\u00e9tat <code>0</code> est symbolis\u00e9 par un verre vide et l'\u00e9tat <code>1</code> par un verre contenant du liquide. L'\u00e9tat dominant est l'\u00e9tat <code>1</code>. En effet, si le verre contient d\u00e9j\u00e0 du liquide, en rajouter ne changera pas l'\u00e9tat actuel, il y aura juste plus de liquide dans le verre.</p> <p>Un nombre binaire peut \u00eatre \u00e9galement d\u00e9compos\u00e9 en puissance successive\u2009:</p> \\[ 1101_{2} = 1 \\cdot 2^{3} + 1 \\cdot 2^{2} + 0 \\cdot 2^{1} + 1 \\cdot 2^{0} \\] <p>Le nombre de possibilit\u00e9s pour un nombre de positions \\(E\\) et une quantit\u00e9 de symboles (ou base) \\(b\\) de 2 est simplement exprim\u00e9 par\u2009:</p> \\[ N = b^E \\] <p>Avec un seul <code>bit</code> il est donc possible d'exprimer 2 valeurs distinctes.</p> <p>Exercise\u2009: Base 2</p> <p>Combien de valeurs d\u00e9cimales peuvent \u00eatre repr\u00e9sent\u00e9es avec 10-bits\u2009?</p> Solution <p>Avec une base binaire 2 et 10 bits, le total repr\u00e9sentable est\u2009:</p> \\[2^10 = 1024\\] <p>Soit les nombres de 0 \u00e0 1023.</p>", "tags": ["systeme-binaire"]}, {"location": "course-c/10-numeration/bases/#systeme-octal", "title": "Syst\u00e8me octal", "text": "<p>Invent\u00e9 par Charles XII de Su\u00e8de , le syst\u00e8me de num\u00e9ration octal utilise 8 symboles emprunt\u00e9s au syst\u00e8me indo-arabe. Ce syst\u00e8me pourrait avoir \u00e9t\u00e9 utilis\u00e9 par l'homme en comptant soit les jointures des phalanges proximales (trous entre les doigts), ou les doigts diff\u00e9rents des pouces.</p> <pre><code>0 1 2 3 4 5 6 7\n</code></pre> <p>Notons que l'utilisation des 8 premiers symboles du syst\u00e8me indo-arabe est une convention d'usage bien pratique, car tout humain occidental est familier de ces symboles. L'inconv\u00e9nient est qu'un nombre \u00e9crit en octal pourrait \u00eatre confondu avec un nombre \u00e9crit en d\u00e9cimal.</p> <p>Comme pour le syst\u00e8me d\u00e9cimal, un nombre octal peut \u00e9galement \u00eatre d\u00e9compos\u00e9 en puissance successive\u2009:</p> \\[ 1607_{8} = 1 \\cdot 8^{3} + 6 \\cdot 8^{2} + 0 \\cdot 8^{1} + 7 \\cdot 8^{0} \\] <p>Au d\u00e9but de l'informatique, la base octale fut tr\u00e8s utilis\u00e9e, car il est tr\u00e8s facile de la construire \u00e0 partir de la num\u00e9ration binaire, en regroupant les chiffres par triplets\u2009:</p> <pre><code>010'111'100'001\u2082 = 2741\u2088\n</code></pre> <p>En C, un nombre octal est \u00e9crit en pr\u00e9fixant la valeur \u00e0 repr\u00e9senter d'un z\u00e9ro. Attention donc \u00e0 ne pas confondre\u2009:</p> <pre><code>int octal = 042; // (1)!\nint decimal = 42;\n\nassert(octal != decimal);\n</code></pre> <ol> <li>La valeur <code>042</code> est un nombre octal, soit \\(4 \\cdot 8^1 + 2 \\cdot 8^0 = 34\\) en d\u00e9cimal. En C un nombre octal est pr\u00e9fix\u00e9 par un z\u00e9ro.</li> </ol> <p>Il est \u00e9galement possible de faire r\u00e9f\u00e9rence \u00e0 un caract\u00e8re en utilisant l'\u00e9chappement octal dans une cha\u00eene de caract\u00e8re\u2009:</p> <pre><code>char cr = '\\015';\nchar msg = \"Hell\\0157\\040World!\";\n</code></pre> <p>Important</p> <p>N'essayez pas de pr\u00e9fixer vos nombres avec des z\u00e9ros lorsque vous programmer car ces nombres seraient alors interpr\u00e9t\u00e9s en octal et non en d\u00e9cimal.</p>"}, {"location": "course-c/10-numeration/bases/#systeme-hexadecimal", "title": "Syst\u00e8me hexad\u00e9cimal", "text": "<p>Ce syst\u00e8me de num\u00e9ration positionnel en base 16 est le plus utilis\u00e9 en informatique pour exprimer des grandeurs binaires. Il utilise les dix symboles du syst\u00e8me indo-arabe, plus les lettres de A \u00e0 F. Il n'y a pas de r\u00e9el consensus quant \u00e0 la casse des lettres qui peuvent \u00eatre soit majuscules ou minuscules. Veillez n\u00e9anmoins \u00e0 respecter une certaine coh\u00e9rence, ne m\u00e9langez pas les casses dans un m\u00eame projet.</p> <pre><code>0 1 2 3 4 5 6 7 8 9 A B C D E F\n</code></pre> <p>L'\u00e9criture peut \u00e9galement \u00eatre d\u00e9compos\u00e9e en puissance successive\u2009:</p> \\[ 1AC7_{16} = (1 \\cdot 16^{3} + 10 \\cdot 16^{2} + 12 \\cdot 16^{1} + 7 \\cdot 16^{0})_{10} = 41415_{10} \\] <p>Il est tr\u00e8s pratique en \u00e9lectronique et en informatique d'utiliser ce syst\u00e8me de repr\u00e9sentation ou chaque chiffre hexad\u00e9cimal repr\u00e9sente un quadruplet, soit deux caract\u00e8res hexad\u00e9cimaux par octet (n'est-ce pas \u00e9l\u00e9gant\u2009?):</p> <pre><code>0101'1110'0001\u2082 = 5E1\u2081\u2086\n</code></pre> <p>L'ing\u00e9nieur qui se respecte doit conna\u00eetre par c\u0153ur la correspondance hexad\u00e9cimale de tous les quadruplets aussi bien que ses tables de multiplication (qu'il conna\u00eet d'ailleurs parfaitement, n'est-ce pas\u2009?)</p>  Correspondance binaire, octale, hexad\u00e9cimale Binaire Hexad\u00e9cimal Octal D\u00e9cimal <code>0b0000</code> <code>0x0</code> <code>00</code> <code>0</code> <code>0b0001</code> <code>0x1</code> <code>01</code> <code>1</code> <code>0b0010</code> <code>0x2</code> <code>02</code> <code>2</code> <code>0b0011</code> <code>0x3</code> <code>03</code> <code>3</code> <code>0b0100</code> <code>0x4</code> <code>04</code> <code>4</code> <code>0b0101</code> <code>0x5</code> <code>05</code> <code>5</code> <code>0b0110</code> <code>0x6</code> <code>06</code> <code>6</code> <code>0b0111</code> <code>0x7</code> <code>07</code> <code>7</code> <code>0b1000</code> <code>0x8</code> <code>10</code> <code>8</code> <code>0b1001</code> <code>0x9</code> <code>11</code> <code>0</code> <code>0b1010</code> <code>0xA</code> <code>12</code> <code>10</code> <code>0b1011</code> <code>0xB</code> <code>13</code> <code>11</code> <code>0b1100</code> <code>0xC</code> <code>14</code> <code>12</code> <code>0b1101</code> <code>0xD</code> <code>15</code> <code>13</code> <code>0b1110</code> <code>0xE</code> <code>16</code> <code>14</code> <code>0b1111</code> <code>0xF</code> <code>17</code> <code>15</code> <p>Le fichier <code>albatros.txt</code> contient un extrait du po\u00e8me de Baudelaire. Un ing\u00e9nieur en proie \u00e0 un bogue li\u00e9 \u00e0 de l'encodage de caract\u00e8re cherche \u00e0 le r\u00e9soudre et utilise le programme <code>hexdump</code> pour lister le contenu hexad\u00e9cimal de son fichier. Il obtient la sortie suivante sur son terminal\u2009:</p> <pre><code>$ hexdump -C albatros.txt\n0000  53 6f 75 76 65 6e 74 2c  20 70 6f 75 72 20 73 27  |Souvent, pour s'|\n0010  61 6d 75 73 65 72 2c 20  6c 65 73 20 68 6f 6d 6d  |amuser, les homm|\n0020  65 73 20 64 27 c3 a9 71  75 69 70 61 67 65 0d 0a  |es d'..quipage..|\n0030  50 72 65 6e 6e 65 6e 74  20 64 65 73 20 61 6c 62  |Prennent des alb|\n0040  61 74 72 6f 73 2c 20 76  61 73 74 65 73 20 6f 69  |atros, vastes oi|\n0050  73 65 61 75 78 20 64 65  73 20 6d 65 72 73 2c 0d  |seaux des mers,.|\n0060  0a 51 75 69 20 73 75 69  76 65 6e 74 2c 20 69 6e  |.Qui suivent, in|\n0070  64 6f 6c 65 6e 74 73 20  63 6f 6d 70 61 67 6e 6f  |dolents compagno|\n0080  6e 73 20 64 65 20 76 6f  79 61 67 65 2c 0d 0a 4c  |ns de voyage,..L|\n0090  65 20 6e 61 76 69 72 65  20 67 6c 69 73 73 61 6e  |e navire glissan|\n00a0  74 20 73 75 72 20 6c 65  73 20 67 6f 75 66 66 72  |t sur les gouffr|\n00b0  65 73 20 61 6d 65 72 73  2e 0d 0a 0d 0a 2e 2e 2e  |es amers........|\n00c0  0d 0a 0d 0a 43 65 20 76  6f 79 61 67 65 75 72 20  |....Ce voyageur |\n00d0  61 69 6c 65 cc 81 2c 20  63 6f 6d 6d 65 20 69 6c  |aile.., comme il|\n00e0  20 65 73 74 20 67 61 75  63 68 65 20 65 74 20 76  | est gauche et v|\n00f0  65 75 6c 65 e2 80 af 21  0d 0a 4c 75 69 2c 20 6e  |eule...!..Lui, n|\n0100  61 67 75 c3 a8 72 65 20  73 69 20 62 65 61 75 2c  |agu..re si beau,|\n0110  20 71 75 27 69 6c 20 65  73 74 20 63 6f 6d 69 71  | qu'il est comiq|\n0120  75 65 20 65 74 20 6c 61  69 64 e2 80 af 21 0d 0a  |ue et laid...!..|\n0130  4c 27 75 6e 20 61 67 61  63 65 20 73 6f 6e 20 62  |L'un agace son b|\n0140  65 63 20 61 76 65 63 20  75 6e 20 62 72 c3 bb 6c  |ec avec un br..l|\n0150  65 2d 67 75 65 75 6c 65  2c 0d 0a 4c 27 61 75 74  |e-gueule,..L'aut|\n0160  72 65 20 6d 69 6d 65 2c  20 65 6e 20 62 6f 69 74  |re mime, en boit|\n0170  61 6e 74 2c 20 6c 27 69  6e 66 69 72 6d 65 20 71  |ant, l'infirme q|\n0180  75 69 20 76 6f 6c 61 69  74 e2 80 af 21           |ui volait...!|\n018d\n</code></pre> <p>Il lit \u00e0 gauche l'offset m\u00e9moire de chaque ligne, au milieu le contenu hexad\u00e9cimal, chaque caract\u00e8re encod\u00e9 sur 8 bits \u00e9tant symbolis\u00e9s par deux caract\u00e8res hexad\u00e9cimaux, et \u00e0 droite le texte o\u00f9 chaque caract\u00e8re non imprimable est remplac\u00e9 par un point. On observe notamment ici que\u2009:</p> <ul> <li><code>\u00e9</code> de \u00e9quipage est encod\u00e9 avec <code>\\xc3\\xa9</code> ce qui est le caract\u00e8re Unicode 0065</li> <li><code>\u00e9</code> de ail\u00e9 est encod\u00e9 avec <code>e\\xcc\\x81</code>, soit le caract\u00e8re e suivi du diacritique <code>\u00b4</code> 0301</li> <li>Une espace fine ins\u00e9cable <code>\\xe2\\x80\\xaf</code> est utilis\u00e9e avant les <code>!</code>, ce qui est le caract\u00e8re Unicode 202F, conform\u00e9ment \u00e0 la recommandation de l'Acad\u00e9mie fran\u00e7aise.</li> </ul> <p>Ce fichier est donc convenablement encod\u00e9 en UTF-8 quant au bogue de notre ami ing\u00e9nieur, il concerne tr\u00e8s probablement les deux mani\u00e8res distinctes utilis\u00e9es pour encoder le <code>\u00e9</code>. On observe n\u00e9anmoins l'\u00e9l\u00e9gance de l'encodage hexad\u00e9cimal qui permet de visualiser facilement, par groupe de 8 bits, le contenu du fichier.</p> <p>Exercise\u2009: Les chiffres hexad\u00e9cimaux</p> <p>Calculez la valeur d\u00e9cimale des nombres suivants et donnez le d\u00e9tail du calcul\u2009:</p> <pre><code>0xaaaa\n0b1100101\n0x1010\n129\n0216\n</code></pre> Solution <pre><code>0xaaaa    \u2261 43690\n0b1100101 \u2261   101\n0x1010    \u2261  4112\n129       \u2261   129 (n'est-ce pas ?)\n0216      \u2261   142\n</code></pre> <p>Exercise\u2009: Albatros</p> <p>Tentez de r\u00e9cup\u00e9rer vous m\u00eame le po\u00e8me l'Albatros de Baudelaire et d'afficher le m\u00eame r\u00e9sultat que ci-dessus depuis un terminal de commande Linux.</p> <pre><code>$ wget https://.../albatros.txt\n$ hexdump -C albatros.txt\n</code></pre> <p>Si vous n'avez pas les outils <code>wget</code> ou <code>hexdump</code>, tentez de les installer ia la commande <code>apt-get install wget hexdump</code> sous Ubuntu.</p>"}, {"location": "course-c/10-numeration/bases/#conversions-de-bases", "title": "Conversions de bases", "text": "<p>La conversion d'une base quelconque en syst\u00e8me d\u00e9cimal utilise la relation suivante\u2009:</p> \\[ \\sum_{i=0}^{n-1} h_i\\cdot b^i \\] <p>o\u00f9\u2009:</p> \\(n\\) <p>Le nombre de chiffres (ou positions)</p> \\(b\\) <p>La base du syst\u00e8me d'entr\u00e9e (ou nombre de symboles)</p> \\(h_i\\) <p>La valeur du chiffre \u00e0 la position \\(i\\)</p> <p>Ainsi, la valeur <code>AP7</code> exprim\u00e9e en base tritrigesimale (base 33) et utilis\u00e9e pour repr\u00e9senter les plaques des v\u00e9hicules \u00e0 Hong Kong peut se convertir en d\u00e9cimales apr\u00e8s avoir pris connaissance de la correspondance d'un symbole tritrigesimal vers le syst\u00e8me d\u00e9cimal\u2009:</p> <pre><code>Tritrigesimal -&gt; D\u00e9cimal :\n\n 0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n\n G  H  I  K  L  M  N  P  R  S  T  U  V  W  X  Y  Z\n16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32\n\nConversion :\n\nAP7 -&gt; 10 * pow(33, 2) + 23 * pow(33, 1) + 7 * pow(33, 0) -&gt; 11'656\n</code></pre> <p>La conversion d'une grandeur d\u00e9cimale vers une base quelconque est malheureusement plus compliqu\u00e9e et n\u00e9cessite d'appliquer un algorithme.</p> <p>La conversion d'un nombre du syst\u00e8me d\u00e9cimal au syst\u00e8me binaire s'effectue simplement par une suite de divisions pour lesquelles on notera le reste.</p> <p>Pour chaque division par 2, on note le reste et tant que le quotient n'est pas nul, on it\u00e8re l'op\u00e9ration. Le r\u00e9sultat en binaire est la suite des restes lus dans le sens inverse\u2009:</p> <pre><code>n = 209\n\n209 / 2 == 104, 209 % 2 == 1  ^ sens de lecture des restes\n104 / 2 ==  52, 104 % 2 == 0  |\n 52 / 2 ==  26,  52 % 2 == 0  |\n 26 / 2 ==  13,  26 % 2 == 0  |\n 13 / 2 ==   6,  13 % 2 == 1  |\n  6 / 2 ==   3,   6 % 2 == 0  |\n  3 / 2 ==   1,   3 % 2 == 1  |\n  1 / 2 ==   0,   1 % 2 == 1  |\n\n209 == 0b11010001\n</code></pre> <p>Exercise\u2009: La num\u00e9ration Shadock</p> <p> Les Shadocks</p> <p>Les Shadocks ne connaissent que quatre mots\u2009: <code>GA</code>, <code>BU</code>, <code>ZO</code>, <code>MEU</code>. La vid\u00e9o \u00e9ducative comment compter comme les Shadocks en explique le principe. Ils utilisent par cons\u00e9quent une base quaternaire.</p> <p>Convertir <code>\u2212\u2a3c\u25cb\u25ff\u25cb</code> (<code>BU ZO GA MEU GA</code>) en d\u00e9cimal.</p> Solution <p>Le syst\u00e8me Shadock est un syst\u00e8me quaternaire similaire au syst\u00e8me du g\u00e9nome humain bas\u00e9 sur quatre bases nucl\u00e9iques. Assignons donc aux symboles Shadocks les symboles du syst\u00e8me indo-arabe que nous connaissons mieux\u2009:</p> <pre><code>0 \u25cb (GA)\n1 \u2212 (BU)\n2 \u2a3c (ZO)\n3 \u25ff (MEU)\n</code></pre> <p>Le nombre d'entr\u00e9e <code>\u2212\u2a3cO\u25ffO</code> peut ainsi s'exprimer\u2009:</p> <pre><code>\u2212\u2a3c\u25cb\u25ff\u25cb \u2261 12030\u2084\n</code></pre> <p>En appliquant la m\u00e9thode du cours, on obtient\u2009:</p> \\[     1 \\cdot 4^4 + 2 \\cdot 4^3 + 0 \\cdot 4^2 + 3 \\cdot 4^1 + 0 \\cdot 4^0 = 396_{10} \\] <p>Notons que depuis un terminal Python vous pouvez simplement utiliser\u2009:</p> <pre><code>int(\"12030\", 4)\n</code></pre>", "tags": ["base-tritrigesimale"]}, {"location": "course-c/10-numeration/bases/#autres-bases", "title": "Autres bases", "text": "<p>Une autre base couramment utilis\u00e9e est la base64, qui utilise les 26 lettres de l'alphabet latin (majuscules et minuscules), les 10 chiffres et deux symboles additionnels. Cette base est souvent utilis\u00e9e pour encoder des donn\u00e9es binaires en ASCII, par exemple pour les pi\u00e8ces jointes des courriels.</p> <p>Elle n'est pas \u00e0 proprement parler une base fondamentale, mais plut\u00f4t une m\u00e9thode de codage qui utilise 64 caract\u00e8res imprimables.</p> <p>On peut transmettre de l'information en binaire mais cela implique de pouvoir g\u00e9rer un contenu arbitraire qui n'est pas toujours \u00e9vident dans des environnements pr\u00e9vus pour des caract\u00e8res imprimables. On pourrait se dire qu'on utilise la repr\u00e9sentation ASCII des caract\u00e8res mais de nombreux caract\u00e8res ne sont pas imprimables. La base64 est une solution \u00e9l\u00e9gante pour encoder des donn\u00e9es binaires en ASCII.</p> <p>Prenons l'exemple de la phrase suivante\u2009:</p> <pre><code>La fleur en bouquet f\u00e2ne... et jamais ne renait !\n</code></pre> <p>Si l'on affiche le contenu hexad\u00e9cimal de cette phrase, on obtient\u2009:</p> <pre><code>$ echo -ne 'La fleur en bouquet f\u00e2ne... et jamais ne renait !'  | hexdump -C\n0000  4c 61 20 66 6c 65 75 72  20 65 6e 20 62 6f 75 71  |La fleur en bouq|\n0010  75 65 74 20 66 c3 a2 6e  65 2e 2e 2e 20 65 74 20  |uet f..ne... et |\n0020  6a 61 6d 61 69 73 20 6e  65 20 72 65 6e 61 69 74  |jamais ne renait|\n0030  20 21                                             | !|\n0032\n</code></pre> <p>En base64, le message est d\u00e9coup\u00e9 en mot de 6 bits, soit 64 valeurs possibles. Chaque mot de 6 bits est ensuite converti en un caract\u00e8re ASCII avec la table de codage suivante\u2009:</p> <pre><code>0  000000 A    17 010001 R    34 100010 i    51 110011 z\n1  000001 B    18 010010 S    35 100011 j    52 110100 0\n2  000010 C    19 010011 T    36 100100 k    53 110101 1\n3  000011 D    20 010100 U    37 100101 l    54 110110 2\n4  000100 E    21 010101 V    38 100110 m    55 110111 3\n5  000101 F    22 010110 W    39 100111 n    56 111000 4\n6  000110 G    23 010111 X    40 101000 o    57 111001 5\n7  000111 H    24 011000 Y    41 101001 p    58 111010 6\n8  001000 I    25 011001 Z    42 101010 q    59 111011 7\n9  001001 J    26 011010 a    43 101011 r    60 111100 8\n10 001010 K    27 011011 b    44 101100 s    61 111101 9\n11 001011 L    28 011100 c    45 101101 t    62 111110 +\n12 001100 M    29 011101 d    46 101110 u    63 111111 /\n13 001101 N    30 011110 e    47 101111 v\n14 001110 O    31 011111 f    48 110000 w    (compl\u00e9ment) =\n15 001111 P    32 100000 g    49 110001 x\n16 010000 Q    33 100001 h    50 110010 y\n</code></pre> <p>Ainsi le message commence par <code>4c612</code> ou en binaire <code>01001100 01100001 0010</code>. D\u00e9coup\u00e9 en paquet de 6 bits <code>010011 000110 000100 10</code>, on utilise selon la table de codage <code>TGE</code>. Comme il s'agit d'un encodage courant, il existe des outils pour le faire automatiquement\u2009:</p> <pre><code>echo -ne 'La fleur en bouquet f\u00e2ne... et jamais ne renait !' | base64\nTGEgZmxldXIgZW4gYm91cXVldCBmw6JuZS4uLiBldCBqYW1haXMgbmUgcmVuYWl0ICE=\n</code></pre> <p>Si le message n'est pas un multiple de \\(4\\times 6\\) bits, il est compl\u00e9t\u00e9 avec des z\u00e9ros et le caract\u00e8re <code>=</code> est ajout\u00e9 \u00e0 la fin du message pour indiquer le nombre de z\u00e9ros ajout\u00e9s. Notre message \u00e0 une longueur de 50 caract\u00e8res, ou bien 400 bits, qui n'est pas divisible par 24. On compl\u00e8te donc avec <code>=</code>.</p> <pre><code>echo -ne 'La fleur en bouquet f\u00e2ne... et jamais ne renait'  | wc -c\n50\n</code></pre>", "tags": ["base64", "ascii"]}, {"location": "course-c/10-numeration/introduction/", "title": "Introduction", "text": "", "tags": ["complement-a-deux", "complement-a-un", "numeration", "bit"]}, {"location": "course-c/10-numeration/introduction/#numeration_1", "title": "Num\u00e9ration", "text": "L'informatique ne concerne pas plus les ordinateurs que l'astronomie ne concerne les t\u00e9lescopes... La science ne concerne pas les outils. Elle concerne la mani\u00e8re dont nous les utilisons et ce que nous d\u00e9couvrons en les utilisant.Edsger W. Dijkstra <p>La num\u00e9ration d\u00e9signe le mode de repr\u00e9sentation des nombres (p. ex. cardinaux, ordinaux), leur base (syst\u00e8me binaire, ternaire, quinaire, d\u00e9cimal ou vic\u00e9simal), ainsi que leur codification, IEEE 754, compl\u00e9ment \u00e0 un, compl\u00e9ment \u00e0 deux. Bien comprendre les bases de la num\u00e9ration est important pour l'ing\u00e9nieur d\u00e9veloppeur, car il est souvent amen\u00e9 \u00e0 effectuer des op\u00e9rations de bas niveau sur les nombres.</p> <p>Ce chapitre n'est essentiel qu'au programmeur de bas niveau, l'\u00e9lectronicien ou l'informaticien technique. Bien comprendre la num\u00e9ration permet de mieux se repr\u00e9senter la mani\u00e8re dont l'ordinateur traite les donn\u00e9es au niveau le plus fondamental\u2009: le bit.</p>"}, {"location": "course-c/10-numeration/introduction/#quantite-dinformation-bit", "title": "Quantit\u00e9 d'information (bit)", "text": "<p>Un bit est l'unit\u00e9 d'information fondamentale qui ne peut prendre que deux \u00e9tats\u2009: <code>1</code> ou <code>0</code>. En \u00e9lectronique, cette information peut \u00eatre stock\u00e9e dans un \u00e9l\u00e9ment m\u00e9moire par une charge \u00e9lectrique. Dans le monde r\u00e9el, on peut stocker un bit avec une pi\u00e8ce de monnaie d\u00e9pos\u00e9e sur le c\u00f4t\u00e9 pile ou face. L'assemblage de plusieurs bits permet de stocker de l'information plus complexe.</p> <p>Le bit est l'abr\u00e9viation de binary digit (chiffre binaire) et est central \u00e0 la th\u00e9orie de l'information. Le concept a \u00e9t\u00e9 popularis\u00e9 par Claude Shannon dans son article fondateur de la th\u00e9orie de l'information en 1948\u2009: A Mathematical Theory of Communication. Shannon y introduit le bit comme unit\u00e9 de mesure de l'information.</p> <p>S'il existe un meuble avec huit casiers assez grands pour une pomme, et que l'on souhaite conna\u00eetre le nombre de possibilit\u00e9s de rangement, on sait que chaque casier peut contenir soit une pomme, soit oaucune. Le nombre de possibilit\u00e9s est alors de \\(2^8 = 256\\). La quantit\u00e9 d'information n\u00e9cessaire \u00e0 conna\u00eetre l'\u00e9tat du meuble est de 8 bits.</p> <p>On pourrait utiliser ce meuble, et ces pommes pour repr\u00e9senter son \u00e2ge. Une personne de 42 ans n'aurait pas besoin de 42 pommes, mais seulement de 3. En effet, si on repr\u00e9sente l'absence de pomme par <code>0</code> et la pr\u00e9sence d'une pomme par <code>1</code>, on obtient\u2009:</p> <pre><code>0 0 1 0 1 0 1 0\n</code></pre> <p>Si l'on souhaite repr\u00e9senter l'\u00e9tat d'un meuble beaucoup plus grand, par exemple un meuble de 64 casiers, la quantit\u00e9 d'information repr\u00e9sentable est de\u2009:</p> \\[2^{64} = 18'446'744'073'709'551'616\\] <p>ou 64 bits. Cela permet de repr\u00e9senter le nombre de grains de sable sur Terre, le nombre de secondes dans 584'942 ann\u00e9es, ou le nombre de combinaisons possibles pour un mot de passe de 8 caract\u00e8res.</p> <p>La quantit\u00e9 d'information peut s'exprimer par la formule suivante\u2009:</p> \\[I = \\log_2(N)\\] <p>o\u00f9 \\(I\\) est la quantit\u00e9 d'information en bits, et \\(N\\) est le nombre de possibilit\u00e9s.</p> <p>Les informaticiens ont l'habitude de regrouper les bits par 8 pour former un octet. Un octet peut donc repr\u00e9senter \\(256\\) valeurs diff\u00e9rentes. Un octet est souvent appel\u00e9 un byte en anglais, mais ce terme est ambigu, car il peut \u00e9galement d\u00e9signer un groupe de bits de taille variable.</p> <p>Lorsque vous achetez un disque de stockage pour votre ordinateur, vous pouvez par exemple lire sur l'emballage que le disque a une capacit\u00e9 de 1 To (T\u00e9ra-octet). Un T\u00e9ra-octet est \u00e9gal \u00e0 \\(2^{40}\\) octets, soit \\(1'099'511'627'776\\) octets. Un octet \u00e9gant \u00e9gal \u00e0 8 bits, donc un T\u00e9ra-octet est \u00e9gal \u00e0 \\(8'796'093'022'208\\) bits. \u00c0 titre d'information l'enti\u00e8ret\u00e9 de Wikip\u00e9dia en p\u00e8se environ 22 Go (Giga-octet). On peut donc dire que notre disque de 1 To permettrait de stocker 45 copies de Wikip\u00e9dia.</p> <p>Pour repr\u00e9senter l'\u00e9tat de Wikip\u00e9dia, il suffirait donc d'avoir \\(10'225'593'776'312\\) pommes et de l'armoire appropri\u00e9e.</p> <p>Exercise\u2009: Pile ou face</p> <p>Lors d'un tir \u00e0 pile ou face de l'engagement d'un match de football, l'arbitre lance une pi\u00e8ce de monnaie qu'il rattrape et d\u00e9pose sur l'envers de sa main. Lorsqu'il annonce le r\u00e9sultat de ce tir, quelle quantit\u00e9 d'information transmet-il\u2009?</p> Solution <p>Il transmet un seul 1 bit d'information\u2009: \u00e9quipe A ou pile ou <code>1</code>, \u00e9quipe B ou face ou <code>0</code>. Il faut n\u00e9anmoins encore d\u00e9finir \u00e0 quoi correspond cette information.</p> <p>Entropie</p> <p>On entends souvent que l'entropie est la mesure du d\u00e9sordre d'un syst\u00e8me. En thermodynamique, l'entropie est une mesure de l'\u00e9nergie non disponible. En informatique, l'entropie est une mesure de l'incertitude d'une information. Plus une information est incertaine, plus elle contient d'entropie. L'entropie est souvent mesur\u00e9e en bits, et est utilis\u00e9e en cryptographie pour mesurer la qualit\u00e9 d'un g\u00e9n\u00e9rateur de nombres al\u00e9atoires.</p> <p>N\u00e9anmoins l'entropie peut \u00e9galement \u00eatre utilis\u00e9e pour mesurer la quantit\u00e9 d'information transmise par un message. Plus un message est incertain, plus il contient d'entropie. Par exemple, si un message est compos\u00e9 de 8 bits, il contient 8 bits d'entropie. Si le message est compos\u00e9 de 16 bits, il contient 16 bits d'entropie.</p>", "tags": ["claude-shannon", "chiffre", "octet", "entropie"]}, {"location": "course-c/10-numeration/introduction/#les-prefixes", "title": "Les pr\u00e9fixes", "text": "<p>On l'a vu, le nombre de bits peut \u00eatre tr\u00e8s grand et m\u00eame divis\u00e9 par 8 pour obtenir un nombre d'octets, il est difficile avec des nombres simples de repr\u00e9senter ces quantit\u00e9s. C'est pourquoi on utilise des pr\u00e9fixes.</p> <p>Avec le syst\u00e8me international d'unit\u00e9s, on utilise des pr\u00e9fixes pour exprimer des multiples de 10. Par exemple, un kilogramme est \u00e9gal \u00e0 1000 grammes. La tonne est \u00e9gale \u00e0 1000 kilogrammes.</p> <p>En informatique, comme on utilise un syst\u00e8me binaire en puissance de deux, rajouter un bit double la quantit\u00e9 d'information. On utilise donc des pr\u00e9fixes pour exprimer des multiples de 2. Un kilo-octet est \u00e9gal \u00e0 1000 octets \\(10^3\\), mais un kibi-octet est \u00e9gal \u00e0 1024 octets \\(2^10\\). Les pr\u00e9fixes binaires sont d\u00e9finis par l'IEC (International Electrotechnical Commission) et sont les suivants\u2009:</p> Pr\u00e9fixes standardsPr\u00e9fixes binaires  Pr\u00e9fixes standards Pr\u00e9fixe Symbole \\(10^n\\) Kilo K \\(10^3\\) M\u00e9ga M \\(10^6\\) Giga G \\(10^9\\) T\u00e9ra T \\(10^{12}\\) Peta P \\(10^{15}\\) Exa E \\(10^{18}\\) Zetta Z \\(10^{21}\\) Yotta Y \\(10^{24}\\)  Pr\u00e9fixes binaires Pr\u00e9fixe Symbole \\(2^{10n}\\) Kibi Ki \\(2^{10}\\) M\u00e9bi Mi \\(2^{20}\\) Gibi Gi \\(2^{30}\\) T\u00e9bi Ti \\(2^{40}\\) P\u00e9bi Pi \\(2^{50}\\) Exbi Ei \\(2^{60}\\) Zebi Zi \\(2^{70}\\) Yobi Yi \\(2^{80}\\) <p>Info</p> <p>Les pr\u00e9fixes binaires sont m\u00e9connus et peu utilis\u00e9s par le marketing. Les disques durs sont souvent vendus en Go (Giga-octets) alors que les syst\u00e8mes d'exploitation les affichent en Gio (Gibi-octets). Il est donc important de bien comprendre la diff\u00e9rence entre ces deux unit\u00e9s.</p>", "tags": ["prefixes-binaires"]}, {"location": "course-c/10-numeration/introduction/#notation-positionnelle", "title": "Notation positionnelle", "text": "<p>La num\u00e9ration est un syst\u00e8me de repr\u00e9sentation des nombres. La num\u00e9ration d\u00e9cimale est un syst\u00e8me de base 10, c'est-\u00e0-dire que chaque chiffre peut prendre 10 valeurs diff\u00e9rentes\u2009: \\(0, 1, 2, 3, 4, 5, 6, 7, 8, 9\\). La position des chiffres dans un nombre d\u00e9cimal indique la puissance de 10 \u00e0 laquelle il est multipli\u00e9. Par exemple, le nombre 123 est \u00e9gal \u00e0\u2009:</p> \\[1 \\times 10^2 + 2 \\times 10^1 + 3 \\times 10^0\\] <p>On parle de notation positionnelle, car la position des chiffres est importante. Le chiffre le plus \u00e0 droite est le chiffre des unit\u00e9s, le chiffre \u00e0 sa gauche est le chiffre des dizaines, puis des centaines, etc.</p> <p>En informatique, et particuli\u00e8rement en binaire on nomme LSB (Least Significant Bit) le bit de poids faible et MSB (Most Significant Bit) le bit de poids fort. Le bit de poids faible est le bit le plus \u00e0 droite, et le bit de poids fort est le bit le plus \u00e0 gauche.</p> <p>On notera que le LSB permet de savoir si le nombre est pair ou impair, si le LSB est \u00e0 <code>0</code>, le nombre est pair, et s'il est \u00e0 <code>1</code>, le nombre est impair\u2009:</p> <pre><code>bool is_even(int n) {\n    return n &amp; 1 == 0;\n}\n</code></pre> <p>Le MSB quant \u00e0 lui permet de savoir si le nombre est positif ou n\u00e9gatif dans un nombre sign\u00e9. Si le MSB est \u00e0 <code>0</code>, le nombre est positif, et s'il est \u00e0 <code>1</code>, le nombre est n\u00e9gatif (on pr\u00e9f\u00e8rera plut\u00f4t utiliser <code>n &lt; 0</code> pour v\u00e9rifier si un nombre est n\u00e9gatif).</p> <pre><code>bool is_negative(int32_t n) {\n    return n &amp; 0x80000000 == 0x80000000;\n}\n</code></pre> <p>Exercise\u2009: Nature de ces nombres\u2009?</p> <p>Pour les nombres suivants stock\u00e9s sur 8-bit, pouvez-vous dire s'ils sont pairs ou impairs, positifs ou n\u00e9gatifs\u2009?</p> <ol> <li><code>0b01100000</code></li> <li><code>0b00001001</code></li> <li><code>0b10000000</code></li> <li><code>0b11011011</code></li> </ol> Solution <ol> <li>Pair, positif</li> <li>Impair, positif</li> <li>Pair, n\u00e9gatif</li> <li>Impair, n\u00e9gatif</li> </ol>", "tags": ["least-significant-bit", "most-significant-bit", "base-10"]}, {"location": "course-c/10-numeration/numbers/", "title": "Nombres", "text": "<p>Vous avez tous appris dans votre enfance \u00e0 compter, puis vous avez appris que les nombres se classifient dans des ensembles. Les math\u00e9maticiens ont d\u00e9fini des ensembles de nombres pour lesquels des propri\u00e9t\u00e9s particuli\u00e8res sont v\u00e9rifi\u00e9es\u2009; ces ensembles sont imbriqu\u00e9s les uns dans les autres, et chaque ensemble est un sous-ensemble de l'ensemble suivant.</p> \\[ \\mathbb{N} \\in \\mathbb{Z} \\in \\mathbb{Q} \\in \\mathbb{R} \\in \\mathbb{C} \\in \\mathbb{H} \\in \\mathbb{O} \\in \\mathbb{S} \\] <p> Ensemble des nombres</p> <p>Les ensembles de nombres sont\u2009:</p> <ul> <li>\\(\\mathbb{N}\\) : ensemble des entiers naturels (0, 1, 2, 3, ...)</li> <li>\\(\\mathbb{Z}\\) : ensemble des entiers relatifs (..., -3, -2, -1, 0, 1, 2, 3, ...)</li> <li>\\(\\mathbb{D}\\) : ensemble des d\u00e9cimaux (-0.1, 0, 0.1, 0.2, 0.3, ...)</li> <li>\\(\\mathbb{Q}\\) : ensemble des rationnels (0, 1, \u00bd, \u2153, \u00bc, ...)</li> <li>\\(\\mathbb{R}\\) : ensemble des r\u00e9els (\\(\\pi\\), \\(\\sqrt{2}\\), ...)</li> <li>\\(\\mathbb{C}\\) : ensemble des complexes (\\(i\\), \\(1 + i\\), ...)</li> <li>\\(\\mathbb{H}\\) : ensemble des quaternions (\\(1 + i + j + k\\), ...)</li> <li>\\(\\mathbb{O}\\) : ensemble des octonions</li> <li>\\(\\mathbb{S}\\) : ensemble des s\u00e9d\u00e9nions</li> </ul> <p>Quaternions, octonions et s\u00e9d\u00e9nions</p> <p>Les quaternions, octonions et s\u00e9d\u00e9nions sont des nombres hypercomplexes qui g\u00e9n\u00e9ralisent les nombres complexes. Ils sont utilis\u00e9s en physique pour d\u00e9crire les rotations dans l'espace.</p> <p>Les quaternions sont utilis\u00e9s en informatique pour repr\u00e9senter les rotations en 3D. Les octonions et s\u00e9d\u00e9nions sont des g\u00e9n\u00e9ralisations des quaternions, mais ils sont moins utilis\u00e9s en pratique.</p> <p>A chaque fois que s'\u00e9loigne du r\u00e9el (et c'est une mani\u00e8re amusante de le dire), on perd des propri\u00e9t\u00e9s int\u00e9ressantes. Les nombres complexes ne sont pas ordonn\u00e9s, les quaternions ne sont pas commutatifs, les octonions ne sont pas associatifs, et les s\u00e9d\u00e9nions ne sont m\u00eame pas alternatifs. Un nombre alternatif est un nombre pour lequel la formule suivante est v\u00e9rifi\u00e9e\u2009:</p> \\[ (a \\cdot a) \\cdot b = a \\cdot (a \\cdot b) \\] <p>En pratique dans une carri\u00e8re d'ing\u00e9nieur, vous n'aurez jamais \u00e0 manipuler ni des quaternions, ni octonions ou s\u00e9d\u00e9nions. Les nombres complexes sont n\u00e9anmoins une extension des nombres r\u00e9els qui sont utilis\u00e9s en physique et en math\u00e9matiques.</p> <p>Un nombre arbitraire n'est pas directement associ\u00e9 \u00e0 une quantit\u00e9 d'information. Le nombre \\(\\pi\\) est irrationnel, c'est-\u00e0-dire qu'il ne se termine jamais et ne se r\u00e9p\u00e8te jamais. Il est donc impossible de stocker \\(\\pi\\) en m\u00e9moire, car il faudrait une quantit\u00e9 infinie de bits pour le repr\u00e9senter.</p> <p>Archim\u00e8de disait\u2009: \u0394\u03cc\u03c2 \u03bc\u03bf\u03b9 \u03c0\u1fb6 \u03c3\u03c4\u1ff6 \u03ba\u03b1\u1f76 \u03c4\u1f70\u03bd \u03b3\u1fb6\u03bd \u03ba\u03b9\u03bd\u03ac\u03c3\u03c9 (Donnez-moi un point d'appui et je soul\u00e8verai le monde). Le Cr\u00e9ateur, s'il existe, aurait pu dire\u2009: Donnez moi un nombre et je vous construirai l'univers\u2009! Bien entendu la quantit\u00e9 d'information dans l'univers est colossale, elle cro\u00eet avec l'entropie et donc avec le temps qui passe.</p> <p>Minecraft</p> <p>Dans Minecraft, lorsque vous cr\u00e9ez un monde, vous pouvez utiliser une graine pour g\u00e9n\u00e9rer un monde al\u00e9atoire. Cette graine est un nombre fini qui sert de base \u00e0 l'algorithme de g\u00e9n\u00e9ration de monde. Si vous utilisez la m\u00eame graine, vous obtiendrez le m\u00eame monde. La graine -5584399987456711267 permet par exemple d'obtenir de merveilleux cerisiers en fleurs qui rappelle la saison de Sakura \u00e0 Kyoto.</p> <p>Mais pour que cela fonctionne il vous faut le code source de Minecraft, lui aussi c'est une succession de 0 et de 1, et donc c'est un nombre, lui aussi fini.</p> <p>Enfin, lorsque vous jouez, vos actions g\u00e9n\u00e8rent de l'information qui influence le monde, et donc la quantit\u00e9 d'information dans le monde cro\u00eet. C'est pour cela que plus vous jouez, plus la sauvegarde de votre monde devient grande, mais vous pouvez la repr\u00e9senter aussi avec un nombre fini.</p> <p>Les m\u00e9moires des ordinateurs ne sont pas infinies, elles sont limit\u00e9es par la quantit\u00e9 de transistors qui les composent. Il n'est donc pas possible d'y stocker n'importe quel nombre. \\(\\pi\\) ne peut pas \u00eatre stock\u00e9 en m\u00e9moire, mais une approximation de \\(\\pi\\) peut l'\u00eatre.</p> <p>Aussi, l'informatique impose certaines limitations sur les nombres que l'on peut manipuler. Les nombres entiers sont les plus simples \u00e0 manipuler, mais ils sont limit\u00e9s par la taille de la m\u00e9moire et la mani\u00e8re dont on les enregistre en m\u00e9moire. C'est ce que nous allons voir.</p>", "tags": ["octonions", "sedenions", "archimede", "entiers-relatifs", "quaternions", "nombres-hypercomplexes", "entiers-naturels", "graine", "nombres-complexes", "minecraft"]}, {"location": "course-c/10-numeration/numbers/#entiers-naturels", "title": "Entiers naturels", "text": "<p>En math\u00e9matiques, un entier naturel est un nombre positif ou nul. Chaque nombre \u00e0 un successeur unique et peut s'\u00e9crire avec une suite finie de chiffres en notation d\u00e9cimale positionnelle, et donc sans signe et sans virgule. L'ensemble des entiers naturels est d\u00e9fini de la fa\u00e7on suivante\u2009:</p> \\[ \\mathbb{N} = {0, 1, 2, 3, ...} \\] <p>Les entiers sont les premiers types de donn\u00e9es manipul\u00e9s par les ordinateurs. Ils sont stock\u00e9s en m\u00e9moire sous forme de bits. En choisissant la taille de stockage des entiers, on d\u00e9termine la plage de valeurs que l'on peut repr\u00e9senter. Un entier de 8 bits peut repr\u00e9senter \\(2^8 = 256\\) valeurs diff\u00e9rentes, de 0 \u00e0 255. Un entier de 16 bits peut repr\u00e9senter \\(2^{16} = 65536\\) valeurs diff\u00e9rentes, de 0 \u00e0 65535.</p> <p>Exemple</p> <p>Le nombre 142 peut s'\u00e9crire sur 8 bits en binaire, avec une notation positionnelle (o\u00f9 les bits sont align\u00e9s par poids d\u00e9croissants) on peut \u00e9crire\u2009:</p> \\[ \\begin{array}{cccccccc} 2^7 &amp; 2^6 &amp; 2^5 &amp; 2^4 &amp; 2^3 &amp; 2^2 &amp; 2^1 &amp; 2^0 \\\\ 1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 &amp; 1 &amp; 1 &amp; 0 \\\\ \\end{array} \\] <p>La taille de stockage d'un entier d\u00e9termine donc ses limites. Si cette mani\u00e8re est \u00e9l\u00e9gante, elle ne permet pas de repr\u00e9senter des valeurs n\u00e9gatives. Pour cela, on aura recours aux entiers relatifs.</p>"}, {"location": "course-c/10-numeration/numbers/#entiers-relatifs", "title": "Entiers relatifs", "text": "<p>Math\u00e9matiquement un entier relatif appartient \u00e0 l'ensemble \\(\\mathbb{Z}\\):</p> \\[ \\mathbb{Z} = {..., -3, -2, -1, 0, 1, 2, 3, ...} \\] <p>Vous le savez maintenant, l'interpr\u00e9tation d'une valeur binaire n'est possible qu'en ayant connaissance de son encodage et s'agissant d'entiers, on peut se demander comment stocker des valeurs n\u00e9gatives, car manque une information permettant d'encoder le symbole pour le signe <code>-</code> (ni m\u00eame d'ailleurs <code>+</code>).</p> <p>Une approche na\u00efve serait de r\u00e9server une partie de la m\u00e9moire pour des entiers positifs et une autre pour des entiers n\u00e9gatifs et stocker la correspondance binaire/d\u00e9cimale simplement. Un peu comme si vous aviez deux bo\u00eetes chez vous, l'une pour les choses qui se mangent (le frigo) et une pour les choses qui ne se mangent plus (la poubelle).</p> <p>L'ennui pour les variables c'est que le contenu peut changer et qu'un nombre n\u00e9gatif pourrait tr\u00e8s bien devenir positif apr\u00e8s un calcul. Il faudrait alors le d\u00e9placer d'une r\u00e9gion m\u00e9moire \u00e0 une autre. Ce n'est donc pas la meilleure m\u00e9thode.</p> <p>On pourrait alors renseigner la nature du nombre, c'est-\u00e0-dire son signe avec sa valeur.</p>"}, {"location": "course-c/10-numeration/numbers/#bit-de-signe", "title": "Bit de signe", "text": "<p>Pourquoi ne pas se r\u00e9server un bit de signe, par exemple le 8<sup>e</sup> bit de notre nombre de 8 bits, pour indiquer si le nombre est positif ou n\u00e9gatif\u2009?</p> <pre><code>\u250c\u2500\u2510\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\n\u25020\u2502\u25021\u25020\u25021\u25020\u25020\u25021\u25021\u2502 = (0 * (-1)) * 0b1010011 = 83\n\u2514\u2500\u2518\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n\u250c\u2500\u2510\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\n\u25021\u2502\u25021\u25020\u25021\u25020\u25020\u25021\u25021\u2502 = (1 * (-1)) * 0b1010011 = -83\n\u2514\u2500\u2518\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n</code></pre> <p>Cette m\u00e9thode impose le sacrifice d'un bit et donc l'intervalle repr\u00e9sentable est ici n'est plus que de <code>[-127..127]</code>. Elle pr\u00e9sente un autre inconv\u00e9nient majeur\u2009: la repr\u00e9sentation de z\u00e9ro.</p> <p>Il existe alors deux z\u00e9ros, le z\u00e9ro n\u00e9gatif <code>0b00000000</code>, et le z\u00e9ro positif <code>0b10000000</code> ce qui peut poser des probl\u00e8mes pour les comparaisons. Est-ce que \\(0\\) est \u00e9gal \\(-0\\) ? En un sens oui, mais en termes de l'information stock\u00e9e, ce n'est pas le m\u00eame nombre.</p> <p>En termes de calcul, l'addition ne fonctionne plus si on raisonne sur les bits. Car si on additionne au z\u00e9ro positif (<code>0b10000000</code>) la valeur 1 on aura 1, mais si on additionne au z\u00e9ro n\u00e9gatif (<code>0b00000000</code>) la valeur 1 on obtiendra -1. C'est un peu d\u00e9routant.</p> <pre><code>000   001   010   011   100   101   110   111\n\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500&gt;\n\n000   001   010   011   100   101   110   111\n\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500&gt;  \u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500&gt; M\u00e9thode du bit de signe\n 0     1     2     3     0    -1    -2    -3\n</code></pre> <p>Il faudrait donc trouver une m\u00e9thode qui permettrait de conserver la possibilit\u00e9 de faire les op\u00e9rations directement en binaire. En d'autres termes on aimerait pouvoir calculer en base deux sans se soucier du signe\u2009:</p> <pre><code>  00000010 (2)\n- 00000101 (5)\n----------\n  11111101 (-125)    2 - 5 != -125\n</code></pre> <p>Si on r\u00e9sume, la solution propos\u00e9e qui utilise un bit de signe pose deux probl\u00e8mes\u2009:</p> <ol> <li>Les op\u00e9rations ne sont plus triviales, et un algorithme particulier doit \u00eatre mis en place pour les g\u00e9rer.</li> <li>Le double z\u00e9ro (positif et n\u00e9gatif) est g\u00eanant.</li> </ol>", "tags": ["bit-de-signe"]}, {"location": "course-c/10-numeration/numbers/#complement-a-un", "title": "Compl\u00e9ment \u00e0 un", "text": "<p>Le compl\u00e9ment \u00e0 un est une m\u00e9thode plus maline utilis\u00e9e dans les premiers ordinateurs comme le CDC 6600 (1964) ou le UNIVAC 1107 (1962). Il existe \u00e9galement un bit de signe, mais il est implicite. </p> <p>Le compl\u00e9ment \u00e0 un tire son nom de sa d\u00e9finition g\u00e9n\u00e9rique nomm\u00e9e radix-complement ou compl\u00e9ment de base et s'exprime par\u2009:</p> \\[ b^n - y \\] <p>o\u00f9</p> \\(b\\) <p>La base du syst\u00e8me positionnel utilis\u00e9</p> \\(n\\) <p>Le nombre de chiffres maximal du nombre consid\u00e9r\u00e9</p> \\(y\\) <p>La valeur \u00e0 compl\u00e9menter.</p> <p>Ainsi, il est facile d'\u00e9crire le compl\u00e9ment \u00e0 neuf d'un nombre en base dix, car on s'arrange pour que chaque chiffre composant le nombre on trouve un autre chiffre dont la somme est \u00e9gale \u00e0 neuf.</p> <pre><code>0 1 2 3 4 5 6 7 8 9\n        |\n        | Compl\u00e9ment \u00e0 9\n        v\n9 8 7 6 5 4 3 2 1 0\n</code></pre> <p>On notera avec beaucoup d'int\u00e9r\u00eat qu'un calcul est possible avec cette m\u00e9thode. \u00c0 gauche on a une soustraction classique, \u00e0 droite on remplace la soustraction par une addition ainsi que les valeurs n\u00e9gatives par leur compl\u00e9ment \u00e0 9. Le r\u00e9sultat <code>939</code> correspond \u00e0 <code>60</code>.</p> <pre><code>  150      150\n- 210    + 789\n-----    -----\n  -60      939\n</code></pre> <p>Notons que le cas pr\u00e9cis de l'inversion des chiffres correspond au compl\u00e9ment de la base, moins un. L'inversion des bits binaire est donc le compl\u00e9ment \u00e0 \\((2-1) = 1\\).</p> <pre><code>000   001   010   011   100   101   110   111\n\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500&gt;\n\n000   001   010   011   100   101   110   111\n\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500&gt; &lt;\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500 compl\u00e9ment \u00e0 un\n 0     1     2     3    -3    -2    -1     0\n</code></pre> <p>Reprenons l'exemple pr\u00e9c\u00e9dent de soustraction, on notera que l'op\u00e9ration fonctionne en soustrayant 1 au r\u00e9sultat du calcul.</p> <pre><code>  00000010 (2)\n+ 11111010 (-5)\n----------\n  11111101 (-3)\n-        1\n----------\n  11111011 (-4)\n</code></pre> <p>En r\u00e9sum\u00e9, la m\u00e9thode du compl\u00e9ment \u00e0 1\u2009:</p> <ol> <li>Les op\u00e9rations redeviennent presque triviales, mais il est n\u00e9cessaire de soustraire 1 au r\u00e9sultat (c'est dommage).</li> <li>Le double z\u00e9ro (positif et n\u00e9gatif) est g\u00eanant.</li> </ol> <p></p>", "tags": ["complement-a-neuf"]}, {"location": "course-c/10-numeration/numbers/#complement-a-deux", "title": "Compl\u00e9ment \u00e0 deux", "text": "<p>Le compl\u00e9ment \u00e0 deux n'est rien d'autre que le compl\u00e9ment \u00e0 un plus un. C'est donc une amusante plaisanterie des informaticiens. Car dans un syst\u00e8me binaire, le nombre de symboles et de 2 (<code>0</code> et <code>1</code>). On ne peut pas trouver un chiffre tel que la somme fasse <code>2</code>. C'est la m\u00eame id\u00e9e que de demander le compl\u00e9ment \u00e0 10 en base 10.</p> <p>Pour r\u00e9aliser ce compl\u00e9ment \u00e0 deux (compl\u00e9ment \u00e0 un plus un), il y a deux \u00e9tapes\u2009:</p> <ol> <li>Calculer le compl\u00e9ment \u00e0 un du nombre d'entr\u00e9es.</li> <li>Ajouter 1 au r\u00e9sultat.</li> </ol> <p>Oui, et alors, en quoi cela change la donne\u2009? Surprenamment, on r\u00e9sout tous les probl\u00e8mes amen\u00e9s par le compl\u00e9ment \u00e0 un\u2009:</p> <pre><code>000   001   010   011   100   101   110   111\n\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500&gt;\n 0     1     2     3     4     5     6     7     sans compl\u00e9ment\n 0     1     2     3    -3    -2    -1     0     compl\u00e9ment \u00e0 un\n 0     1     2     3    -4    -3    -2    -1     compl\u00e9ment \u00e0 deux\n</code></pre> <p>Au niveau du calcul\u2009:</p> <pre><code>  2        00000010\n- 5      + 11111011   (~0b101 + 1 == 0b11111011)\n---     -----------\n -3        11111101   (~0b11111101 + 1 == 0b11 == 3)\n</code></pre> <p>Les avantages\u2009:</p> <ol> <li>Les op\u00e9rations sont triviales.</li> <li>Le probl\u00e8me du double z\u00e9ro est r\u00e9solu.</li> <li>On gagne une valeur n\u00e9gative <code>[-128..+127]</code> contre <code>[-127..+127]</code> avec les m\u00e9thodes pr\u00e9c\u00e9demment \u00e9tudi\u00e9es.</li> </ol> <p>Vous l'aurez compris, le compl\u00e9ment \u00e0 deux est le m\u00e9canisme le plus utilis\u00e9 dans les ordinateurs modernes pour repr\u00e9senter les nombres entiers n\u00e9gatifs.</p>", "tags": ["complement-a-deux"]}, {"location": "course-c/10-numeration/numbers/#les-nombres-reels", "title": "Les nombres r\u00e9els", "text": "<p>Math\u00e9matiquement, les nombres r\u00e9els \\(\\mathbb{R}\\), sont des nombres qui peuvent \u00eatre repr\u00e9sent\u00e9s par une partie enti\u00e8re, et une liste finie ou infinie de d\u00e9cimales. En informatique, stocker une liste infinie de d\u00e9cimale demanderait une quantit\u00e9 infinie de m\u00e9moire et donc, la pr\u00e9cision arithm\u00e9tique est contrainte.</p> <p>Au d\u00e9but de l'\u00e8re des ordinateurs, il n'\u00e9tait possible de stocker que des nombres entiers, mais le besoin de pouvoir stocker des nombres r\u00e9els s'est rapidement fait sentir. La transition s'est faite progressivement, d'abord par l'apparition de la virgule fixe, puis par la virgule flottante.</p> <p>Le premier ordinateur avec une capacit\u00e9 de calcul en virgule flottante date de 1942 (ni vous ni moi n'\u00e9tions probablement n\u00e9s) avec le Zuse's Z4, du nom de son inventeur Konrad Zuse.</p>"}, {"location": "course-c/10-numeration/numbers/#virgule-fixe", "title": "Virgule fixe", "text": "<p>Prenons l'exemple d'un nombre entier exprim\u00e9 sur 8-bits, on peut admettre facilement que bien qu'il s'agisse d'un nombre entier, une virgule pourrait \u00eatre ajout\u00e9e au bit z\u00e9ro sans en modifier sa signification.</p> <pre><code>\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\n\u25020\u25021\u25020\u25021\u25020\u25020\u25021\u25021\u2502 = 2^6 + 2^4 + 2^1 + 2^0 = 64 + 16 + 2 + 1 = 83\n\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n                , / 2^0     ----&gt; 83 / 1 = 83\n</code></pre> <p>Imaginons \u00e0 pr\u00e9sent que nous d\u00e9placions cette virgule virtuelle de trois \u00e9l\u00e9ments sur la gauche. En admettant que deux ing\u00e9nieurs se mettent d'accord pour consid\u00e9rer ce nombre <code>0b01010011</code> avec une virgule fixe positionn\u00e9e au quatri\u00e8me bit, l'interpr\u00e9tation de cette grandeur serait alors la valeur enti\u00e8re divis\u00e9e par 8 (\\(2^3\\)). On parvient alors \u00e0 exprimer une grandeur r\u00e9elle comportant une partie d\u00e9cimale\u2009:</p> <pre><code>\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\n\u25020\u25021\u25020\u25021\u25020\u25020\u25021\u25021\u2502 = 2\u2076 + 2\u2074 + 2\u00b9 + 2\u2070 = 64 + 16 + 2 + 1 = 83\n\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n          ,       / 2\u00b3     ----&gt; 83 / 8 = 10.375\n</code></pre> <p>Cependant, il manque une information. Un ordinateur, sans yeux et sans bon sens, est incapable sans information additionnelle d'interpr\u00e9ter correctement la position de la virgule puisque sa position n'est encod\u00e9e nulle part. Et puisque la position de cette virgule est dans l'intervalle <code>[0..7]</code>, il serait possible d'utiliser trois bits suppl\u00e9mentaires \u00e0 cette fin\u2009:</p> <pre><code>\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\n\u25020\u25021\u25020\u25021\u25020\u25020\u25021\u25021\u2502 = 2\u2076 + 2\u2074 + 2\u00b9 + 2\u2070 = 64 + 16 + 2 + 1 = 83\n\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n          \u250c\u2500\u252c\u2500\u252c\u2500\u2510\n          \u25020\u25021\u25021\u2502 / 2\u00b3     ----&gt; 83 / 8 = 10.375\n          \u2514\u2500\u2534\u2500\u2534\u2500\u2518\n</code></pre> <p>Cette solution est \u00e9l\u00e9gante, mais demande \u00e0 pr\u00e9sent 11-bits contre 8-bits initialement. Un ordinateur n'\u00e9tant dou\u00e9 que pour manipuler des paquets de bits souvent sup\u00e9rieurs \u00e0 8, il faudrait ici soit \u00e9tendre inutilement le nombre de bits utilis\u00e9s pour la position de la virgule \u00e0 8, soit tenter d'int\u00e9grer cette information, dans les 8-bits initiaux.</p>", "tags": ["virgule-fixe"]}, {"location": "course-c/10-numeration/numbers/#virgule-flottante", "title": "Virgule flottante", "text": "<p>Imaginons alors que l'on sacrifie 3 bits sur les 8 pour encoder l'information de la position de la virgule. Appelons l'espace r\u00e9serv\u00e9 pour positionner la virgule l' exposant et le reste de l'information la mantisse, qui en math\u00e9matique repr\u00e9sente la partie d\u00e9cimale d'un logarithme (\u00e0 ne pas confondre avec la mantis shrimp, une quille ou crevette-mante boxeuse aux couleurs particuli\u00e8rement chatoyantes). </p> <pre><code>  exp.  mantisse\n\u251e\u2500\u252c\u2500\u252c\u2500\u2540\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2526\n\u25020\u25021\u25020\u25021\u25020\u25020\u25021\u25021\u2502 = 2\u2074 + 2\u00b9 + 2\u2070 = 16 + 2 + 1 = 19\n\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500&gt; / 2\u00b9 ----&gt; 19 / 2 = 9.5\n</code></pre> <p>Notre construction nous permet toujours d'exprimer des grandeurs r\u00e9elles, mais avec ce sacrifice, il n'est maintenant plus possible d'exprimer que les grandeurs comprises entre \\(1\\cdot2^{7}=0.0078125\\) et \\(63\\). Ce probl\u00e8me peut \u00eatre ais\u00e9ment r\u00e9solu en augmentant la profondeur m\u00e9moire \u00e0 16 ou 32-bits. Ajoutons par ailleurs que cette solution n'est pas \u00e0 m\u00eame d'exprimer des grandeurs n\u00e9gatives.</p> <p>Derni\u00e8re it\u00e9ration, choisissons d'\u00e9tendre notre espace de stockage \u00e0 ,4 octets. R\u00e9servons un bit de signe pour exprimer les grandeurs n\u00e9gatives, 8 bits pour l'exposant et 23 bits pour la mantisse\u2009:</p> <pre><code> \u250c Signe 1 bit\n \u2502        \u250c Exposant 8 bits\n \u2502        \u2502                             \u250c Mantisse 23 bits\n \u2534 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u251e\u2500\u2540\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\u250c\u2500\u2540\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2526\n\u25020\u25020\u25020\u25021\u25020\u25020\u25020\u25020\u2502\u25020\u25021\u25020\u25020\u25021\u25020\u25020\u25020\u2502\u25021\u25021\u25020\u25021\u25021\u25021\u25021\u25021\u2502\u25020\u25021\u25020\u25020\u25020\u25020\u25020\u25021\u2502\n\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n</code></pre> <p>Peu \u00e0 peu, nous nous rapprochons du Standard for Floating-Point Arithmetic (IEEE 754). La formule de base est la suivante\u2009:</p> \\[ x = s\\cdot b^e\\sum_{k=1}^p f_k\\cdot b^{-k},\\; e_{\\text{min}} \\le e \\le e_{\\text{max}} \\] <p>Avec\u2009:</p> \\(s\\) <p>Signe (\\(\\pm1\\))</p> \\(b\\) <p>Base de l'exposant, un entier \\(&gt;1\\).</p> \\(e\\) <p>Exposant, un entier entre \\(e_\\text{min}\\) et \\(e_\\text{max}\\)</p> \\(p\\) <p>Pr\u00e9cision, nombre de digits en base \\(b\\) de la mantisse</p> \\(f_k\\) <p>Entier non n\u00e9gatif plus petit que la base \\(b\\).</p> <p>\u00c9tant donn\u00e9 que les ordinateurs sont plus \u00e0 l'aise \u00e0 la manipulation d'entr\u00e9es binaire, la base est 2 et la norme IEEE nomme ces nombres <code>binary16</code>, <code>binary32</code> ou <code>binary64</code>, selon le nombre de bits utilis\u00e9 pour coder l'information. Les termes de Single precision ou Double precision sont aussi couramment utilis\u00e9s.  </p> <p>Les formats support\u00e9 par un ordinateur ou qu'un microcontr\u00f4leur \u00e9quip\u00e9 d'une unit\u00e9 de calcul en virgule flottante (FPU pour Floating point unit) sont les suivants\u2009:</p>  Formats de nombres en virgule flottante IEEE-754 Exposant Mantisse Signe <code>binary32</code> 8 bits 23 bits 1 bit <code>binary64</code> 11 bits 52 bits 1 bit <p>Prenons le temps de faire quelques observations\u2009:</p> <ul> <li>Une valeur encod\u00e9e en virgule flottante sera toujours une approximation d'une grandeur r\u00e9elle.</li> <li>La pr\u00e9cision est d'autant plus grande que le nombre de bits de la mantisse est grand.</li> <li>La base ayant \u00e9t\u00e9 fix\u00e9e \u00e0 2, il est possible d'exprimer \\(1/1024\\) sans erreur de pr\u00e9cision, mais pas \\(1/1000\\).</li> <li>Un ordinateur qui n'est pas \u00e9quip\u00e9 d'une FPU sera beaucoup plus lent (10 \u00e0 100x) pour faire des calculs en virgule flottante.</li> <li>Bien que le standard C99 d\u00e9finisse les types virgule flottante <code>float</code>, <code>double</code> et <code>long double</code>, ils ne d\u00e9finissent pas la pr\u00e9cision avec laquelle ces nombres sont exprim\u00e9s, car cela d\u00e9pend de l'architecture du processeur utilis\u00e9.  </li> </ul>"}, {"location": "course-c/10-numeration/numbers/#simple-precision", "title": "Simple pr\u00e9cision", "text": "<p>Le type <code>float</code> aussi dit \u00e0 pr\u00e9cision simple utilise un espace de stockage de 32-bits organis\u00e9 en 1 bit de signe, 8 bits pour l'exposant et 23 bits pour la mantisse. Les valeurs pouvant \u00eatre exprim\u00e9es sont de\u2009:</p> <ul> <li>\\(\\pm\\inf\\) lorsque l'exposant vaut <code>0xff</code></li> <li>\\((-1)^{\\text{sign}}\\cdot2^{\\text{exp} - 127}\\cdot1.\\text{significand}\\)</li> <li>\\(0\\) lorsque la mantisse vaut <code>0x00000</code></li> </ul> <p>La valeur de 1.0 est encod\u00e9e\u2009:</p> \\[ \\begin{aligned} 0\\:01111111\\:00000000000000000000000_2 &amp;= \\text{3f80}\\: \\text{0000}_{16} \\\\ &amp;= (-1)^0 \\cdot 2^{127-127} \\cdot \\frac{(2^{23} + 0)}{2^{23}} \\\\ &amp;= 2^{0} \\cdot 1.0 = 1.0 \\end{aligned} \\] <p>La valeur maximale exprimable\u2009:</p> \\[ \\begin{aligned} 0\\:11111110\\:11111111111111111111111_2 &amp;= \\text{7f7f}\\: \\text{ffff}_{16} \\\\ &amp;= (-1)^0 \\cdot 2^{254-127} \\cdot \\frac{(2^{23} + 838'607)}{2^{23}} \\\\ &amp;\u2248 2^{127} \\cdot 1.9999998807 \\\\ &amp;\u2248 3.4028234664 \\cdot 10^{38} \\end{aligned} \\] <p>La valeur de \\(-\\pi\\) (pi) est\u2009:</p> \\[ \\begin{aligned} 1\\:10000000\\:10010010000111111011011_2 &amp;= \\text{4049}\\: \\text{0fdb}_{16} \\\\ &amp;= (-1)^1 \\cdot 2^{128-127} \\cdot \\frac{(2^{23} + 4'788'187)}{2^{23}} \\\\ &amp;\u2248 -1 \\cdot 2^{1} \\cdot 1.5707963 \\\\ &amp;\u2248 -3.14159274101 \\end{aligned} \\] <p>Vient s'ajouter les valeurs particuli\u00e8res suivantes\u2009:</p> <pre><code>0 00000000 00000000000000000000000\u2082 \u2261 0000 0000\u2081\u2086 \u2261 0\n0 11111111 00000000000000000000000\u2082 \u2261 7f80 0000\u2081\u2086 \u2261 inf\n1 11111111 00000000000000000000000\u2082 \u2261 ff80 0000\u2081\u2086 \u2261 \u2212inf\n</code></pre> <p>D\u00e9passement de capacit\u00e9</p> <p>Il ne faut pas oublier que la repr\u00e9sentation des nombres en virgule flottante n'est pas exacte. Il est possible de d\u00e9passer la capacit\u00e9 de stockage d'un nombre en virgule flottante. La pr\u00e9cision maximale d'un nombre en virgule flottante d\u00e9pend de sa mantisse.</p> <p>Par exemple si l'on souhaite r\u00e9aliser un int\u00e9grateur simple, nous disposons d'un compteur <code>u</code> initialis\u00e9 \u00e0 1.0. \u00c0 chaque it\u00e9ration, on incr\u00e9mente <code>u</code> de 1.0. Lorsque la valeur cesse de cro\u00eetre, on affiche la valeur de <code>u</code>.</p> <pre><code>#include &lt;stdio.h&gt;\nint main() {\n    float u = 1.0, v;\n    do { v = u++; } while (u &gt; v);\n    printf(\"%f\\n\", u);\n}\n</code></pre> <p>Vous pourriez vous attendre \u00e0 ce que le programme tourne \u00e0 l'infini, o\u00f9 du moins jusqu'\u00e0 une limite tr\u00e8s grande, mais en r\u00e9alit\u00e9, il s'arr\u00eate \u00e0 16777216.0. C'est parce que la pr\u00e9cision de la mantisse est de 23 bits, et que le nombre 16777217.0 est le premier nombre entier qui ne peut pas \u00eatre repr\u00e9sent\u00e9 avec une pr\u00e9cision de 23 bits.</p> <p>Les nombres subnormaux</p> <p>On l'a vu un nombre en virgule flottante simple pr\u00e9cision s'\u00e9crit sous la forme\u2009:</p> \\[ (-1)^s \\times (1.m) \\times 2^{(e - Bias)} \\] <p>Les nombres subnormaux sont des nombres qui ne respectent pas la norme IEEE 754, mais qui sont tout de m\u00eame repr\u00e9sentables. Ils sont utilis\u00e9s pour repr\u00e9senter des nombres tr\u00e8s petits, proches de z\u00e9ro. En effet, la norme IEEE 754 impose que le premier bit de la mantisse soit toujours \u00e9gal \u00e0 1, ce qui implique que le nombre 0 ne peut pas \u00eatre repr\u00e9sent\u00e9. Les nombres subnormaux permettent de repr\u00e9senter des nombres tr\u00e8s proches de z\u00e9ro, en diminuant la pr\u00e9cision de la mantisse.</p>"}, {"location": "course-c/10-numeration/numbers/#double-precision", "title": "Double pr\u00e9cision", "text": "<p>La double pr\u00e9cision est similaire \u00e0 la simple pr\u00e9cision, mais avec une mantisse \u00e0 52 bits et 11 bits d'exposants.</p> <p>Exercise\u2009: Expressions arithm\u00e9tiques flottantes</p> <p>Donnez la valeur des expressions ci-dessous\u2009:</p> <pre><code>25. + 10. + 7. \u2013 3.\n5. / 2.\n24. + 5. / 2.\n25. / 5. / 2.\n25. / (5. / 2.)\n2. * 13. % 7.\n1.3E30 + 1.\n</code></pre>"}, {"location": "course-c/10-numeration/numbers/#quadruple-precision", "title": "Quadruple pr\u00e9cision", "text": "<p>Bien que ce soit marginal dans le monde de l'informatique, la quadruple pr\u00e9cision est une norme IEEE 754 qui utilise 128 bits pour stocker les nombres r\u00e9els. Elle est utilis\u00e9e pour des calculs scientifiques n\u00e9cessitant une tr\u00e8s grande pr\u00e9cision comme au CERN ou pour l'\u00e9tude de mod\u00e8les cosmologiques.</p> <p>La quadruple pr\u00e9cision offre une pr\u00e9cision de 34 chiffres significatifs, soit environ 112 bits de pr\u00e9cision. Elle est cod\u00e9e sur 128 bits.</p> <p>Il est possible de l'utiliser avec certains compilateurs C comme GCC en utilisant le type <code>__float128</code> de la biblioth\u00e8que <code>&lt;quadmath.h&gt;</code>.</p> <p>Avertissement</p> <p>Son utilisation ralenti consid\u00e9rablement les calculs, car les processeurs actuels ne sont pas optimis\u00e9s pour ce type de calculs. Un processeur peut faire des calculs sur 64 bits en une seule op\u00e9ration, mais pour des calculs en quadruple pr\u00e9cision, il doit faire plusieurs op\u00e9rations pour chaque chiffre.</p>", "tags": ["cern", "quadruple-precision"]}, {"location": "course-c/10-numeration/numbers/#nombres-complexes", "title": "Nombres complexes", "text": "<p>En C, il est possible de d\u00e9finir des nombres complexes en utilisant le type <code>complex</code> de la biblioth\u00e8que <code>&lt;complex.h&gt;</code>. Les nombres complexes sont compos\u00e9s de deux parties, la partie r\u00e9elle et la partie imaginaire. Ils sont souvent utilis\u00e9s en math\u00e9matiques pour repr\u00e9senter des nombres qui ne peuvent pas \u00eatre exprim\u00e9s avec des nombres r\u00e9els. Ils ont \u00e9t\u00e9 introduits avec la version C99 du langage C.</p> <p>N\u00e9anmoins les nombres complexes ne sont pas support\u00e9s par les op\u00e9rateurs du langage, il est n\u00e9cessaire d'utiliser des fonctions sp\u00e9cifiques pour effectuer des op\u00e9rations sur les nombres complexes.</p> <p>Note</p> <p>Dans des langages plus haut niveau comme le C++, le C# ou Python, les nombres complexes sont support\u00e9s nativement.</p> <p>Exemple en Python\u2009:</p> <pre><code>from math import sqrt\na, b, c = 1, 2, 3\ndelta = b**2 - 4*a*c # Calcul du discriminant qui sera n\u00e9gatif\nx1, x1 = (-b + sqrt(delta)) / (2*a), (-b - sqrt(delta)) / (2*a)\n</code></pre> <p><code>x1</code> et <code>x2</code> sont des nombres complexes.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;complex.h&gt;\n\nint main() {\n    double complex z1 = 1.0 + 2.0*I;\n    double complex z2 = 3.0 + 4.0*I;\n\n    printf(\"z1 = %.1f + %.1fi\\n\", creal(z1), cimag(z1));\n    printf(\"z2 = %.1f + %.1fi\\n\", creal(z2), cimag(z2));\n\n    double complex sum = z1 + z2;\n    double complex product = z1 * z2;\n\n    printf(\"sum = %.1f + %.1fi\\n\", creal(sum), cimag(sum));\n    printf(\"product = %.1f + %.1fi\\n\", creal(product), cimag(product));\n\n    return 0;\n}\n</code></pre>"}, {"location": "course-c/10-numeration/numbers/#format-q-virgule-fixe", "title": "Format Q (virgule fixe)", "text": "<p>Le format Q est une notation en virgule fixe dans laquelle le format d'un nombre est repr\u00e9sent\u00e9 par la lettre Q suivie de deux nombres\u2009:</p> <ol> <li>Le nombre de bits entiers</li> <li>Le nombre de bits fractionnaires</li> </ol> <p>Ainsi, un registre 16 bits contenant un nombre allant de +0.999 \u00e0 -1.0 s'exprimera Q1.15 soit 1 + 15 valant 16 bits.</p> <p>Pour exprimer la valeur pi (3.1415...) il faudra au minimum 3 bits pour repr\u00e9senter la partie enti\u00e8re, car le bit de signe doit rester \u00e0 z\u00e9ro. Le format sur 16 bits sera ainsi Q4.12.</p> <p>La construction de ce nombre est facile\u2009:</p> <ol> <li>Prendre le nombre r\u00e9el</li> <li>Le multiplier par 2 \u00e0 la puissance du nombre de bits</li> <li>Prendre la partie enti\u00e8re</li> </ol> <pre><code>1.    3.1415926535\n2.    2**12 * 3.1415926535 = 12867.963508736\n3.    12867\n</code></pre> <p>Pour convertir un nombre Q4.12 en sa valeur r\u00e9elle il faut\u2009:</p> <ol> <li>Prendre le nombre encod\u00e9 en Q4.12</li> <li>Diviser sa valeur 2 \u00e0 la puissance du nombre de bits</li> </ol> <pre><code>1.    12867\n2.    12867 / 2**12 = 3.141357421875\n</code></pre> <p>On note une perte de pr\u00e9cision puisqu'il n'est pas possible d'encoder un tel nombre dans seulement 16 bits. L'incr\u00e9ment positif minimal serait\u2009: \\(1 / 2^12 = 0.00024\\). Il convient alors d'arrondir le nombre \u00e0 la troisi\u00e8me d\u00e9cimale, soit 3.141.</p> <p>Les op\u00e9rations arithm\u00e9tiques sont possibles facilement entre des nombres de m\u00eames types. Le chapitre sur les algorithmes d\u00e9crit une impl\u00e9mentation de calcul de sinus en utilisant ce format.</p>", "tags": ["virgule-fixe"]}, {"location": "course-c/10-numeration/numbers/#addition", "title": "Addition", "text": "<p>L'addition peut se faire avec ou sans saturation\u2009:</p> <pre><code>typedef int16_t Q;\ntypedef Q Q12;\n\nQ q_add(Q a, Q b) {\n    return a + b;\n}\n\nQ q_add_sat(Q a, Q b) {\n    int32_t res = (int32_t)a + (int32_t)b;\n    res = res &gt; 0x7FFF ? 0x7FFF : res\n    res = res &lt; -1 * 0x8000 ? -1 * 0x8000 : res;\n    return (Q)res;\n}\n</code></pre>"}, {"location": "course-c/10-numeration/numbers/#multiplication", "title": "Multiplication", "text": "<p>Soit deux nombres 0.9 et 3.141\u2009:</p> <pre><code>\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2540\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2526\n\u25020\u25020\u25020\u25020\u25021\u25021\u25021\u25020\u2502\u25020\u25021\u25021\u25020\u25020\u25021\u25021\u25020\u2502 Q4.12 (0.9) 3686\n\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n\n\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2540\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2526\n\u25020\u25020\u25021\u25021\u25020\u25020\u25021\u25020\u2502\u25020\u25021\u25020\u25020\u25020\u25020\u25021\u25021\u2502 Q4.12 (3.141) 12867\n\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n</code></pre> <p>Multiplier ces deux valeurs revient \u00e0 une multiplication sur 2 fois la taille. Le r\u00e9sultat doit \u00eatre obtenu sur 32-bits sachant que les nombres Q s'additionnent comme Q4.12 x Q4.12 donnera Q8.24.</p> <p>On voit imm\u00e9diatement que la partie enti\u00e8re vaut 2, donc 90% de 3.14 donnera une valeur en dessous de 3. Pour reconstruire une valeur Q8.8 il convient de supprimer les 16-bits de poids faible.</p> <pre><code>3686 * 12867 = 47227762\n\n\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2526\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2526\n\u25020\u25020\u25020\u25020\u25020\u25020\u25021\u25020\u2502\u25021\u25021\u25020\u25021\u25020\u25020\u25020\u25020\u2502\u25021\u25020\u25021\u25020\u25020\u25020\u25021\u25021\u2502\u25020\u25021\u25021\u25021\u25020\u25020\u25021\u25020\u2502 Q8.24\n\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n\n\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2526\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2526\n\u25020\u25020\u25020\u25020\u25020\u25020\u25021\u25020\u2502\u25021\u25021\u25020\u25021\u25020\u25020\u25020\u25020\u2502 Q8.8\n\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n</code></pre> <pre><code>inline Q q_sat(int32_t x) {\n    x = x &gt; 0x7FFF ? 0x7FFF : x\n    x = x &lt; -1 * 0x8000 ? -1 * 0x8000 : x;\n    return (Q)x;\n}\n\ninline int16_t q_mul(int16_t a, int16_t b, char q)\n{\n    int32_t c = (int32_t)a * (int32_t)b;\n    c += 1 &lt;&lt; (q - 1);\n    return sat(c &gt;&gt; q);\n}\n\ninline int16_t q12_mul(int16_t a, int16_t b)\n{\n    return q_mul(a, b, 12);\n}\n</code></pre>"}, {"location": "course-c/15-fundations/control-structures/", "title": "Structures de contr\u00f4le", "text": "<p>Les structures de contr\u00f4le appartiennent aux langages de programmation \u00e9tant de paradigme imp\u00e9ratif et structur\u00e9.</p> <p>Elles permettent de modifier l'ordre des op\u00e9rations lors de l'ex\u00e9cution du code. On peut citer les cat\u00e9gories suivantes\u2009:</p> <ul> <li> <p>Les s\u00e9quences</p> <ul> <li>Les s\u00e9quences de code (<code>;</code>)</li> <li>Les blocs de code (<code>{}</code>)</li> <li>Les points de s\u00e9quences</li> </ul> </li> <li> <p>Les sauts (<code>jumps</code>)</p> <ul> <li>Conditionnels (<code>if</code>, <code>switch</code>)</li> <li>Inconditionnels (<code>break</code>, <code>continue</code>, <code>goto</code>, <code>return</code>)</li> </ul> </li> <li> <p>Les boucles (<code>loops</code>)</p> <ul> <li>Boucle it\u00e9rative sur une valeur connue <code>for</code></li> <li>Boucle sur condition <code>while</code></li> <li>Boucle sur condition avec test \u00e0 la fin <code>do</code>...<code>while</code></li> </ul> </li> </ul> <p>Sans structure de contr\u00f4le, un programme se comportera toujours de la m\u00eame mani\u00e8re et ne pourra pas \u00eatre sensible \u00e0 des \u00e9v\u00e8nements ext\u00e9rieurs puisque le flux d'ex\u00e9cution ne pourra pas \u00eatre modifi\u00e9 conditionnellement.</p> <p>L'intelligence d'un programme r\u00e9side dans sa capacit\u00e9 \u00e0 prendre des d\u00e9cisions en fonction de l'\u00e9tat du syst\u00e8me et des donn\u00e9es qu'il manipule. Les structures de contr\u00f4le permettent de d\u00e9finir ces d\u00e9cisions, un peu comme un livre dont vous \u00eates le h\u00e9ros o\u00f9 chaque choix vous m\u00e8ne \u00e0 une page diff\u00e9rente par un saut.</p>"}, {"location": "course-c/15-fundations/control-structures/#sequences", "title": "S\u00e9quences", "text": ""}, {"location": "course-c/15-fundations/control-structures/#sequences-de-code", "title": "S\u00e9quences de code", "text": "<p>En C, chaque instruction est s\u00e9par\u00e9e de la suivante par un point-virgule <code>;</code> 003B. On appelle ce caract\u00e8re le d\u00e9limiteur d'instruction.</p> <pre><code>k = 8; k *= 2;\n</code></pre> <p>Ceci permet d'\u00e9crire un programme sur une seule ligne (sauf concernant les directives pr\u00e9processeur), mais il est g\u00e9n\u00e9ralement pr\u00e9f\u00e9rable de s\u00e9parer les instructions sur plusieurs lignes pour am\u00e9liorer la lisibilit\u00e9 du code.</p> <pre><code>#include &lt;stdio.h&gt;\nint main() { char hello[] = \"hello\"; printf(\"%s, world\", hello); return 42; }\n</code></pre> <p>Certaines instructions n\u00e9cessitent un d\u00e9limiteur pour \u00eatre correctement interpr\u00e9t\u00e9es par le compilateur. Par exemple le <code>do...while</code> doit \u00eatre termin\u00e9 par un point-virgule\u2009:</p> <pre><code>do {\n    printf(\"Hello, world\\n\");\n} while (0); // &lt;== point virgule obligatoire\n</code></pre> <p>Le point-virgule grec</p> <p>N'allez pas confondre le point virgule <code>;</code> (003B) avec le <code>\u037e</code> (037E), le point d'interrogation grec (\u03b5\u03c1\u03c9\u03c4\u03b7\u03bc\u03b1\u03c4\u03b9\u03ba\u03cc). Certains farceurs aiment \u00e0 le remplacer dans le code de camarades ce qui g\u00e9n\u00e8re naturellement des erreurs de compilation.</p> <p></p>"}, {"location": "course-c/15-fundations/control-structures/#sequences-de-bloc", "title": "S\u00e9quences de bloc", "text": "<p>Une s\u00e9quence bloc est une suite d'instructions regroup\u00e9es en un bloc mat\u00e9rialis\u00e9 par des accolades <code>{}</code>:</p> <pre><code>{\n    double pi = 3.14;\n    area = pi * radius * radius;\n}\n</code></pre> <p>Il est possible d'ajouter autant de blocs que vous voulez, mais il est recommand\u00e9 de ne pas imbriquer les blocs de mani\u00e8re excessive. Un bloc est une unit\u00e9 de code qui peut \u00eatre trait\u00e9e comme une seule instruction. Il est possible de d\u00e9clarer des variables locales dans un bloc, ces variables n'\u00e9tant accessibles que dans le bloc o\u00f9 elles sont d\u00e9clar\u00e9es.</p> <pre><code>{\n    int a = 1;\n    {\n        int b = 2;\n        {\n            int c = 3;\n        }\n        // c n'est pas accessible ici\n    }\n    // b et c ne sont pas accessibles ici\n}\n// a, b et c ne sont pas accessibles ici\n</code></pre> <p>Limites de profondeur</p> <p>Le standard C99 \u00a75.2.4.1 impose qu'un compilateur C doit supporter au moins 127 niveaux d'imbrication de blocs, ce qui est emplement suffisant. Cette valeur n'a pas \u00e9t\u00e9 introduite par hasard, 127 est la valeur maximale d'un entier sign\u00e9 sur 8 bits (<code>char</code>) et les ordinateurs ne savent pas manipuler efficacement des types de donn\u00e9es plus petits.</p> <p>Ceci \u00e9tant, le nombre d'imbrication de structures conditionnelles est limit\u00e9 \u00e0 63, ce qui est d\u00e9j\u00e0 beaucoup trop. Si vous avez besoin de plus de 63 niveaux d'imbrication, il est temps de revoir votre conception\u2009!</p> <p></p>"}, {"location": "course-c/15-fundations/control-structures/#point-de-sequence", "title": "Point de s\u00e9quence", "text": "<p>On appelle un point de s\u00e9quence ou sequence point d\u00e9crite dans l'annexe du standard C que certains ordres d'\u00e9valuation sont garantis.</p> <p>Les r\u00e8gles sont les suivantes\u2009:</p> <ol> <li>l'appel d'une fonction est effectu\u00e9 apr\u00e8s que tous ses arguments ont \u00e9t\u00e9 \u00e9valu\u00e9s\u2009;</li> <li>la fin du premier op\u00e9rande dans les op\u00e9rations <code>&amp;&amp;</code>, <code>||</code>, <code>?</code> et <code>,</code> qui permet de court-circuiter le calcul dans <code>a() &amp;&amp; b()</code>. La condition <code>b()</code> n'est jamais \u00e9valu\u00e9e si la condition <code>a()</code> est valide\u2009;</li> <li>avant et apr\u00e8s des actions associ\u00e9es \u00e0 un formatage d'entr\u00e9e sortie.</li> </ol> <p>L'op\u00e9rateur d'assignation <code>=</code> n'est donc pas un point de s\u00e9quence et l'ex\u00e9cution du code <code>(a = 2) + a + (a = 2)</code> est par cons\u00e9quent ind\u00e9termin\u00e9e.</p> <p></p>"}, {"location": "course-c/15-fundations/control-structures/#les-sauts-conditionnels", "title": "Les sauts conditionnels", "text": "<p>Les embranchements sont des instructions de prise de d\u00e9cision. Une prise de d\u00e9cision est binaire lorsqu'il y a un choix vrai et un choix faux, ou multiple lorsque la condition est scalaire. En C il y en a deux types d'embranchements\u2009:</p> <ol> <li><code>if</code>, <code>if else</code></li> <li><code>switch</code></li> </ol> <p>On peut repr\u00e9senter ces embranchements par des diagrammes de flux BPMN (Business Process Modelling Notation) ou des structogrammes NSD (Nassi-Shneiderman):</p> <p> Diagrammes BPMN</p> <p>Les embranchements s'appuient naturellement sur les s\u00e9quences puisque chaque branche est compos\u00e9e d'une s\u00e9quence.</p> <p></p>"}, {"location": "course-c/15-fundations/control-structures/#if_1", "title": "<code>if</code>", "text": "<p>L'instruction <code>if</code> traduite par si est la plus utilis\u00e9e. L'exemple suivant illustre un embranchement binaire. Il affiche <code>odd</code> si le nombre est impair et <code>even</code> s'il est pair\u2009:</p> <pre><code>if (value % 2)\n{\n    printf(\"odd\\n\");\n}\nelse\n{\n    printf(\"even\\n\");\n}\n</code></pre> <p>Notons que les blocs sont facultatifs. L'instruction <code>if</code> s'attend \u00e0 une seule instruction, mais il est possible de regrouper plusieurs instructions dans un bloc <code>{}</code>. Il est recommand\u00e9 de toujours utiliser les blocs pour \u00e9viter les erreurs de logique. N\u00e9anmoins le code suivant est valide\u2009:</p> <pre><code>if (value % 2)\n    printf(\"odd\\n\");\nelse\n    printf(\"even\\n\");\n</code></pre> <p>De m\u00eame que comme des <code>;</code> s\u00e9parent les instructions, on peut aussi \u00e9crire\u2009:</p> <pre><code>if (value % 2) printf(\"odd\\n\"); else printf(\"even\\n\");\n</code></pre> <p>Info</p> <p>Dans ce cas pr\u00e9cis, l'instruction ternaire est plus \u00e9l\u00e9gante\u2009:</p> <pre><code>printf(\"%s\\n\", value % 2 ? \"odd\" : \"even\");\n</code></pre> <p>Le mot cl\u00e9 <code>else</code> est facultatif. Si l'on ne souhaite pas ex\u00e9cuter d'instruction lorsque la condition est fausse, il est possible de ne pas le sp\u00e9cifier.</p> <pre><code>int a = 42;\nint b = 0;\n\nif (b == 0) {\n    printf(\"Division par z\u00e9ro impossible\\n\");\n    exit(EXIT_FAILURE);\n}\n\nprintf(\"a / b = %d\\n\", a / b);\n</code></pre> <p>En C il n'y a pas d'instruction <code>if..else if</code> comme on peut le trouver dans d'autres langages de programmation (p. ex. Python). Faire suivre une sous condition \u00e0 <code>else</code> est n\u00e9anmoins possible puisque <code>if</code> est une instruction comme une autre la preuve est donn\u00e9e par la grammaire du langage\u2009:</p> <pre><code>selection_statement\n    : IF '(' expression ')' statement\n    | IF '(' expression ')' statement ELSE statement\n    | SWITCH '(' expression ')' statement\n    ;\n</code></pre> <p>On voit que <code>if</code> peut \u00eatre suivi d'un <code>statement</code> lequel peut \u00eatre suivi d'un <code>ELSE</code> et d'un autre <code>statement</code>. Ces deux <code>statement</code> peuvent par cons\u00e9quent \u00eatre un <code>selection_statement</code> et donc \u00eatre imbriqu\u00e9s.</p> <p>Voici un exemple d'imbriquement de conditions\u2009:</p> <pre><code>if (value &lt; 0) {\n    printf(\"La valeur est n\u00e9gative\\n\");\n}\nelse {\n    if (value == 0) {\n        printf(\"La valeur est nulle\\n\");\n    }\n    else {\n        printf(\"La valeur est positive\\n\");\n    }\n}\n</code></pre> <p>N\u00e9anmoins, comme il n'y a qu'une instruction <code>if</code> apr\u00e8s le premier <code>else</code>, le bloc peut \u00eatre omis. En outre, il est correct de faire figurer le <code>if</code> sur la m\u00eame ligne que le <code>else</code> :</p> <pre><code>if (value &lt; 0) {\n    printf(\"La valeur est n\u00e9gative\\n\");\n}\nelse if (value == 0) {\n    printf(\"La valeur est nulle\\n\");\n}\nelse {\n    printf(\"La valeur est positive\\n\");\n}\n</code></pre> <p>Une condition n'est pas n\u00e9cessairement unique, mais peut-\u00eatre la concat\u00e9nation logique de plusieurs conditions s\u00e9par\u00e9es\u2009:</p> <pre><code>if((0 &lt; x &amp;&amp; x &lt; 10) || (100 &lt; x &amp;&amp; x &lt; 110) || (200 &lt; x &amp;&amp; x &lt; 210))\n{\n    printf(\"La valeur %d est valide\", x);\n    is_valid = true;\n}\nelse\n{\n    printf(\"La valeur %d n'est pas valide\", x);\n    is_valid = false;\n}\n</code></pre> <p>Remarquons qu'au passage cet exemple peut \u00eatre simplifi\u00e9 pour diminuer la complexit\u00e9 cyclomatique :</p> <pre><code>is_valid = (0 &lt; x &amp;&amp; x &lt; 10) || (100 &lt; x &amp;&amp; x &lt; 110) || (200 &lt; x &amp;&amp; x &lt; 210);\n\nif (is_valid)\n{\n    printf(\"La valeur %d est valide\", x);\n}\nelse\n{\n    printf(\"La valeur %d n'est pas valide\", x);\n}\n</code></pre>"}, {"location": "course-c/15-fundations/control-structures/#point-virgule-en-trop", "title": "Point virgule en trop", "text": "<p>Il est courant de placer un point virgule derri\u00e8re un <code>if</code>. Le point virgule correspondant \u00e0 une instruction vide, c'est cette instruction qui sera ex\u00e9cut\u00e9e si la condition du test est vraie.</p> <pre><code>if (z == 0);\nprintf(\"z est nul\"); // ALWAYS executed\n</code></pre>"}, {"location": "course-c/15-fundations/control-structures/#affectation-dans-un-test", "title": "Affectation dans un test", "text": "<p>Le test de la valeur d'une variable s'\u00e9crit avec l'op\u00e9rateur d'\u00e9galit\u00e9 <code>==</code> et non l'op\u00e9rateur d'affectation <code>=</code>. Ici, l'\u00e9valuation de la condition vaut la valeur affect\u00e9e \u00e0 la variable.</p> <pre><code>if (z = 0)               // set z to zero !!\n    printf(\"z est nul\"); // NEVER executed\n</code></pre>"}, {"location": "course-c/15-fundations/control-structures/#loubli-des-accolades", "title": "L'oubli des accolades", "text": "<p>Dans le cas ou vous souhaitez ex\u00e9cuter plusieurs instructions, vous devez imp\u00e9rativement d\u00e9clarer un bloc d'instructions. Si vous omettez les accolades, seule la premi\u00e8re instruction sera ex\u00e9cut\u00e9e puisque la s\u00e9quence se termine par un point virgule ou un bloc.</p> <pre><code>if (z == 0)\n    printf(\"z est nul\");\n    is_valid = false;  // Ne fait par partie du bloc et s'ex\u00e9cute toujours\n</code></pre>"}, {"location": "course-c/15-fundations/control-structures/#exemple", "title": "Exemple", "text": "<p>On peut utiliser des conditions multiples pour d\u00e9terminer le comportement d'un programme. Par exemple, le programme suivant affiche un message diff\u00e9rent en fonction de la valeur de <code>value</code> :</p> <pre><code>if (value % 2)\n{\n    printf(\"La valeur est impaire.\");\n}\nelse if (value &gt; 500)\n{\n    printf(\"La valeur est paire et sup\u00e9rieure \u00e0 500.\");\n}\nelse if (!(value % 5))\n{\n    printf(\"La valeur est paire, inf\u00e9rieur \u00e0 500 et divisible par 5.\");\n}\nelse\n{\n    printf(\"La valeur ne satisfait aucune condition \u00e9tablie.\");\n}\n</code></pre> <p>Exercise\u2009: Et si\u2009?</p> <p>Comment se comporte l'exemple suivant\u2009:</p> <pre><code>if (!(i &lt; 8) &amp;&amp; !(i &gt; 8))\n    printf(\"i is %d\\n\", i);\n</code></pre> <p>Exercise\u2009: D'autres si\u2009?</p> <p>Compte tenu de la d\u00e9claration <code>int i = 8;</code>, indiquer pour chaque expression si elles impriment ou non <code>i vaut 8</code>:</p> <ol> <li> <p> </p><pre><code>if (!(i &lt; 8) &amp;&amp; !(i &gt; 8)) then\n    printf(\"i vaut 8\\n\");\n</code></pre> </li> <li> <p> </p><pre><code>if (!(i &lt; 8) &amp;&amp; !(i &gt; 8))\n    printf(\"i vaut 8\");\n    printf(\"\\n\");\n</code></pre> </li> <li> <p> </p><pre><code>if !(i &lt; 8) &amp;&amp; !(i &gt; 8)\n    printf(\"i vaut 8\\n\");\n</code></pre> </li> <li> <p> </p><pre><code>if (!(i &lt; 8) &amp;&amp; !(i &gt; 8))\n    printf(\"i vaut 8\\n\");\n</code></pre> </li> <li> <p> </p><pre><code>if (i = 8) printf(\"i vaut 8\\n\");\n</code></pre> </li> <li> <p> </p><pre><code>if (i &amp; (1 &lt;&lt; 3)) printf(\"i vaut 8\\n\");\n</code></pre> </li> <li> <p> </p><pre><code>if (i ^ 8) printf(\"i vaut 8\\n\");\n</code></pre> </li> <li> <p> </p><pre><code>if (i - 8) printf(\"i vaut 8\\n\");\n</code></pre> </li> <li> <p> </p><pre><code>if (i == 1 &lt;&lt; 3) printf (\"i vaut 8\\n\");\n</code></pre> </li> <li> <p> </p><pre><code>if (!((i &lt; 8) || (i &gt; 8)))\n    printf(\"i vaut 8\\n\");\n</code></pre> </li> </ol> <p></p>"}, {"location": "course-c/15-fundations/control-structures/#switch_1", "title": "<code>switch</code>", "text": "<p>L'instruction <code>switch</code> n'est pas fondamentale et certains langages de programmation comme Python ne la connaissaient pas. Elle permet essentiellement de simplifier l'\u00e9criture pour minimiser les r\u00e9p\u00e9titions. On l'utilise lorsque les conditions multiples portent toujours sur la m\u00eame variable. Par exemple, le code suivant peut \u00eatre r\u00e9\u00e9crit plus simplement en utilisant un <code>switch</code> :</p> <pre><code>if (defcon == 1)\n    printf(\"Guerre nucl\u00e9aire imminente\");\nelse if (defcon == 2)\n    printf(\"Prochaine \u00e9tape, guerre nucl\u00e9aire\");\nelse if (defcon == 3)\n    printf(\"Accroissement de la pr\u00e9paration des forces\");\nelse if (defcon == 4)\n    printf(\"Mesures de s\u00e9curit\u00e9 renforc\u00e9es et renseignements accrus\");\nelse if (defcon == 5\n    printf(\"Rien \u00e0 signaler, temps de paix\");\nelse\n    printf(\"ERREUR: Niveau d'alerte DEFCON invalide\");\n</code></pre> <p>Voici l'expression utilisant <code>switch</code>. Notez que chaque condition est plus claire\u2009:</p> <pre><code>switch (defcon)\n{\n    case 1 :\n        printf(\"Guerre nucl\u00e9aire imminente\");\n        break;\n    case 2 :\n        printf(\"Prochaine \u00e9tape, guerre nucl\u00e9aire\");\n        break;\n    case 3 :\n        printf(\"Accroissement de la pr\u00e9paration des forces\");\n        break;\n    case 4 :\n        printf(\"Mesures de s\u00e9curit\u00e9 renforc\u00e9es et renseignements accrus\");\n        break;\n    case 5 :\n        printf(\"Rien \u00e0 signaler, temps de paix\");\n        break;\n    default :\n        printf(\"ERREUR: Niveau d'alerte DEFCON invalide\");\n}\n</code></pre> <p>La valeur par d\u00e9faut <code>default</code> est optionnelle, mais recommand\u00e9e pour traiter les cas d'erreurs possibles.</p> <p>La structure d'un <code>switch</code> est compos\u00e9e d'une condition <code>switch (condition)</code> suivie d'une s\u00e9quence <code>{}</code>. Les instructions de cas <code>case 42:</code> sont appel\u00e9es labels. Notez la pr\u00e9sence de l'instruction <code>break</code> qui est n\u00e9cessaire pour terminer l'ex\u00e9cution de chaque condition. Par ailleurs, les labels peuvent \u00eatre cha\u00een\u00e9s sans instructions interm\u00e9diaires ni <code>break</code>:</p> <pre><code>switch (coffee)\n{\n    case IRISH_COFFEE :\n        add_whisky();\n\n    case CAPPUCCINO :\n    case MACCHIATO :\n        add_milk();\n\n    case ESPRESSO :\n    case AMERICANO :\n        add_coffee();\n        break;\n\n    default :\n        printf(\"ERREUR 418: Type de caf\u00e9 inconnu\");\n}\n</code></pre> <p>Notons quelques observations\u2009:</p> <ul> <li>La structure <code>switch</code> bien qu'elle puisse toujours \u00eatre remplac\u00e9e par une structure <code>if..else if</code> est g\u00e9n\u00e9ralement plus \u00e9l\u00e9gante et plus lisible. Elle \u00e9vite par ailleurs de r\u00e9p\u00e9ter la condition plusieurs fois (c.f. DRY).</li> <li>Le compilateur est mieux \u00e0 m\u00eame d'optimiser un choix multiple lorsque les valeurs scalaires de la condition tri\u00e9es se suivent directement p. ex. <code>{12, 13, 14, 15}</code>.</li> <li>L'ordre des cas d'un <code>switch</code> n'a pas d'importance, le compilateur peut m\u00eame choisir de r\u00e9ordonner les cas pour optimiser l'ex\u00e9cution.</li> </ul>"}, {"location": "course-c/15-fundations/control-structures/#les-boucles", "title": "Les boucles", "text": "<p> Bien choisir sa structure de contr\u00f4le</p> <p>Une boucle est une structure it\u00e9rative permettant de r\u00e9p\u00e9ter l'ex\u00e9cution d'une s\u00e9quence. En C il existe trois types de boucles\u2009:</p> <ol> <li><code>for</code></li> <li><code>while</code></li> <li><code>do</code> .. <code>while</code></li> </ol> <p>Elles peuvent \u00eatre repr\u00e9sent\u00e9es par les diagrammes de flux suivants\u2009:</p> <p> Aper\u00e7u des trois structures de boucles</p> <p>On observe que quelque soit la structure de boucle, une condition de maintien est n\u00e9cessaire. Cette condition est \u00e9valu\u00e9e avant ou apr\u00e8s l'ex\u00e9cution de la s\u00e9quence. Si la condition est fausse, la s\u00e9quence est interrompue et le programme continue son ex\u00e9cution.</p> <p></p>"}, {"location": "course-c/15-fundations/control-structures/#while", "title": "while", "text": "<p>La structure <code>while</code> r\u00e9p\u00e8te une s\u00e9quence tant que la condition est vraie.</p> <p>Dans l'exemple suivant tant que le poids d'un objet d\u00e9pos\u00e9 sur une balance est inf\u00e9rieur \u00e0 une valeur constante, une masse est ajout\u00e9e et le syst\u00e8me patiente avant stabilisation.</p> <pre><code>while (get_weight() &lt; 420 /* newtons */) {\n    add_one_kg();\n    wait(5 /* seconds */);\n}\n</code></pre> <p>S\u00e9quentiellement une boucle <code>while</code> teste la condition, puis ex\u00e9cute la s\u00e9quence associ\u00e9e.</p> <p>Exercise\u2009: Tant que...</p> <p>Comment se comportent ces programmes\u2009:</p> <ol> <li><code>size_t i=0;while(i&lt;11){i+=2;printf(\"%i\\n\",i);}</code></li> <li><code>i=11;while(i--){printf(\"%i\\n\",i--);}</code></li> <li><code>i=12;while(i--){printf(\"%i\\n\",--i);}</code></li> <li><code>i = 1;while ( i &lt;= 5 ){ printf ( \"%i\\n\", 2 * i++ );}</code></li> <li><code>i = 1; while ( i != 9 ) { printf ( \"%i\\n\", i = i + 2 ); }</code></li> <li><code>i = 1; while ( i &lt; 9 ) { printf ( \"%i\\n\", i += 2 ); break; }</code></li> <li><code>i = 0; while ( i &lt; 10 ) { continue; printf ( \"%i\\n\", i += 2 ); }</code></li> </ol> <p></p>"}, {"location": "course-c/15-fundations/control-structures/#dowhile", "title": "do..while", "text": "<p>De temps en temps il est n\u00e9cessaire de tester la condition \u00e0 la sortie de la s\u00e9quence et non \u00e0 l'entr\u00e9e. La boucle <code>do</code>...<code>while</code> permet justement ceci\u2009:</p> <pre><code>size_t i = 10;\n\ndo {\n    printf(\"Veuillez attendre encore %d seconde(s)\\r\\n\", i);\n    i -= 1;\n} while (i);\n</code></pre> <p>Contrairement \u00e0 la boucle <code>while</code>, la s\u00e9quence est ici ex\u00e9cut\u00e9e au moins une fois.</p> <p></p>"}, {"location": "course-c/15-fundations/control-structures/#for", "title": "for", "text": "<p>La boucle <code>for</code> est un <code>while</code> am\u00e9lior\u00e9 qui permet en une ligne de r\u00e9sumer les conditions de la boucle\u2009:</p> <pre><code>for (/* expression 1 */; /* expression 2 */; /* expression 3 */) {\n    /* s\u00e9quence */\n}\n</code></pre> Expression 1 <p>Ex\u00e9cut\u00e9e une seule fois \u00e0 l'entr\u00e9e dans la boucle, c'est l'expression d'initialisation permettant par exemple de d\u00e9clarer une variable et de l'initialiser \u00e0 une valeur particuli\u00e8re.</p> Expression 2 <p>Condition de validit\u00e9 (ou de maintien de la boucle). Tant que la condition est vraie, la boucle est ex\u00e9cut\u00e9e.</p> Expression 3 <p>Action de fin de tour. \u00c0 la fin de l'ex\u00e9cution de la s\u00e9quence, cette action est ex\u00e9cut\u00e9e avant le tour suivant. Cette action permet par exemple d'incr\u00e9menter une variable.</p> <p>Voici comment r\u00e9p\u00e9ter 10x un bloc de code\u2009:</p> <pre><code>for (size_t i = 0; i &lt; 10; i++) {\n    something();\n}\n</code></pre> <p>Notons que les portions de <code>for</code> sont optionnels et que la structure suivante est strictement identique \u00e0 la boucle <code>while</code>:</p> <pre><code>for (; get_weight() &lt; 420 ;) {\n    /* ... */\n}\n</code></pre> <p>Exercise\u2009: Pour quelques tours</p> <p>Comment est-ce que ces expressions se comportent-elles\u2009?</p> <pre><code>int i, k;\n</code></pre> <ol> <li><code>for (i = 'a'; i &lt; 'd'; printf (\"%i\\n\", ++i));</code></li> <li><code>for (i = 'a'; i &lt; 'd'; printf (\"%c\\n\", ++i));</code></li> <li><code>for (i = 'a'; i++ &lt; 'd'; printf (\"%c\\n\", i ));</code></li> <li><code>for (i = 'a'; i &lt;= 'a' + 25; printf (\"%c\\n\", i++ ));</code></li> <li><code>for (i = 1 / 3; i ; printf(\"%i\\n\", i++ ));</code></li> <li><code>for (i = 0; i != 1 ; printf(\"%i\\n\", i += 1 / 3 ));</code></li> <li><code>for (i = 12, k = 1; k++ &lt; 5 ; printf(\"%i\\n\", i-- ));</code></li> <li><code>for (i = 12, k = 1; k++ &lt; 5 ; k++, printf(\"%i\\n\", i-- ));</code></li> </ol> <p>Exercise\u2009: Erreur</p> <p>Identifier les deux erreurs dans ce code suivant\u2009:</p> <pre><code>for (size_t = 100; i &gt;= 0; --i)\n    printf(\"%d\\n\", i);\n</code></pre> <p>Exercise\u2009: De un \u00e0 cent</p> <p>\u00c9crivez un programme affichant les entiers de 1 \u00e0 100 en employant\u2009:</p> <ol> <li>Une boucle <code>for</code></li> <li>Une boucle <code>while</code></li> <li>Une boucle <code>do..while</code></li> </ol> <p>Quelle est la structure de contr\u00f4le la plus adapt\u00e9e \u00e0 cette situation\u2009?</p> <p>Exercise\u2009: Op\u00e9rateur virgule dans une boucle</p> <p>Expliquez quelle est la fonctionnalit\u00e9 globale du programme ci-dessous\u2009:</p> <pre><code>int main(void) {\n    for(size_t i = 0, j = 0; i * i &lt; 1000; i++, j++, j %= 26, printf(\"\\n\"))\n        printf(\"%c\", 'a' + (char)j);\n}\n</code></pre> <p>Proposer une meilleure impl\u00e9mentation de ce programme.</p>"}, {"location": "course-c/15-fundations/control-structures/#boucles-infinies", "title": "Boucles infinies", "text": "<p>Une boucle infinie n'est jamais termin\u00e9e. On rencontre souvent ce type de boucle dans ce que l'on appelle \u00e0 tort La boucle principale aussi nomm\u00e9e run loop. Lorsqu'un programme est ex\u00e9cut\u00e9 bare-metal, c'est \u00e0 dire directement \u00e0 m\u00eame le microcontr\u00f4leur et sans syst\u00e8me d'exploitation, il est fr\u00e9quent d'y trouver une fonction <code>main</code> telle que\u2009:</p> <pre><code>void main_loop() {\n    // Boucle principale\n}\n\nint main(void) {\n    for (;;)\n    {\n        main_loop();\n    }\n}\n</code></pre> <p>Il y a diff\u00e9rentes variantes de boucles infinies\u2009:</p> <pre><code>for (;;) { }\n\nwhile (true) { }\n\ndo { } while (true);\n</code></pre> <p>Notions que l'expression <code>while (1)</code> que l'on rencontre fr\u00e9quemment dans des exemples est fausse syntaxiquement. Une condition de validit\u00e9 devrait \u00eatre un bool\u00e9en, soit vrai, soit faux. Or, la valeur scalaire <code>1</code> devrait pr\u00e9alablement \u00eatre transform\u00e9e en une valeur bool\u00e9enne. Il est donc plus juste d'\u00e9crire <code>while (1 == 1)</code> ou simplement <code>while (true)</code>.</p> <p>On pr\u00e9f\u00e9rera n\u00e9anmoins l'\u00e9criture <code>for (;;)</code> qui ne fait pas intervenir de conditions ext\u00e9rieures, car, avant C99 d\u00e9finir la valeur <code>true</code> \u00e9tait \u00e0 la charge du d\u00e9veloppeur et on pourrait s'imaginer cette plaisanterie de mauvais go\u00fbt\u2009:</p> <pre><code>_Bool true = 0;\n\nwhile (true) { /* ... */ }\n</code></pre> <p>Lorsque l'on a besoin d'une boucle infinie, il est g\u00e9n\u00e9ralement pr\u00e9f\u00e9rable de permettre au programme de se terminer correctement lorsqu'il est interrompu par le signal SIGINT (c. f. signals). On rajoute alors une condition de sortie \u00e0 la boucle principale\u2009:</p> <pre><code>#include &lt;stdlib.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;stdbool.h&gt;\n\nstatic volatile bool is_running = true;\n\nvoid sigint_handler(int dummy)\n{\n    is_running = false;\n}\n\nint main(void)\n{\n    signal(SIGINT, sigint_handler);\n\n    while (is_running)\n    {\n       /* ... */\n    }\n\n    return EXIT_SUCCESS;\n}\n</code></pre> <p></p>"}, {"location": "course-c/15-fundations/control-structures/#les-sauts", "title": "Les sauts", "text": "<p>Il existe 4 instructions en C permettant de contr\u00f4ler le d\u00e9roulement de l'ex\u00e9cution d'un programme. Elles d\u00e9clenchent un saut inconditionnel vers un autre endroit du programme.</p> <ul> <li> <p><code>break</code> interrompt la structure de contr\u00f4le en cours. Elle est valide pour\u2009:</p> </li> <li> <p><code>while</code></p> </li> <li><code>do</code>...<code>while</code></li> <li> <p><code>switch</code></p> </li> <li> <p><code>continue</code>: saute un tour d'ex\u00e9cution dans une boucle</p> </li> <li><code>goto</code>: interrompt l'ex\u00e9cution et saute \u00e0 un label situ\u00e9 ailleurs dans la fonction</li> <li><code>return</code></li> </ul>"}, {"location": "course-c/15-fundations/control-structures/#goto", "title": "<code>goto</code>", "text": "<p>Il s'agit de l'instruction la plus controvers\u00e9e en C. Cherchez sur internet et les d\u00e9tracteurs sont nombreux, et ils ont partiellement raison, car dans la tr\u00e8s vaste majorit\u00e9 des cas o\u00f9 vous pensez avoir besoin de <code>goto</code>, une autre solution plus \u00e9l\u00e9gante existe.</p> <p>N\u00e9anmoins, il est important de comprendre que <code>goto</code> \u00e9tait dans certain langage de programmation comme BASIC, la seule structure de contr\u00f4le disponible permettant de faire des sauts. Elle est par ailleurs le reflet du langage machine, car la plupart des processeurs ne connaissent que cette instruction souvent appel\u00e9e <code>JUMP</code>. Il est par cons\u00e9quent possible d'imiter le comportement de n'importe quelle structure de contr\u00f4le si l'on dispose de <code>if</code> et de <code>goto</code>.</p> <p><code>goto</code> effectue un saut inconditionnel \u00e0 un label d\u00e9fini en C par un identificateur  suivi d'un <code>:</code>.</p> <p>L'un des seuls cas de figure autoris\u00e9s est celui d'un traitement d'erreur centralis\u00e9 lorsque de multiples points de retours existent dans une fonction ceci \u00e9vitant de r\u00e9p\u00e9ter du code\u2009:</p> <pre><code>#include &lt;time.h&gt;\n\nint parse_message(int message)\n{\n    struct tm *t = localtime(time(NULL));\n    if (t-&gt;tm_hour &lt; 7) {\n        goto error;\n    }\n\n    if (message &gt; 1000) {\n        goto error;\n    }\n\n    /* ... */\n\n    return 0;\n\n    error:\n        printf(\"ERROR: Une erreur a \u00e9t\u00e9 commise\\n\");\n        return -1;\n}\n</code></pre>"}, {"location": "course-c/15-fundations/control-structures/#continue", "title": "<code>continue</code>", "text": "<p>Le mot cl\u00e9 <code>continue</code> ne peut exister qu'\u00e0 l'int\u00e9rieur d'une boucle. Il permet d'interrompre le cycle en cours et directement passer au cycle suivant.</p> <pre><code>uint8_t airplane_seat = 100;\n\nwhile (--airplane_seat)\n{\n    if (airplane_seat == 13) {\n        continue;\n    }\n\n    printf(\"Dans cet avion il y a un si\u00e8ge num\u00e9ro %d\\n\", airplane_seat);\n}\n</code></pre> <p>Cette structure est \u00e9quivalente \u00e0 l'utilisation d'un goto avec un label plac\u00e9 \u00e0 la fin de la s\u00e9quence de boucle, mais promettez-moi que vous n'utiliserez jamais cet exemple\u2009:</p> <pre><code>while (true)\n{\n    if (condition) {\n        goto next;\n    }\n\n    /* ... */\n\n    next:\n}\n</code></pre>"}, {"location": "course-c/15-fundations/control-structures/#break", "title": "<code>break</code>", "text": "<p>Le mot-cl\u00e9 <code>break</code> peut \u00eatre utilis\u00e9 dans une boucle ou dans un <code>switch</code>. Il permet d'interrompre l'ex\u00e9cution de la boucle ou de la structure <code>switch</code> la plus proche. Nous avions d\u00e9j\u00e0 \u00e9voqu\u00e9 l'utilisation dans un <code>switch</code> (c.f. switch).</p>"}, {"location": "course-c/15-fundations/control-structures/#return", "title": "<code>return</code>", "text": "<p>Le mot cl\u00e9 <code>return</code> suivi d'une valeur de retour ne peut appara\u00eetre que dans une fonction dont le type de retour n'est pas <code>void</code>. Ce mot-cl\u00e9 permet de stopper l'ex\u00e9cution d'une fonction et de retourner \u00e0 son point d'appel.</p> <pre><code>void unlock(int password)\n{\n    static tries = 0;\n\n    if (password == 4710 /* MacGuyver: A Retrospective 1986 */) {\n        open_door();\n        tries = 0;\n        return;\n    }\n\n    if (tries++ == 3)\n    {\n        alert_security_guards();\n    }\n}\n</code></pre>"}, {"location": "course-c/15-fundations/control-structures/#exercices-de-revision", "title": "Exercices de r\u00e9vision", "text": "<p>Exercise\u2009: Faute d'erreur</p> <p>Consid\u00e9rons les d\u00e9clarations suivantes\u2009:</p> <pre><code>long i = 0;\ndouble x = 100.0;\n</code></pre> <p>Indiquer la nature de l'erreur dans les expressions suivantes\u2009:</p> <p>1.     </p><pre><code>do\n    x = x / 2.0;\n    i++;\nwhile (x &gt; 1.0);\n</code></pre> 2.     <pre><code>if (x = 0)\n    printf(\"0 est interdit !\\n\");\n</code></pre> 3.     <pre><code>switch(x) {\n    case 100 :\n        printf(\"Bravo.\\n\");\n        break;\n    default :\n        printf(\"Pas encore.\\n\");\n\n}\n</code></pre> 4.     <pre><code>for (i = 0 ; i &lt; 10 ; i++);\n    printf(\"%d\\n\", i);\n</code></pre> 5.     <pre><code>while i &lt; 100 {\n    printf(\"%d\", ++i);\n}\n</code></pre> <p>Exercise\u2009: Cas appropri\u00e9s</p> <p>Parmi les cas suivants, quelle structure de contr\u00f4le utiliser\u2009?</p> <ol> <li>Test qu'une variable est dans un intervalle donn\u00e9.</li> <li>Actions suivant un choix multiple de l'utilisateur</li> <li>Rechercher un caract\u00e8re particulier dans une cha\u00eene de caract\u00e8re</li> <li>It\u00e9rer toutes les valeurs paires sur un intervalle donn\u00e9</li> <li>Demander la ligne suivante du t\u00e9l\u00e9gramme \u00e0 l'utilisateur jusqu'\u00e0 <code>STOP</code></li> </ol> Solution <ol> <li> <p>Le cas est circonscrit \u00e0 un intervalle de valeur donn\u00e9e, le <code>if</code> est appropri\u00e9\u2009:</p> <pre><code>if (i &gt; min &amp;&amp; i &lt; max) { /* ... */ }\n</code></pre> </li> <li> <p>Dans ce cas un <code>switch</code> semble le plus appropri\u00e9</p> <pre><code>switch(choice) {\n    case 0 :\n        /* ... */\n        break;\n    case 1 :\n        /* ... */\n}\n</code></pre> </li> <li> <p>\u00c0 reformuler tant que le caract\u00e8re n'est pas trouv\u00e9 ou que la fin de la cha\u00eene n'est pas atteinte. On se retrouve donc avec une boucle \u00e0 deux conditions de sorties.</p> <pre><code>size_t pos;\nwhile (pos &lt; strlen(str) &amp;&amp; str[pos] != c) {\n    pos++;\n}\nif (pos == strlen(str)) {\n    // Not found\n} else {\n    // Found `c` in `str` at position `pos`\n}\n</code></pre> </li> <li> <p>La boucle <code>for</code> semble ici la plus adapt\u00e9e</p> <pre><code>for (size_t i = 100; i &lt; 200; i += 2) {\n    /* ... */\n}\n</code></pre> </li> <li> <p>Il est n\u00e9cessaire ici d'assurer au moins un tour de boucle\u2009:</p> <pre><code>const size_t max_line_length = 64;\nchar format[32];\nsnprintf(format, sizeof(format), \"%%%zus\", max_line_length - 1);\nunsigned int line = 0;\nchar buffer[max_lines][max_line_length];\ndo {\n    printf(\"%d. \", line);\n} while (\n    scanf(format, buffer[line]) == 1 &amp;&amp;\n    strcmp(buffer[line], \"STOP\") &amp;&amp;\n    ++line &lt; max_lines\n);\n</code></pre> </li> </ol> <p>Exercise\u2009: Comptons sur les caract\u00e8res</p> <p>Un texte est pass\u00e9 \u00e0 un programme par <code>stdin</code>. Comptez le nombre de caract\u00e8res transmis.</p> <pre><code>$ echo \"hello world\" | count-this\n11\n</code></pre> <p>Exercise\u2009: Esperluette conditionnelle</p> <p>Quel est le probl\u00e8me avec cette ligne de code\u2009?</p> <pre><code>if (x&amp;mask==bits)\n</code></pre> Solution <p>La priorit\u00e9 de l'op\u00e9rateur unitaire <code>&amp;</code> est plus \u00e9lev\u00e9e que <code>==</code> ce qui se traduit par\u2009:</p> <pre><code>if (x &amp; (mask == bits))\n</code></pre> <p>Le d\u00e9veloppeur voulait probablement appliquer le masque \u00e0 <code>x</code> puis le comparer au motif <code>bits</code>. La bonne r\u00e9ponse devrait alors \u00eatre\u2009:</p> <pre><code>if ((x &amp; mask) == bits)\n</code></pre>"}, {"location": "course-c/15-fundations/datatype/", "title": "Types de donn\u00e9es", "text": ""}, {"location": "course-c/15-fundations/datatype/#typage", "title": "Typage", "text": "<p>Inh\u00e9rent au fonctionnement interne de l'ordinateur, un langage de programmation s'abstrait plus ou moins du mode de stockage interne des donn\u00e9es telles qu'elles sont enregistr\u00e9es dans la m\u00e9moire. De la m\u00eame mani\u00e8re que dans la vie r\u00e9elle, il n'est pas possible de rendre de la monnaie \u00e0 un vendeur \u00e0 moins d'un cinqui\u00e8me de centime pr\u00e8s, il n'est pas possible pour un ordinateur de stocker des informations num\u00e9riques avec une pr\u00e9cision infinie.</p> <p>Aussi, les langages de programmation sont dits typ\u00e9s lorsqu'ils confient au programmeur la responsabilit\u00e9 de choisir comment une information sera stock\u00e9e en m\u00e9moire, et non typ\u00e9s lorsque ce choix est implicite. Chacun des langages \u00e0 ses avantages et ses inconv\u00e9nients et pour reprendre l'exemple du rendu de monnaie, il serait ennuyant d'autoriser d'enregistrer des informations financi\u00e8res avec une pr\u00e9cision meilleure qu'une pi\u00e8ce de cinq centimes, car il serait alors impossible \u00e0 un caissier de rendre la monnaie correctement. Dans cette situation on pr\u00e9f\u00e9rera les langages typ\u00e9s et heureusement C est un langage fortement typ\u00e9.</p> <p>Les types de donn\u00e9es ne se bornent pas qu'aux informations num\u00e9riques, il existe des types plus complexes qui permettent par exemple de traiter des caract\u00e8res tels que <code>A</code> ou <code>B</code>. Ce chapitre \u00e0 pour objectif de familiariser le lecteur aux diff\u00e9rents types de donn\u00e9es disponibles en C.</p> <p>Standard ISO 80000-2</p> <p>Les ing\u00e9nieurs sont friands des standards et qui plus est lorsqu'ils sont  internationaux. Ainsi afin d'\u00e9viter le crash malheureux d'une fus\u00e9e caus\u00e9 par la m\u00e9sentente de deux ing\u00e9nieurs de diff\u00e9rents pays, il existe la norme ISO 80000-2 qui d\u00e9finit pr\u00e9cis\u00e9ment ce qu'est un entier, s'il doit inclure ou non le z\u00e9ro, que sont les nombres r\u00e9els, etc. Bien entendu les compilateurs, s'ils sont bien faits, cherchent \u00e0 respecter au mieux ces normes internationales, et vous\u2009?</p>"}, {"location": "course-c/15-fundations/datatype/#stockage-et-interpretation", "title": "Stockage et interpr\u00e9tation", "text": "<p>Rappelez-vous qu'un ordinateur ne peut stocker l'information que sous forme binaire et qu'il n'est \u00e0 m\u00eame de manipuler ces informations que par paquets d\u2019octets. Aussi un ordinateur 64-bits manipulera avec aisance des paquets de 64-bits, mais plus difficilement des paquets de 32-bits. Ajoutons qu'il existe encore des microcontr\u00f4leurs 8-bits utilis\u00e9s dans des dispositifs \u00e0 faible consommation et qui peinent \u00e0 manipuler des types de plus grande taille. Stocker une temp\u00e9rature avec une trop grande pr\u00e9cision et effectuer des op\u00e9rations math\u00e9matiques sur toute la pr\u00e9cision serait une erreur, car le microcontr\u00f4leur n'est simplement pas adapt\u00e9 \u00e0 manipuler ce type d'information.</p> <p>Consid\u00e9rons le paquet de 32-bit suivant, \u00eates-vous \u00e0 m\u00eame d'en donner une signification\u2009?</p> <pre><code>01000000 01001001 00001111 11011011\n</code></pre> <p>Il y a plusieurs interpr\u00e9tations possibles\u2009:</p> <ol> <li>4 caract\u00e8res de 8-bits\u2009: <code>01000000</code> <code>@</code>, <code>01001001</code> <code>I</code>, <code>00001111</code> <code>\\x0f</code> et <code>11011011</code> <code>\u00db</code>.</li> <li>4 nombres de 8-bits\u2009: <code>64</code>, <code>73</code>, <code>15</code>, <code>219</code>.</li> <li>Deux nombres de 16-bits <code>18752</code> et <code>56079</code>.</li> <li>Un seul nombre de 32-bit <code>3675212096</code>.</li> <li>Peut-\u00eatre le nombre <code>-40331460896358400.000000</code> lu en little endian.</li> <li>Ou encore <code>3.141592</code> lu en big endian.</li> </ol> <p>Qu'en pensez-vous\u2009?</p> <p>Lorsque l'on souhaite programmer \u00e0 bas niveau, vous voyez que la notion de type de donn\u00e9e est essentielle, car en dehors d'une interpr\u00e9tation subjective\u2009: \u00ab\u2009c'est forc\u00e9ment PI la bonne r\u00e9ponse\u2009\u00bb, rien ne permet \u00e0 l'ordinateur d'interpr\u00e9ter convenablement l'information enregistr\u00e9e en m\u00e9moire.</p> <p>Le typage permet de r\u00e9soudre toute ambigu\u00eft\u00e9.</p> <pre><code>int main() {\n    union {\n        uint8_t u8[4];\n        uint16_t u16[2];\n        uint32_t u32;\n        float f32;\n    } u = { 0b01000000, 0b01001001, 0b00001111, 0b11011011 };\n\n    printf(\"'%c', '%c', '%c', '%c'\\n\", u.u8[0], u.u8[1], u.u8[2], u.u8[3]);\n    printf(\"%hhu, %hhu, %hhu, %hhu\\n\", u.u8[0], u.u8[1], u.u8[2], u.u8[3]);\n    printf(\"%hu, %hu\\n\", u.u16[0], u.u16[1]);\n    printf(\"%u\\n\", u.u32);\n    printf(\"%f\\n\", u.f32);\n    u.u32 = (\n        ((u.u32 &gt;&gt; 24) &amp; 0xff) | // move byte 3 to byte 0\n        ((u.u32 &lt;&lt; 8) &amp; 0xff0000) | // move byte 1 to byte 2\n        ((u.u32 &gt;&gt; 8) &amp; 0xff00) | // move byte 2 to byte 1\n        ((u.u32 &lt;&lt; 24) &amp; 0xff000000) // byte 0 to byte 3\n    );\n    printf(\"%f\\n\", u.f32);\n}\n</code></pre> <p></p>"}, {"location": "course-c/15-fundations/datatype/#boutisme", "title": "Boutisme", "text": "<p> Boutisme par J. J. Grandville (1838)</p> <p>La hantise de l'ing\u00e9nieur bas-niveau c'est le boutisme aussi appel\u00e9 endianess. Ce terme \u00e9trange a \u00e9t\u00e9 popularis\u00e9 par l'informaticien Dany Cohen en r\u00e9f\u00e9rence aux Voyages de Gulliver de Jonathan Swift. Dans ce conte les habitants de Lilliput refusent d'ob\u00e9ir \u00e0 un d\u00e9cret obligeant \u00e0 manger les \u0153ufs \u00e0 la coque par le petit bout (petit boutisme/little endian), la r\u00e9pression incite les rebelles \u00e0 manger leurs \u0153ufs par le gros bout (gros boutisme/big endian).</p> <p>Aujourd'hui encore, il existe des microprocesseurs qui fonctionnent en big endian alors que d'autres sont en little endian. C'est-\u00e0-dire que si une information est stock\u00e9e en m\u00e9moire comme suit\u2009:</p> <pre><code>[0x40, 0x49, 0xf, 0xdb]\n</code></pre> <p>Faut-il la lire de gauche \u00e0 droite ou de droite \u00e0 gauche\u2009? Cela vous para\u00eet trivial, mais si cet exemple \u00e9tait mentionn\u00e9 dans un livre r\u00e9dig\u00e9 en arabe, quelle serait alors votre r\u00e9ponse\u2009?</p> <p>Imaginons qu'un programme ex\u00e9cut\u00e9 sur un microcontr\u00f4leur big-endian 8-bit envoie par Bluetooth la valeur <code>1'111'704'645</code>, qui correspond au nombre de photons ayant frapp\u00e9 un d\u00e9tecteur optique. Il transmet donc les 4 octets suivants\u2009: <code>0x42, 0x43, 0x44, 0x45</code>. L'ordinateur qui re\u00e7oit les informations d\u00e9code <code>1'162'101'570</code>. Les deux ordinateurs n'interpr\u00e8tent pas les donn\u00e9es de la m\u00eame fa\u00e7on, et c'est un probl\u00e8me que la plupart des ing\u00e9nieurs \u00e9lectroniciens rencontrent un jour dans leur carri\u00e8re.</p>"}, {"location": "course-c/15-fundations/datatype/#les-nombres-entiers", "title": "Les nombres entiers", "text": "<p>Les nombres entiers sont des nombres sans virgule et incluant le z\u00e9ro. Ils peuvent donc \u00eatre n\u00e9gatifs, nuls ou positifs. Math\u00e9matiquement ils appartiennent \u00e0 l'ensemble des entiers relatifs.</p> <p>Comme aucun ordinateur ne dispose d'un espace de stockage infini, ces nombres excluent les infinis positifs et n\u00e9gatifs, et sont donc born\u00e9s, cela va de soi.</p>"}, {"location": "course-c/15-fundations/datatype/#les-entiers-naturels", "title": "Les entiers naturels", "text": "<p>En informatique, ces nombres sont par cons\u00e9quent non sign\u00e9s, et peuvent prendre des valeurs comprises entre \\(0\\) et \\(2^N-1\\) o\u00f9 \\(N\\) correspond au nombre de bits avec lesquels la valeur num\u00e9rique sera stock\u00e9e en m\u00e9moire. Il faut naturellement que l'ordinateur sur lequel s'ex\u00e9cute le programme soit capable de supporter le nombre de bits demand\u00e9 par le programmeur.</p> <p>En C, on nomme ce type de donn\u00e9e <code>unsigned int</code>, <code>int</code> \u00e9tant le d\u00e9nominatif du latin integer signifiant \u00ab\u2009entier\u2009\u00bb.</p> <p>Voici quelques exemples des valeurs minimales et maximales possibles selon le nombre de bits utilis\u00e9s pour coder l'information num\u00e9rique\u2009:</p>  Stockage d'un entier non sign\u00e9 sur diff\u00e9rentes profondeurs Profondeur Minimum Maximum 8 bits 0 255 (\\(2^8 - 1\\)) 16 bits 0 65'535 (\\(2^{16} - 1\\)) 32 bits 0 4'294'967'295 (\\(2^{32} - 1\\)) 64 bits 0 18'446'744'073'709'551'616 (\\(2^{64} - 1\\)) <p>Notez l'importance du \\(-1\\) dans la d\u00e9finition du maximum, car la valeur minimum \\(0\\) fait partie de l'information m\u00eame si elle repr\u00e9sente une quantit\u00e9 nulle. Il y a donc 256 valeurs possibles pour un nombre entier non sign\u00e9 8-bits, bien que la valeur maximale ne soit que de 255.</p>"}, {"location": "course-c/15-fundations/datatype/#les-entiers-bornes-signes", "title": "Les entiers born\u00e9s sign\u00e9s", "text": "<p>Les entiers sign\u00e9s peuvent \u00eatre n\u00e9gatifs, nuls ou positifs et peuvent prendre des valeurs comprises entre \\(-2^{N-1}\\) et \\(+2^{N-1}-1\\) o\u00f9 \\(N\\) correspond au nombre de bits avec lesquels la valeur num\u00e9rique sera stock\u00e9e en m\u00e9moire. Notez l'asym\u00e9trie entre la borne positive et n\u00e9gative.</p> <p>Comme il sont sign\u00e9s (signed en anglais), il est par cons\u00e9quent correct d'\u00e9crire <code>signed int</code> bien que le pr\u00e9fixe <code>signed</code> soit optionnel, car le standard d\u00e9finit qu'un entier est par d\u00e9faut sign\u00e9. La raison \u00e0 cela rel\u00e8ve plus du lourd historique de C qu'\u00e0 des pr\u00e9ceptes logiques et rationnels.</p> <p>Voici quelques exemples de valeurs minimales et maximales selon le nombre de bits utilis\u00e9s pour coder l'information\u2009:</p>  Stockage d'un entier sign\u00e9 sur diff\u00e9rentes profondeurs Profondeur Minimum Maximum 8 bits -128 +127 16 bits -32'768 +32'767 32 bits -2'147'483'648 +2'147'483'647 <p>En m\u00e9moire, ces nombres sont stock\u00e9s en utilisant le compl\u00e9ment \u00e0 deux qui fait l'objet d'une section \u00e0 part enti\u00e8re.</p>"}, {"location": "course-c/15-fundations/datatype/#les-entiers-bornes", "title": "Les entiers born\u00e9s", "text": "<p>Comme nous l'avons vu, les degr\u00e9s de libert\u00e9 pour d\u00e9finir un entier sont\u2009:</p> <ul> <li>Sign\u00e9 ou non sign\u00e9</li> <li>Nombre de bits avec lesquels l'information est stock\u00e9e en m\u00e9moire</li> </ul> <p>\u00c0 l'origine le standard C restait flou quant au nombre de bits utilis\u00e9s pour chacun des types et aucune r\u00e9elle coh\u00e9rence n'existait pour la construction d'un type. Le modificateur <code>signed</code> \u00e9tait optionnel, le pr\u00e9fixe <code>long</code> ne pouvait s'appliquer qu'au type <code>int</code> et <code>long</code> et la confusion entre <code>long</code> (pr\u00e9fixe) et <code>long</code> (type) restait possible. En fait, la plupart des d\u00e9veloppeurs s'y perdaient et s'y perd toujours ce qui menait \u00e0 des probl\u00e8mes de compatibilit\u00e9s des programmes entre eux.</p>"}, {"location": "course-c/15-fundations/datatype/#types-standards", "title": "Types standards", "text": "<p>La construction d'un type entier C est la suivante\u2009:</p> <p> Entiers standardis\u00e9s</p> <p>Ce qu'il faut retenir c'est que chaque type de donn\u00e9e offre une profondeur d'au moins \\(N\\) bits, ce qui est l'information minimale essentielle pour le programmeur. La liste des types de donn\u00e9es standards en C pour les entiers est donn\u00e9e ci-dessous\u2009:</p>  Table des types entiers en C Type Signe Profondeur Format <code>char</code> ? <code>CHAR_BIT</code> <code>%c</code> <code>signed char</code> signed au moins 8 bits <code>%c</code> <code>unsigned char</code> unsigned au moins 8 bits <code>%c</code> <code>short</code> signed  au moins 16 bits   %hi  <code>short int</code> <code>signed short</code> <code>signed short int</code> <code>unsigned short</code> unsigned  au moins 16 bits  %hu  <code>unsigned short int</code> <code>unsigned</code> unsigned  au moins 32 bits  %u   <code>unsigned int</code> <code>int</code> signed  au moins 32 bits  %d  <code>signed</code> <code>signed int</code> <code>unsigned</code> unsigned  au moins 32 bits  %u  <code>unsigned int</code> <code>long</code> signed  au moins 32 bits  %li  <code>long int</code> <code>signed long</code> <code>signed long int</code> <code>unsigned long</code> unsigned  au moins 32 bits  %lu  <code>unsigned long int</code> <code>long long</code> signed  au moins 64 bits  %lli  <code>long long int</code> <code>signed long long</code> <code>signed long long int</code> <code>unsigned long long</code> unsigned  au moins 64 bits  %llu  <code>unsigned long long int</code> <p>Avec l'av\u00e8nement de C99, une meilleure coh\u00e9sion des types a \u00e9t\u00e9 propos\u00e9e dans le fichier d'en-t\u00eate <code>stdint.h</code>. Cette biblioth\u00e8que standard offre les types suivants\u2009:</p> <p> Flux de construction d'un entier standardis\u00e9</p> <p></p>"}, {"location": "course-c/15-fundations/datatype/#types-reformes", "title": "Types r\u00e9form\u00e9s", "text": "<p>Voici les types standards qu'il est recommand\u00e9 d'utiliser lorsque le nombre de bits de l'entier doit \u00eatre ma\u00eetris\u00e9.</p>  Entiers standard d\u00e9fini par stdint Type Signe Profondeur Format <code>uint8_t</code> unsigned 8 bits <code>%c</code> <code>int8_t</code> signed 8 bits <code>%c</code> <code>uint16_t</code> unsigned 16 bits <code>%hu</code> <code>int16_t</code> signed 16 bits <code>%hi</code> <code>uint32_t</code> unsigned 32 bits <code>%u</code> <code>int32_t</code> signed 32 bits <code>%d</code> <code>uint64_t</code> unsigned 64 bits <code>%llu</code> <code>int64_t</code> signed 64 bits <code>%lli</code> <p>\u00c0 ces types s'ajoutent les types rapides (fast) et minimums (least). Un type nomm\u00e9 <code>uint_least32_t</code> garanti l'utilisation du type de donn\u00e9e utilisant le moins de m\u00e9moire et garantissant une profondeur d'au minimum 32 bits. Il est strictement \u00e9quivalent \u00e0 <code>unsigned int</code>.</p> <p>Les types rapides, moins utilis\u00e9s vont automatiquement choisir le type adapt\u00e9 le plus rapide \u00e0 l'ex\u00e9cution. Par exemple si l'architecture mat\u00e9rielle permet un calcul natif sur 48-bits, elle sera privil\u00e9gi\u00e9e par rapport au type 32-bits.</p> <p>Exercise\u2009: Expressions arithm\u00e9tiques enti\u00e8res</p> <p>Donnez la valeur des expressions ci-dessous\u2009:</p> <pre><code>25 + 10 + 7 \u2013 3\n5 / 2\n24 + 5 / 2\n(24 + 5) / 2\n25 / 5 / 2\n25 / (5 / 2)\n72 % 5 \u2013 5\n72 / 5 \u2013 5\n8 % 3\n-8 % 3\n8 % -3\n-8 % -3\n</code></pre> <p>Exercise\u2009: D\u00e9bordement</p> <p>Quel sera le contenu de <code>j</code> apr\u00e8s l'ex\u00e9cution de l'instruction suivante\u2009:</p> <pre><code>uint16_t j = 1024 * 64;\n</code></pre>"}, {"location": "course-c/15-fundations/datatype/#modele-de-donnee", "title": "Mod\u00e8le de donn\u00e9e", "text": "<p>Comme nous l'avons \u00e9voqu\u00e9 plus haut, la taille des entiers <code>short</code>, <code>int</code>, ... n'est pas pr\u00e9cis\u00e9ment d\u00e9finie par le standard. On sait qu'un <code>int</code> contient au moins 16-bits, mais il peut, selon l'architecture, et aussi le mod\u00e8le de donn\u00e9e, prendre n'importe quelle valeur sup\u00e9rieure. Ceci pose des probl\u00e8mes de portabilit\u00e9 possibles si le d\u00e9veloppeur n'est pas suffisamment consciencieux et qu'il ne s'appuie pas sur une batterie de tests automatis\u00e9s.</p> <p>Admettons que ce d\u00e9veloppeur sans scrupule d\u00e9veloppe un programme complexe sur sa machine de guerre 64-bits en utilisant un <code>int</code> comme valeur de comptage allant au-del\u00e0 de dix milliards. Apr\u00e8s tests, son programme fonctionne sur sa machine, ainsi que celle de son coll\u00e8gue. Mais lorsqu'il livre le programme \u00e0 son client, le processus crash. En effet, la taille du <code>int</code> sur l'ordinateur du client est de 32-bits. Comment peut-on s'affranchir de ce type de probl\u00e8me\u2009?</p> <p>La premi\u00e8re solution est de toujours utiliser les types propos\u00e9s par <code>&lt;stdint.h&gt;</code> lorsque la taille du type n\u00e9cessaire est sup\u00e9rieure \u00e0 la valeur garantie. L'autre solution est de se fier au mod\u00e8le de donn\u00e9es\u2009:</p>  Mod\u00e8le de donn\u00e9es Mod\u00e8le short int long long long size_t Syst\u00e8me d'exploitation LP32 16 16 32 32 Windows 16-bits, Apple Macintosh ILP32 16 32 32 64 32 Windows x86, Linux 32-bits LLP64 16 32 32 64 64 Microsoft Windows x86-64 LP64 16 32 64 64 64 Unix, Linux, macOS ILP64 16 64 64 64 64 HAL (SPARC) SILP64 64 64 64 64 64 UNICOS (Super ordinateur) <p>Pour les ordinateurs modernes, on peut faire l'hypoth\u00e8se raisonnable que\u2009:</p> <ul> <li><code>char</code> est de 8-bits,</li> <li><code>short</code> est de 16-bits,</li> <li><code>int</code> est de 32-bits,</li> <li><code>long long</code> est de 64-bits,</li> </ul> <p>Pour s'assurer qu'un type est de la taille souhait\u00e9e, il est recommand\u00e9 d'utiliser les types r\u00e9form\u00e9s de <code>&lt;stdint.h&gt;</code>. Ainsi pour s'assurer qu'un type soit au moins de 32-bits, on utilisera <code>uint_least32_t</code>.</p>"}, {"location": "course-c/15-fundations/datatype/#les-caracteres", "title": "Les caract\u00e8res", "text": "<p>Les caract\u00e8res, ceux que vous voyez dans cet ouvrage, sont g\u00e9n\u00e9ralement repr\u00e9sent\u00e9s par des grandeurs exprim\u00e9es sur 1 octet (8-bits):</p> <pre><code>97 \u2261 0b1100001 \u2261 'a'\n</code></pre> <p>Un caract\u00e8re du clavier enregistr\u00e9 en m\u00e9moire c'est donc un nombre entier de 8-bits. En C, le type de donn\u00e9e <code>char</code> est utilis\u00e9 pour stocker un caract\u00e8re.</p> <p>Mais comment un ordinateur sait-il que <code>97</code> correspond \u00e0 <code>a</code> ? C'est l\u00e0 que la notion d'encodage entre en jeu.</p>"}, {"location": "course-c/15-fundations/datatype/#la-table-ascii", "title": "La table ASCII", "text": "<p>Historiquement, alors que les informations dans un ordinateur ne sont que des 1 et des 0, il a fallu \u00e9tablir une correspondance entre une grandeur binaire et le caract\u00e8re associ\u00e9. Un standard a \u00e9t\u00e9 propos\u00e9 en 1963 par l'ASA, l'American Standards Association aujourd'hui ANSI qui ne d\u00e9finissait alors que 63 caract\u00e8res imprimables et comme la m\u00e9moire \u00e9tait en son temps tr\u00e8s cher, un caract\u00e8re n'\u00e9tait cod\u00e9 que sur 7 bits.</p> <p> Table ASCII ASA X3.4 \u00e9tablie en 1963</p> <p>Aujourd'hui la table ASCII de base d\u00e9finit 128 caract\u00e8res qui n'incluent pas les caract\u00e8res accentu\u00e9s.</p> <p> Table ANSI INCITS 4-1986 (standard actuel)</p> <p>Chaque pays et chaque langue utilise ses propres caract\u00e8res et il a fallu trouver un moyen de satisfaire tout le monde. Il a \u00e9t\u00e9 alors convenu d'encoder les caract\u00e8res sur 8-bits au lieu de 7 et de profiter des 128 nouvelles positions pour ajouter les caract\u00e8res manquants tels que les caract\u00e8res accentu\u00e9s, le signe euro, la livre sterling et d'autres. Le standard ISO/IEC 8859 aussi appel\u00e9 standard Latin d\u00e9finit 16 tables d'extension selon les besoins des pays. Les plus courantes en Europe occidentale sont les tables ISO-8859-1 ou (latin1) et ISO-8859-15 (latin9):</p> <p> Table d'extension ISO-8859-1 (haut) et ISO-8859-15 (bas)</p> <p>Ce standard a g\u00e9n\u00e9r\u00e9 durant des d\u00e9cennies de grandes frustrations et de profondes incompr\u00e9hensions chez les d\u00e9veloppeurs, et utilisateurs d'ordinateur. Ne vous est-il jamais arriv\u00e9 d'ouvrir un fichier texte et de ne plus voir les accents convenablement\u2009? C'est un probl\u00e8me typique d'encodage.</p> <p>Pour tenter de rem\u00e9dier \u00e0 ce standard incompatible entre les pays, Microsoft a propos\u00e9 un standard nomm\u00e9 Windows-1252 s'inspirant de ISO-8859-1. En voulant rassembler en proposant un standard plus g\u00e9n\u00e9ral, Microsoft n'a contribu\u00e9 qu'\u00e0 proposer un standard suppl\u00e9mentaire venant s'inscrire dans une liste d\u00e9j\u00e0 trop longue. Et l'histoire n'est pas termin\u00e9e...</p>"}, {"location": "course-c/15-fundations/datatype/#unicode", "title": "Unicode", "text": "<p>Avec l'arriv\u00e9e d'internet et les \u00e9changes entre les Arabes (\u0639\u064e\u0631\u064e\u0628), les Cor\u00e9ens (\ud55c\uad6d\uc5b4), les Japonais qui poss\u00e8dent deux alphabets ainsi que des caract\u00e8res chinois (\u65e5\u672c\u8a9e), sans oublier l'ourdou (\u067e\u0627\u06a9\u0650\u0633\u062a\u0627\u0646) pakistanais et tous ceux que l'on ne mentionnera pas, il a fallu bien plus que 256 caract\u00e8res et quelques tables de correspondance. Ce pr\u00e9sent ouvrage, ne pourrait d'ailleurs par \u00eatre \u00e9crit sans avoir pu r\u00e9soudre, au pr\u00e9alable, ces probl\u00e8mes d'encodage\u2009; la preuve \u00e9tant, vous parvenez \u00e0 voir ces caract\u00e8res qui ne vous sont pas familiers.</p> <p>Un consensus plan\u00e9taire a \u00e9t\u00e9 atteint en 2008 avec l'adoption majoritaire du standard Unicode (Universal Coded Character Set) plus pr\u00e9cis\u00e9ment nomm\u00e9 UTF-8.</p> <p> Tendances sur l'encodage des pages web en faveur de UTF-8 d\u00e8s 2008</p> <p>Cette tendance est accessible ici.</p> <p>L'UTF-8 est capable d'encoder 11'112'064 caract\u00e8res en utilisant de 1 \u00e0 4 octets. Ken Thompson, dont nous avons d\u00e9j\u00e0 parl\u00e9 en introduction,  est \u00e0 l'origine de ce standard. Par exemple le devanagari caract\u00e8re <code>\u0939</code> utilis\u00e9 en Sanskrit poss\u00e8de la d\u00e9nomination Unicode 0939 et s'encode sur 3 octets\u2009: <code>0xE0 0xA4 0xB9</code></p> <p>En programmation C, un caract\u00e8re <code>char</code> ne peut exprimer sans ambig\u00fcit\u00e9 que les 128 caract\u00e8res de la table ASCII standard et selon les conventions locales, les 128 caract\u00e8res d'extension.</p> <p>Voici par exemple comment d\u00e9clarer une variable contenant le caract\u00e8re dollar\u2009:</p> <pre><code>char c = '$';\n</code></pre> <p>Attention donc au caract\u00e8re <code>'3'</code> qui correspond \u00e0 la grandeur hexad\u00e9cimale <code>0x33</code>:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char c = '3';\n    printf(\"Le caract\u00e8re %c vaut 0x%x en hexad\u00e9cimal ou %d en d\u00e9cimal.\\n\", c, c, c);\n    return 0;\n}\n</code></pre> <p>Note</p> <p>L'unicode permet notament de repr\u00e9senter des caract\u00e8res sp\u00e9ciaux tels que les \u00e9motic\u00f4nes (\ud83d\udca9).</p>"}, {"location": "course-c/15-fundations/datatype/#les-emojis", "title": "Les emojis", "text": "<p>Les emojis sont des caract\u00e8res sp\u00e9ciaux qui ont \u00e9t\u00e9 introduits en 2010 par le standard Unicode 6.0. Ils sont donc cod\u00e9s sur 4 octets et permettent de repr\u00e9senter des \u00e9motions, des objets, des animaux, des symboles, etc.</p> <p>Les \u00e9motic\u00f4nes que vous pouvez envoyer \u00e0 votre grand-m\u00e8re sont donc des caract\u00e8res Unicode et non des images. Si vous dites \u00e0 votre grand-maman que vous l'aimez en lui envoyant un c\u0153ur, elle recevra le caract\u00e8re 2764 qui est le caract\u00e8re <code>\u2764</code>. Mais les navigateurs web et les applications informatiques remplacent \u00e0 la vol\u00e9e ces caract\u00e8res par des images.</p> <p>Ceci est vrai, mais encore faut-il que la police d'\u00e9criture utilis\u00e9e par votre ch\u00e8re grand-maman soit capable d'afficher ce caract\u00e8re. Si ce n'est pas le cas, elle verra probablement le caract\u00e8re \ufffd qui est un caract\u00e8re de remplacement tr\u00e8s disgracieux et qui ne d\u00e9montre pas tout l'amour que vous lui portez.</p>"}, {"location": "course-c/15-fundations/datatype/#chaine-de-caracteres", "title": "Cha\u00eene de caract\u00e8res", "text": "<p>Une cha\u00eene de caract\u00e8res est simplement la suite contigu\u00eb de plusieurs caract\u00e8res dans une zone m\u00e9moire donn\u00e9e. Afin de savoir lorsque cette cha\u00eene se termine, le standard impose que le dernier caract\u00e8re d'une cha\u00eene soit <code>NUL</code> ou <code>\\0</code>. On appelle ce caract\u00e8re le caract\u00e8re de fin de cha\u00eene. Il s'agit d'une sentinelle.</p> <p>Les l\u00e9gumes et les choux</p> <p>Imaginez que l'on vous demande de vous placer dans un champ et de d\u00e9terrer n'importe quel l\u00e9gume sauf un chou. Votre algorithme est\u2009:</p> <pre><code>%% Algorithme de d\u00e9terrage de l\u00e9gumes\nflowchart LR\n    start(D\u00e9but) --&gt; pick[D\u00e9terrer]\n    pick --&gt; if{Choux?}\n    if --Non--&gt; step[Avancer de 1 pas]\n    step --&gt; pick\n    if --Oui--&gt; stop(Fin)</code></pre> <p>Si vous trouvez un chou, vous savez que vous \u00eates arriv\u00e9s au bout du champ. Le chou fait office de sentinelle.</p> <p>Sans sentinelle, vous \u00eates oblig\u00e9 de conna\u00eetre \u00e0 l'avance le nombre de pas \u00e0 faire pour arriver au bout du champ. Vous devez donc stocker en m\u00e9moire cette information additionnelle ce qui n'est pas pratique.</p> <p>La cha\u00eene de caract\u00e8re <code>Hello</code> sera en m\u00e9moire stock\u00e9e en utilisant les codes ASCII suivants.</p> <pre><code>char string[] = \"Hello\";\n</code></pre> <pre><code>  H   E   L   L   O  \\0\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n\u2502 72\u2502101\u2502108\u2502108\u2502111\u2502 0 \u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n\n 0x00 01001000\n 0x01 01100101\n 0x02 01101100\n 0x03 01101100\n 0x04 01101111\n 0x05 00000000\n</code></pre> <p>On utilise le caract\u00e8re nul <code>\\0</code> pour plusieurs raisons\u2009:</p> <ol> <li>Il est facilement reconnaissable.</li> <li>Dans un test il vaut <code>false</code>.</li> <li>Il n'est pas imprimable et n'appartient \u00e0 aucun caract\u00e8re sp\u00e9cial.</li> </ol> <p>Avertissement</p> <p>Ne pas confondre le caract\u00e8re nul <code>\\0</code> avec le caract\u00e8re <code>0</code>. Le premier est un caract\u00e8re de fin de cha\u00eene, le second est un caract\u00e8re num\u00e9rique qui vaut <code>0x30</code>.</p> <p>Exercise\u2009: Constantes litt\u00e9rales caract\u00e9rielles</p> <p>Indiquez si les constantes litt\u00e9rales suivantes sont valides ou invalides.</p> <ol> <li><code>'a'</code></li> <li><code>'A'</code></li> <li><code>'ab'</code></li> <li><code>'\\x41'</code></li> <li><code>'\\041'</code></li> <li><code>'\\0x41'</code></li> <li><code>'\\n'</code></li> <li><code>'\\w'</code></li> <li><code>'\\t'</code></li> <li><code>'\\xp2'</code></li> <li><code>\"abcdef\"</code></li> <li><code>\"\\abc\\ndef\"</code></li> <li><code>\"\\'\\\"\\\\\"</code></li> <li><code>\"hello \\world!\\n\"</code></li> </ol> <p>Exercise\u2009: Cha\u00eenes de formatage</p> <p>Pour les instructions ci-dessous, indiquer quel est l'affichage obtenu.</p> <pre><code>char a = 'a';\nshort sh1 = 5;\nfloat f1 = 7.0f;\nint i1 = 7, i2 = 'a';\n</code></pre> <ol> <li><code>printf(\"Next char: %c.\\n\", a + 1);</code></li> <li><code>printf(\"Char: %3c.\\n\", a);</code></li> <li><code>printf(\"Char: %-3c.\\n\", a);</code></li> <li><code>printf(\"Chars: \\n-%c.\\n-%c.\\n\", a, 'z' - 1);</code></li> <li><code>printf(\"Sum: %i\\n\", i1 + i2 - a);</code></li> <li><code>printf(\"Taux d\u2019erreur\\t%i %%\\n\", i1);</code></li> <li><code>printf(\"Quel charabia horrible:\\\\\\a\\a\\a%g\\b\\a%%\\a\\\\\\n\", f1);</code></li> <li><code>printf(\"Inventaire: %i4 pieces\\n\", i1);</code></li> <li><code>printf(\"Inventory: %i %s\\n\", i1, \"pieces\");</code></li> <li><code>printf(\"Inventaire: %4i pieces\\n\", i1);</code></li> <li><code>printf(\"Inventaire: %-4i pieces\\n\", i1);</code></li> <li><code>printf(\"Mixed sum: %f\\n\", sh1 + i1 + f1);</code></li> <li><code>printf(\"Tension: %5.2f mV\\n\", f1);</code></li> <li><code>printf(\"Tension: %5.2e mV\\n\", f1);</code></li> <li><code>printf(\"Code: %X\\n\", 12);</code></li> <li><code>printf(\"Code: %x\\n\", 12);</code></li> <li><code>printf(\"Code: %o\\n\", 12);</code></li> <li><code>printf(\"Value: %i\\n\", -1);</code></li> <li><code>printf(\"Value: %hi\\n\", 65535u);</code></li> <li><code>printf(\"Value: %hu\\n\", -1);</code></li> </ol>"}, {"location": "course-c/15-fundations/datatype/#les-booleens", "title": "Les bool\u00e9ens", "text": "<p>Un bool\u00e9en est un type de donn\u00e9e \u00e0 deux \u00e9tats consensuellement nomm\u00e9s vrai (<code>true</code>) et faux (<code>false</code>) et destin\u00e9s \u00e0 repr\u00e9senter les \u00e9tats en logique bool\u00e9enne (Nom venant de George Boole, fondateur de l'alg\u00e8bre \u00e9ponyme).</p> <p>La convention est d'utiliser <code>1</code> pour m\u00e9moriser un \u00e9tat vrai, et <code>0</code> pour un \u00e9tat faux, c'est d'ailleurs de cette mani\u00e8re que les bool\u00e9ens sont encod\u00e9s en C.</p> <p>Les bool\u00e9ens ont \u00e9t\u00e9 introduits formellement en C avec C99 et n\u00e9cessitent l'inclusion du fichier d'en-t\u00eate <code>stdbool.h</code>. Avant cela le type bool\u00e9en \u00e9tait <code>_Bool</code> et d\u00e9finir les \u00e9tats vrais et faux \u00e9tait \u00e0 la charge du d\u00e9veloppeur.</p> <pre><code>#include &lt;stdbool.h&gt;\n\nbool is_enabled = false;\nbool has_tail = true;\n</code></pre> <p>Afin de faciliter la lecture du code, il est courant de pr\u00e9fixer les variables bool\u00e9ennes avec les pr\u00e9fixes <code>is_</code> ou <code>has_</code>.</p> <p>\u00c0 titre d'exemple, si l'on souhaite stocker le genre d'un individu (m\u00e2le, ou femelle), on pourrait utiliser la variable <code>is_male</code>.</p>"}, {"location": "course-c/15-fundations/datatype/#enumerations", "title": "\u00c9num\u00e9rations", "text": "<p>Ce style d'\u00e9criture permet de d\u00e9finir un type de donn\u00e9es contenant un nombre fini de valeurs. Ces valeurs sont nomm\u00e9es textuellement et d\u00e9finies num\u00e9riquement dans le type \u00e9num\u00e9r\u00e9.</p> <pre><code>enum ColorCode {\n    COLOR_BLACK, // Vaut z\u00e9ro par d\u00e9faut\n    COLOR_BROWN,\n    COLOR_RED,\n    COLOR_ORANGE,\n    COLOR_YELLOW,\n    COLOR_GREEN,\n    COLOR_BLUE,\n    COLOR_PURPLE,\n    COLOR_GRAY,\n    COLOR_WHITE\n};\n</code></pre> <p>Le type d'une \u00e9num\u00e9ration est apparent\u00e9 \u00e0 un entier <code>int</code>. Sans autres pr\u00e9cisions, la premi\u00e8re valeur vaut 0, la suivante 1, etc.</p> <p>Il est possible de forcer les valeurs de la mani\u00e8re suivante\u2009:</p> <pre><code>typedef enum country_codes {\n    CODE_SWITZERLAND=41,\n    CODE_FRANCE=33,\n    CODE_US=1\n} CountryCodes;\n</code></pre> <p>ou encore\u2009:</p> <pre><code>typedef enum country_codes {\n    CODE_SWITZERLAND=41,\n    CODE_BELGIUM=32\n    CODE_FRANCE, // Sera 33...\n    CODE_SPAIN, // Sera 34...\n    CODE_US=1\n} CountryCodes;\n</code></pre> <p>Pour ne pas confondre un type \u00e9num\u00e9r\u00e9 avec une variable, on utilise souvent la convention d'une notation en capitales. Pour \u00e9viter d\u2019\u00e9ventuelles collisions avec d'autres types, un pr\u00e9fixe est souvent ajout\u00e9.</p> <p>L'utilisation d'un type \u00e9num\u00e9r\u00e9 peut \u00eatre la suivante\u2009:</p> <pre><code>void call(enum country_codes code) {\n    switch(code) {\n    case CODE_SWITZERLAND :\n        printf(\"Calling Switzerland, please wait...\\n\");\n        break;\n    case CODE_BELGIUM :\n        printf(\"Calling Belgium, please wait...\\n\");\n        break;\n    case CODE_FRANCE :\n        printf(\"Calling France, please wait...\\n\");\n        break;\n    default :\n        printf(\"No calls to this country are allowed yet!\\n\");\n    }\n}\n</code></pre>"}, {"location": "course-c/15-fundations/datatype/#type-incomplets", "title": "Type incomplets", "text": "<p>Un type incomplet est un qualificatif de type de donn\u00e9e d\u00e9crivant un objet dont sa taille en m\u00e9moire n'est pas connue.</p>"}, {"location": "course-c/15-fundations/datatype/#vlq", "title": "VLQ", "text": "<p>Dans certains syst\u00e8mes, on peut stocker des nombres entiers \u00e0 taille variables. C'est \u00e0 dire que l'on s'arrange pour r\u00e9server un bit suppl\u00e9mentaire dans le nombre pour indiquer si le nombre se poursuit sur un autre octet. C'est le cas des nombres entiers VLQ utilis\u00e9s dans le protocole MIDI.</p> <p>On peut stocker un nombre VLQ en m\u00e9moire, mais on ne sait pas de combien d'octets on aura besoin. On peut donc d\u00e9finir un type incomplet pour ce type de donn\u00e9e, mais nous aurons besoin de notions que nous n'avons pas encore vues pour le manipuler, les structures et les unions.</p>"}, {"location": "course-c/15-fundations/datatype/#type-vide-void", "title": "Type vide (void)", "text": "<p>Le type <code>void</code> est particulier. Il s'agit d'un type dit incomplet, car la taille de l'objet qu'il repr\u00e9sente en m\u00e9moire n'est pas connue. Il est utilis\u00e9 comme type de retour pour les fonctions qui ne retournent rien\u2009:</p> <pre><code>void shout() {\n    printf(\"Hey!\\n\");\n}\n</code></pre> <p>Il peut \u00eatre \u00e9galement utilis\u00e9 comme type g\u00e9n\u00e9rique comme la fonction de copie m\u00e9moire <code>memcpy</code></p> <pre><code>void *memcpy(void * restrict dest, const void * restrict src, size_t n);\n</code></pre> <p>Le mot cl\u00e9 <code>void</code> ne peut \u00eatre utilis\u00e9 que dans les contextes suivants\u2009:</p> <ul> <li>Comme param\u00e8tre unique d'une fonction, indiquant que cette fonction n'a pas de param\u00e8tres <code>int main(void)</code></li> <li>Comme type de retour pour une fonction indiquant que cette fonction ne retourne rien <code>void display(char c)</code></li> <li>Comme pointeur dont le type de destination n'est pas sp\u00e9cifi\u00e9 <code>void* ptr</code></li> </ul>"}, {"location": "course-c/15-fundations/datatype/#transtypage", "title": "Transtypage", "text": ""}, {"location": "course-c/15-fundations/datatype/#promotion-implicite", "title": "Promotion implicite", "text": "<p>G\u00e9n\u00e9ralement le type <code>int</code> est de la m\u00eame largeur que le bus m\u00e9moire de donn\u00e9e d'un ordinateur. C'est-\u00e0-dire que c'est souvent, le type le plus optimis\u00e9 pour v\u00e9hiculer de l'information au sein du processeur. Les registres du processeur, autrement dit ses casiers m\u00e9moires, sont au moins assez grand pour  contenir un <code>int</code>.</p> <p>Aussi, la plupart des types de taille inf\u00e9rieure \u00e0 <code>int</code> sont automatiquement et implicitement promus en <code>int</code>. Le r\u00e9sultat de <code>a + b</code> lorsque <code>a</code> et <code>b</code> sont des <code>char</code> sera automatiquement un <code>int</code>.</p>  Promotion num\u00e9rique Type source Type cible char int short int int long long float float double <p>Notez qu'il n'y a pas de promotion num\u00e9rique vers le type short. On passe directement \u00e0 un type int.</p> <p>Exercise\u2009: Expressions mixtes</p> <p>Soit les instructions suivantes\u2009:</p> <pre><code>int n = 10;\nint p = 7;\nfloat x = 2.5;\n</code></pre> <p>Donnez le type et la valeur des expressions suivantes\u2009:</p> <ol> <li><code>x + n % p</code></li> <li><code>x + p / n</code></li> <li><code>(x + p) / n</code></li> <li><code>.5 * n</code></li> <li><code>.5 * (float)n</code></li> <li><code>(int).5 * n</code></li> <li><code>(n + 1) / n</code></li> <li><code>(n + 1.0) / n</code></li> </ol> <p>Exercise\u2009: Promotion num\u00e9rique</p> <p>Repr\u00e9sentez les promotions num\u00e9riques qui surviennent lors de l'\u00e9valuation des expressions ci-dessous\u2009:</p> <pre><code>char c;\nshort sh;\nint i;\nfloat f;\ndouble d;\n</code></pre> <ol> <li><code>c * sh - f / i + d;</code></li> <li><code>c * (sh \u2013 f) / i + d;</code></li> <li><code>c * sh - f - i + d;</code></li> <li><code>c + sh * f / i + d;</code></li> </ol>"}, {"location": "course-c/15-fundations/datatype/#promotion-explicite", "title": "Promotion explicite", "text": "<p>Il est possible de forcer la promotion d'un type vers un autre en utilisant un transtypage explicite. Par exemple, pour forcer la promotion d'un <code>int</code> vers un <code>double</code> :</p> <pre><code>int n = 10;\ndouble x = (double)n;\n</code></pre> <p>Le changement de type forc\u00e9 (transtypage) entre des variables de diff\u00e9rents types engendre des effets de bord qu'il faut conna\u00eetre. Lors d'un changement de type vers un type dont le pouvoir de repr\u00e9sentation est plus important, il n'y a pas de probl\u00e8me. \u00c0 l'inverse, on peut rencontrer des erreurs sur la pr\u00e9cision ou une modification radicale de la valeur repr\u00e9sent\u00e9e\u2009!</p>"}, {"location": "course-c/15-fundations/datatype/#transtypage-dun-entier-en-flottant", "title": "Transtypage d'un entier en flottant", "text": "<p>Par exemple, la conversion d'un nombre flottant (double ou float) en entier (sign\u00e9) doit \u00eatre \u00e9tudi\u00e9e pour \u00e9viter tout probl\u00e8me. Le type entier doit \u00eatre capable de recevoir la valeur (attention aux valeurs maxi).</p> <pre><code>double d=3.9;\nlong l=(long)d; // valeur : 3 =&gt; perte de pr\u00e9cision\n</code></pre> <p>A l'ex\u00e9cution, la valeur de \\(l\\) sera la partie enti\u00e8re de \\(d\\). Il n'y a pas d'arrondi.</p> <pre><code>double d=0x12345678;\nshort sh=(short)d; // valeur : 0x5678 =&gt; changement de valeur\n</code></pre> <p>La variable sh (short sur 16 bit) ne peut contenir la valeur r\u00e9elle. Lors du transtypage, il y a modification de la valeur ce qui conduit \u00e0 des erreurs de calculs par la suite.</p> <pre><code>double d=-123;\nunsigned short sh=(unsigned short)d; // valeur : 65413 =&gt; changement de valeur\n</code></pre> <p>L'utilisation d'un type non sign\u00e9 pour convertir un nombre r\u00e9el conduit \u00e9galement \u00e0 une modification de la valeur num\u00e9rique.</p>"}, {"location": "course-c/15-fundations/datatype/#transtypage-dun-double-en-float", "title": "Transtypage d'un double en float", "text": "<p>La conversion d'un nombre r\u00e9el de type double en r\u00e9el de type float pose un probl\u00e8me de pr\u00e9cision de calcul.</p> <pre><code>double d=0.1111111111111111;\nfloat f=(float)d; // valeur : 0.1111111119389533 =&gt; perte de pr\u00e9cision\n</code></pre> <p>\u00c0 l'ex\u00e9cution, il y a une perte de pr\u00e9cision lors de la conversion, ce qui peut, lors d'un calcul it\u00e9ratif induire des erreurs de calcul.</p> <p>Exercise\u2009: Conversion de types</p> <p>On consid\u00e8re les d\u00e9clarations suivantes\u2009:</p> <pre><code>float x;\nshort i;\nunsigned short j;\nlong k;\nunsigned long l;\n</code></pre> <p>Identifiez les expressions ci-dessous dont le r\u00e9sultat n'est pas math\u00e9matiquement correct.</p> <pre><code>x = 1e6;\ni = x;\nj = -20;\nk = x;\nl = k;\nk = -20;\nl = k;\n</code></pre> Solution <pre><code>x = 1e6;\ni = x;    // Incorrect, i peut-\u00eatre limit\u00e9 \u00e0 -32767..+32767 (C99 \u00a75.2.4.2.1)\nj = -20;  // Incorrect, valeur sign\u00e9e dans un conteneur non sign\u00e9\nk = x;\nl = k;\nk = -20;\nl = k;    // Incorrect, valeur sign\u00e9e dans un conteneur non sign\u00e9\n</code></pre> <p>Exercise\u2009: Un casting explicite</p> <p>Que valent les valeurs de <code>p</code>, <code>x</code> et <code>n</code>:</p> <pre><code>float x;\nint n, p;\n\np = 2;\nx = (float)15 / p;\nn = x + 1.1;\n</code></pre> Solution <pre><code>p \u2261 2\nx = 7.5\nn = 8\n</code></pre> <p>Exercise\u2009: Op\u00e9rateurs de relation et op\u00e9rateurs logiques</p> <p>Soit les d\u00e9clarations suivantes\u2009:</p> <pre><code>float x, y;\nbool condition;\n</code></pre> <p>R\u00e9\u00e9crire l'expression ci-dessous en mettant des parenth\u00e8ses montrant l'ordre des op\u00e9rations\u2009:</p> <pre><code>condition = x &gt;= 0 &amp;&amp; x &lt;= 20 &amp;&amp; y &gt; x || y == 50 &amp;&amp; x == 2 || y == 60;\n</code></pre> <p>Donner la valeur de <code>condition</code> \u00e9valu\u00e9e avec les valeurs suivantes de <code>x</code> et <code>y</code>:</p> <ol> <li><code>x = -1.0; y = 60.;</code></li> <li><code>x = 0; y = 1.;</code></li> <li><code>x = 19.0; y = 1.0;</code></li> <li><code>x = 0.0; y = 50.0;</code></li> <li><code>x = 2.0; y = 50.0;</code></li> <li><code>x = -10.0; y = 60.0;</code></li> </ol> Solution <pre><code>condition = (\n    (x &gt;= 0) &amp;&amp; (x &lt;= 20) &amp;&amp; (y &gt; x))\n    ||\n    ((y == 50) &amp;&amp; (x == 2))\n    ||\n    (y == 60)\n);\n</code></pre> <ol> <li><code>true</code></li> <li><code>true</code></li> <li><code>false</code></li> <li><code>true</code></li> <li><code>true</code></li> <li><code>true</code></li> </ol> <p>Exercise\u2009: Casse-t\u00eate</p> <p>Vous participez \u00e0 une revue de code et tombez sur quelques perles laiss\u00e9es par quelques coll\u00e8gues. Comment proposeriez-vous de corriger ces \u00e9critures\u2009? Le code est \u00e9crit pour un mod\u00e8le de donn\u00e9e LLP64.</p> <p>Pour chaque exemple, donner la valeur des variables apr\u00e8s ex\u00e9cution du code.</p> <ol> <li> <p> </p> <pre><code>unsigned short i = 32767;\ni++;\n</code></pre> </li> <li> <p> </p> <pre><code>short i = 32767;\ni++;\n</code></pre> </li> <li> <p> </p> <pre><code>short i = 0;\ni = i--;\ni = --i;\ni = i--;\n</code></pre> </li> </ol>"}, {"location": "course-c/15-fundations/datatype/#exercices-de-revision", "title": "Exercices de r\u00e9vision", "text": "<p>Exercise\u2009: \u00c9valuation d'expressions</p> <p>Consid\u00e9rons les d\u00e9clarations suivantes\u2009:</p> <pre><code>char c = 3;\nshort s = 7;\nint i = 3;\nlong l = 4;\nfloat f = 3.3;\ndouble d = 7.7;\n</code></pre> <p>Que vaut le type et la valeur des expressions suivantes\u2009?</p> <ol> <li><code>c / 2</code></li> <li><code>sh + c / 10</code></li> <li><code>lg + i / 2.0</code></li> <li><code>d + f</code></li> <li><code>(int)d + f</code></li> <li><code>(int)d + lg</code></li> <li><code>c &lt;&lt; 2</code></li> <li><code>sh &amp; 0xF0</code></li> <li><code>sh &amp;&amp; 0xF0</code></li> <li><code>sh == i + lg</code></li> <li><code>d + f == sh + lg</code></li> </ol> <p>Exercise\u2009: Pr\u00e9cision des flottants</p> <p>Que vaut <code>x</code>?</p> <pre><code>float x = 10000000. + 0.1;\n</code></pre> Solution <p>Le format float est stock\u00e9 sur 32-bits avec 23-bits de mantisse et 8-bits d'exposants. Sa pr\u00e9cision est donc limit\u00e9e \u00e0 environ 6 d\u00e9cimales. Pour repr\u00e9senter 10'000'000.1 il faut plus que 6 d\u00e9cimales et l'addition est donc caduc\u2009:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    float x = 10000000. + 0.1;\n    printf(\"%f\\n\", x);\n}\n</code></pre> <pre><code>$ ./a.out\n10000000.000000\n</code></pre> <p>Exercise\u2009: Type de donn\u00e9e idoine</p> <p>Pour chaque entr\u00e9e suivante, indiquez le nom et le type des variables que vous utiliseriez pour repr\u00e9senter les donn\u00e9es dans ce programme\u2009:</p> <ol> <li>Gestion d'un parking\u2009: nombre de voitures pr\u00e9sente</li> <li>Station m\u00e9t\u00e9o     a. Temp\u00e9rature moyenne de la journ\u00e9e     b. Nombre de valeurs utilis\u00e9es pour la moyenne</li> <li>Montant disponible sur un compte en banque</li> <li>Programme de calcul de d'\u00e9nergie produite dans une centrale nucl\u00e9aire</li> <li>Programme de conversion d\u00e9cimal, hexad\u00e9cimal, binaire</li> <li>Produit scalaire de deux vecteurs plans</li> <li>Nombre d'impulsions re\u00e7ues par un capteur de position incr\u00e9mental</li> </ol> <p>Exercise\u2009: Construction d'expressions</p> <p>On consid\u00e8re un disque, divis\u00e9 en 12 secteurs angulaires \u00e9gaux, num\u00e9rot\u00e9s de 0 \u00e0 11. On mesure l\u2019angle de rotation du disque en degr\u00e9s, sous la forme d\u2019un nombre entier non sign\u00e9. Une fl\u00e8che fixe d\u00e9signe un secteur. Entre 0 et 29 \u00b0, le secteur d\u00e9sign\u00e9 est le n\u00b0 0, entre 30 \u00b0 et 59 \u00b0, c\u2019est le secteur 1, ...</p> <p>Donnez une expression arithm\u00e9tique permettant, en fonction d\u2019un angle donn\u00e9, d\u2019indiquer quel est le secteur du disque se trouve devant la fl\u00e8che. Note\u2009: l\u2019angle de rotation peut \u00eatre sup\u00e9rieur \u00e0 360 \u00b0. V\u00e9rifiez cette expression avec les angles de 0, 15, 29, 30, 59, 60, 360, 389, 390 degr\u00e9s.</p> <p>\u00c9crivez un programme demandant l\u2019angle et affichant le num\u00e9ro de secteur correspondant.</p> <p>Exercise\u2009: Somme des entiers</p> <p>Il est prouv\u00e9 math\u00e9matiquement que la somme des entiers strictement positifs pris dans l'ordre croissant peut \u00eatre exprim\u00e9e comme\u2009:</p> \\[ \\sum_{k=1}^n k = \\frac{n(n+1)}{2} \\] <p>\u0b9a\u0bc0\u0ba9\u0bbf\u0bb5\u0bbe\u0b9a \u0b87\u0bb0\u0bbe\u0bae\u0bbe\u0ba9\u0bc1\u0b9c\u0ba9\u0bcd, un grand math\u00e9maticien (Srinivasa Ramanujan) \u00e0 d\u00e9montr\u00e9 que ce la somme \u00e0 l'infini donne\u2009:</p> \\[ \\sum_{k=1}^{\\inf} k = -\\frac{1}{12} \\] <p>Vous ne le croyez pas et d\u00e9cider d'utiliser le superordinateur Pens\u00e9es Profondes pour faire ce calcul. Comme vous n'avez pas acc\u00e8s \u00e0 cet ordinateur pour l'instant (et probablement vos enfants n'auront pas acc\u00e8s \u00e0 cet ordinateur non plus), \u00e9crivez un programme simple pour tester votre algorithme et prenant en param\u00e8tre la valeur <code>n</code> \u00e0 laquelle s'arr\u00eater.</p> <p>Tester ensuite votre programme avec des valeurs de plus en plus grandes et analyser les performances avec le programme <code>time</code>:</p> <pre><code>$ time ./a.out 1000000000\n500000000500000000\n\nreal    0m0.180s\nuser    0m0.172s\nsys     0m0.016s\n</code></pre> <p>\u00c0 partir de quelle valeur, le temps de calcul devient significativement palpable\u2009?</p> Solution <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, char *argv[]) {\n    long long n = atoi(argv[1]);\n    long long sum = 0;\n    for(size_t i = 0; i &lt; n; i++, sum += i);\n    printf(\"%lld\\n\", sum);\n}\n</code></pre> <p>Exercise\u2009: Syst\u00e8me de vision industriel</p> <p>La soci\u00e9t\u00e9 japonaise Nakain\u0153il d\u00e9veloppe des syst\u00e8mes de vision industriels pour l'inspection de pi\u00e8ces dans une ligne d'assemblage. Le programme du syst\u00e8me de vision comporte les variables internes suivantes\u2009:</p> <pre><code>uint32_t inspected_parts, bad_parts;\nfloat percentage_good_parts;\n</code></pre> <p>\u00c0 un moment du programme, on peut lire\u2009:</p> <pre><code>percentage_good_parts = (inspected_parts - bad_parts) / inspected_parts;\n</code></pre> <p>Sachant que <code>inspected_parts = 2000</code> et <code>bad_parts = 200</code>:</p> <ol> <li>Quel r\u00e9sultat le d\u00e9veloppeur s'attend-il \u00e0 obtenir\u2009?</li> <li>Qu'obtient-il en pratique\u2009?</li> <li>Pourquoi\u2009?</li> <li>Corrigez les \u00e9ventuelles erreurs.</li> </ol> Solution <ol> <li>Le d\u00e9veloppeur s'attend \u00e0 obtenir le pourcentage de bonnes pi\u00e8ces avec plusieurs d\u00e9cimales apr\u00e8s la virgule.</li> <li>En pratique, il obtient un entier, c'est \u00e0 dire toujours 0.</li> <li> <p>La promotion implicite des entiers peut \u00eatre d\u00e9coup\u00e9e comme suit\u2009:</p> <pre><code>(uint32_t)numerator = (uint32_t)inspected_parts - (uint32_t)bad_parts;\n(uint32_t)percentage = (uint32_t)numerator / (uint32_t)inspected_parts;\n(float)percentage_good_parts = (uint32_t)percentage;\n</code></pre> </li> </ol> <p>La division est donc appliqu\u00e9e \u00e0 des entiers et non des flottants.</p> <ol> <li> <p>Une possible correction consiste \u00e0 forcer le type d'un des membres de la division\u2009:</p> <pre><code>percentage_good_parts = (float)(inspected_parts - bad_parts) / inspected_parts;\n</code></pre> </li> </ol> <p>Exercise\u2009: Missile Patriot</p> <p>Durant la guerre du Golfe le 25 f\u00e9vrier 1991, une batterie de missile am\u00e9ricaine \u00e0 Dharan en Arabie saoudite \u00e0 \u00e9chou\u00e9 \u00e0 intercepter un missile irakien Scud. Cet \u00e9chec tua 28 soldats am\u00e9ricains et en blessa 100 autres. L'erreur sera imput\u00e9e \u00e0 un probl\u00e8me de type de donn\u00e9e sera longuement discut\u00e9e dans le rapport GAO/OMTEC-92-26 du commandement g\u00e9n\u00e9ral.</p> <p>Un registre 24-bit est utilis\u00e9 pour le stockage du temps \u00e9coul\u00e9 depuis le d\u00e9marrage du logiciel de contr\u00f4le indiquant le temps en dixi\u00e8me de secondes. D\u00e8s lors il a fallait multiplier ce temps par 1/10 pour obtenir le temps en seconde. La valeur 1/10 \u00e9tait tronqu\u00e9e \u00e0 la 24^e d\u00e9cimale apr\u00e8s la virgule. Des erreurs d'arrondi sont apparue menant \u00e0 un d\u00e9calage de pr\u00e8s de 1 seconde apr\u00e8s 100 heures de fonction. Or, cette erreur d'une seconde s'est traduite par 600 m\u00e8tres d'erreur lors de la tentative d'interception.</p> <p>Le stockage de la valeur 0.1 est donn\u00e9 par\u2009:</p> \\[ 0.1_{10} \\approx \\lfloor 0.1_{10}\\cdot 2^{23} \\rfloor = 11001100110011001100_{2} \\approx 0.09999990463256836 \\] <p>Un registre contient donc le nombre d'heures \u00e9coul\u00e9es exprim\u00e9es en dixi\u00e8me de seconde soit pour 100 heures\u2009:</p> \\[ 100 \\cdot 60 \\cdot 60 \\cdot 10 = 3'600'000 \\] <p>En termes de virgule fixe, la premi\u00e8re valeur est exprim\u00e9e en Q1.23 tandis que la seconde en Q0.24. Multiplier les deux valeurs entre elles donne <code>Q1.23 x Q0.24 = Q1.47</code> le r\u00e9sultat est donc exprim\u00e9 sur 48 bits. Il faut donc diviser le r\u00e9sultat du calcul par :math\u2009:<code>2^{47}</code> pour obtenir le nombre de secondes \u00e9coul\u00e9es depuis le d\u00e9but la mise sous tension du syst\u00e8me.</p> <p>Quel est l'erreur en seconde cumul\u00e9e sur les 100 heures de fonctionnement\u2009?</p>"}, {"location": "course-c/15-fundations/functions/", "title": "Fonctions", "text": "<p> Margaret Hamilton, directrice projet AGC (1969), photo du MIT Museum</p> <p>Margaret Hamilton la directrice du projet Apollo Guidance Computer (AGC) \u00e0 c\u00f4t\u00e9 du code du projet.</p> <p>\u00c0 l'\u00e9poque d'Apollo 11, les fonctions n'existaient pas, le code n'\u00e9tait qu'une suite monolithique d'instruction \u00e9sot\u00e9rique dont les sources du Apollo Guidance Computer ont \u00e9t\u00e9 publi\u00e9es sur GitHub. Le langage est l'assembler yaYUL dispose de sous-routines, ou proc\u00e9dures qui sont des fonctions sans param\u00e8tres. Ce type de langage est proc\u00e9dural.</p> <p>N\u00e9anmoins, dans ce langage assembleur \u00e9trange, le code reste monolithique et toutes les variables sont globales.</p> <p>Un programme convenablement structur\u00e9 est d\u00e9coup\u00e9 en \u00e9l\u00e9ments fonctionnels qui disposent pour chacun d'entr\u00e9es et de sorties. De la m\u00eame mani\u00e8re qu'un t\u00e9lenc\u00e9phale hautement d\u00e9velopp\u00e9 et son pouce pr\u00e9henseur aime organiser sa maison en pi\u00e8ces d\u00e9di\u00e9es \u00e0 des occupations particuli\u00e8res et que chaque pi\u00e8ce dispose de rangements assign\u00e9s les uns \u00e0 des assiettes, les autres \u00e0 des couverts, le d\u00e9veloppeur organisera son code en blocs fonctionnels et cherchera \u00e0 minimiser les effets de bord.</p> <p> Agencement de fonctions</p> <p>Une fonction est donc un ensemble de code ex\u00e9cutable d\u00e9limit\u00e9 du programme principal et disposant\u2009:</p> <ul> <li>D'un identifiant unique</li> <li>D'une valeur de retour</li> <li>De param\u00e8tres d'appel</li> </ul> <p>L'utilisation des fonctions permet\u2009:</p> <ul> <li>De d\u00e9composer un programme complexe en t\u00e2ches plus simples</li> <li>De r\u00e9duire la redondance de code</li> <li>De maximiser la r\u00e9utilisation du code</li> <li>De s'abstraire des d\u00e9tails d'impl\u00e9mentation</li> <li>D'augmenter la lisibilit\u00e9 du code</li> <li>D'accro\u00eetre la tra\u00e7abilit\u00e9 \u00e0 l'ex\u00e9cution</li> </ul> <p>En revanche, une fonction apporte quelques d\u00e9savantages qui \u00e0 l'\u00e9chelle des ordinateurs moderne sont parfaitement n\u00e9gligeables. L'appel \u00e0 une fonction ou sous-routine requiert du housekeeping, qui se compose d'un pr\u00e9lude et d'un aboutissant et dans lequel le contexte doit \u00eatre sauvegard\u00e9.</p>"}, {"location": "course-c/15-fundations/functions/#conventions-dappel", "title": "Conventions d'appel", "text": "<p>Dans le Voyage de Chihiro (\u5343\u3068\u5343\u5c0b\u306e\u795e\u96a0\u3057) de Hayao Miyazaki, le vieux Kamaji (\u91dc\u723a) travaille dans la chaudi\u00e8re des bains pour l'alimenter en charbon et pr\u00e9parer les d\u00e9coctions d'herbes pour parfumer les bains des clients.</p> <p> Le vieux Kamaji et ses bras extensibles.</p> <p>Je vous propose de b\u00e2tir une m\u00e9taphore du changement de contexte en s'inspirant de cette illustration. Les murs de la chaudi\u00e8re sont emplis de casiers contenant diff\u00e9rentes herbes, ces casiers peuvent \u00eatre apparent\u00e9s \u00e0 la m\u00e9moire de l'ordinateur, et les diff\u00e9rentes herbes, des types de donn\u00e9es diff\u00e9rents. De son pupitre Kamaji dispose de plusieurs mortiers dans lequel il m\u00e9lange les herbes\u2009; ils sont \u00e0 l'instar de l'ALU d'un ordinateur le si\u00e8ge d'op\u00e9rations transformant, \u00e0 l'aide du pilon, plusieurs entr\u00e9es en une seule sortie\u2009: le m\u00e9lange d'herbes servant \u00e0 la d\u00e9coction. Bien qu'il ait six bras et afin de s'\u00e9viter des manipulations inutiles, il garde de petites r\u00e9serves d'herbes \u00e0 c\u00f4t\u00e9 de son pupitre dans de petits casiers, similaires aux registres du processeur.</p> <p>Il profite de son temps libre, pendant que les bains sont ferm\u00e9s pour pr\u00e9parer certains m\u00e9langes d'herbes les plus populaires et il place ce stock dans un casier du mur. Pr\u00e9parer un m\u00e9lange est tr\u00e8s similaire \u00e0 un programme informatique dans lequel une suite d'op\u00e9ration repr\u00e9sente une recette donn\u00e9e. Le vieux Kamaji \u00e0 une tr\u00e8s grande m\u00e9moire, et il ne dispose pas de livre de recettes, mais vous, moi, n'importe qui, aurions besoin d'instructions claires du type\u2009:</p> <pre><code>AUTUMN_TONIC_TEA :\n\n  MOVE  R1 @B4      # D\u00e9place de la grande ortie du casier B4 au registre R1\n  MOVE  R2 @A8      # D\u00e9place la menthe verte (Mentha spicata) du casier\n                    # A8 au registre R2\n  MOVE  R3 @C7      # D\u00e9place le gingembre du casier C7 au registre R3\n  ...\n  CHOP  R4 R3, FINE # Coupe tr\u00e8s finement le gingembre et le place dans R4\n  ...\n  LEAV  R2 R5       # D\u00e9tache les feuilles des tiges de la menthe\n                    # verte, place les feuilles en R5\n  ...\n  ADD   R8 R1 R5    # Pilonne le contenu de R1 et R2 et place dans R8\n  ADD   R8 R8 R4\n  ...\n  STO   R8 @F6      # Place le m\u00e9lange d'herbe automnale tonic dans le casier F6\n</code></pre> <p>Souvent, le vieux Kamaji r\u00e9p\u00e8te les m\u00eames suites d'op\u00e9ration et ce, peu importe les herbes qu'il manipule, une fois plac\u00e9es dans les petits casiers (registres), il pourrait travailler les yeux ferm\u00e9s.</p> <p>On pourrait r\u00e9sumer ce travail par une fonction C, ici prenant un rhizome et deux herbes en entr\u00e9e et g\u00e9n\u00e9rant un m\u00e9lange en sortie.</p> <pre><code>blend slice_and_blend(rootstock a, herb b, herb c);\n</code></pre> <p>Pour des recettes complexes, il se pourrait que la fonction <code>slice_and_blend</code> soit appel\u00e9e plusieurs fois \u00e0 la suite, mais avec des ingr\u00e9dients diff\u00e9rents. De m\u00eame que cette fonction fait appel \u00e0 une autre fonction plus simple tel que <code>slice</code> (d\u00e9couper) ou <code>blend_together</code> (incorporer).</p> <p>Et le contexte dans tout cela\u2009? Il existe selon le langage de programmation et l'architecture processeur ce que l'on appelle les conventions d'appel. C'est-\u00e0-dire les r\u00e8gles qui r\u00e9gissent les interactions entre les appels de fonctions. Dans notre exemple, on adoptera peut-\u00eatre la convention que n'importe quelle fonction trouvera ses ingr\u00e9dients d'entr\u00e9es dans les casiers R1, R2 et R3 et que le r\u00e9sultat de la fonction, ici le blend, sera plac\u00e9 dans le casier R8. Ainsi peu importe les herbes en entr\u00e9e, le vieux Kamaji peut travailler les yeux ferm\u00e9s, piochant simplement dans R1, R2 et R3.</p> <p>On observe n\u00e9anmoins dans la recette \u00e9voqu\u00e9e plus haut qu'il utilise d'autres casiers, R4, et R5. Il faut donc faire tr\u00e8s attention \u00e0 ce qu'une autre fonction peut-\u00eatre la fonction <code>slice</code>, n'utilise pas dans sa propre recette le casier R5, car sinon, c'est la catastrophe.</p> <pre><code>herb slice(herb a);\n</code></pre> <p>Kamaji entrepose temporairement les feuilles de menthe verte dans R5 et lorsqu'il en a besoin, plus tard, apr\u00e8s avoir d\u00e9coup\u00e9 les fleurs de mol\u00e8ne que R5 contient des tiges d'une autre plante.</p> <p>Dans les conventions d'appel, il faut donc \u00e9galement donner la responsabilit\u00e9 \u00e0 quelqu'un de ne pas utiliser certains casiers, ou alors d'en sauvegarder ou de restaurer le contenu au d\u00e9but et \u00e0 la fin de la recette. Dans les conventions d'appel, il y a en r\u00e9alit\u00e9 plusieurs cat\u00e9gories de registres\u2009:</p> <ul> <li>ceux utilis\u00e9s pour les param\u00e8tres de la fonction,</li> <li>ceux utilis\u00e9s pour les valeurs de retour,</li> <li>ceux qui peuvent \u00eatre utilis\u00e9s librement par une fonction (la sauvegarde est \u00e0 la charge du caller, la fonction qui appelle une autre fonction),</li> <li>ceux qui doivent \u00eatre sauvegard\u00e9s par le callee (la fonction qui est appel\u00e9e).</li> </ul> <p>En C, ce m\u00e9canisme est parfaitement automatique, le programmeur n'a pas \u00e0 se soucier du processeur, du nom des registres, de la correspondance entre le nom des herbes et le casier ou elles sont entrepos\u00e9es. N\u00e9anmoins, l'\u00e9lectronicien d\u00e9veloppeur, proche du mat\u00e9riel, doit parfois bien comprendre ces m\u00e9canismes et ce qu'ils co\u00fbtent (en temps et en place m\u00e9moire) \u00e0 l'ex\u00e9cution d'un programme.</p>"}, {"location": "course-c/15-fundations/functions/#overhead", "title": "Overhead", "text": "<p>L'appel de fonction co\u00fbte \u00e0 l'ex\u00e9cution, car avant chaque fonction, le compilateur ajoute automatiquement des instructions de sauvegarde et de restauration des registres utilis\u00e9s\u2009:</p> <p> Sauvegarde des registres du processeur et convention d'appel de fonction.</p> <p>Ce co\u00fbt est faible, tr\u00e8s faible, un ordinateur fonctionnant \u00e0 3 GHz et une fonction complexe utilisant tous les registres disponibles, mettons 10 registres, consommera entre l'appel de la fonction et son retour 0.000'000'003 seconde, \u00e7a va, c'est raisonnable. Sauf que, si la fonction ne comporte qu'une seule op\u00e9ration comme ci-dessous, l'overhead sera aussi plus faible.</p> <pre><code>int add(int a, int b) {\n    return a + b;\n}\n</code></pre>"}, {"location": "course-c/15-fundations/functions/#stack", "title": "Stack", "text": "<p>En fran\u00e7ais la pile d'ex\u00e9cution, est un emplacement m\u00e9moire utilis\u00e9 pour sauvegarder les registres du processeur entre les appels de fonctions, sauvegarder les adresses de retour des fonctions qui sont analogue \u00e0 sauvegarder le num\u00e9ro de page du livre de recettes\u2009: p 443. Recette du Bras de V\u00e9nus\u2009: commencer par r\u00e9aliser une g\u00e9noise de 300g (p. 225). Une fois la g\u00e9noise termin\u00e9e, il faut se rappeler de retourner \u00e0 la page 443. Enfin le stack est utilis\u00e9 pour m\u00e9moriser les param\u00e8tres des fonctions suppl\u00e9mentaires qui ne tiendraient pas dans les registres d'entr\u00e9es. La convention d'appel de la plupart des architectures pr\u00e9voit g\u00e9n\u00e9ralement 3 registres pour les param\u00e8tres d'entr\u00e9es, si bien qu'une fonction \u00e0 4 param\u00e8tres pourrait bien aussi utiliser le stack:</p> <pre><code>double quaternion_norm(double a1, double b1, double c1, double d1);\n</code></pre> <p>La pile d'ex\u00e9cution est, comme son nom l'indique, une pile sur laquelle sont empil\u00e9s et d\u00e9pil\u00e9s les \u00e9l\u00e9ments au besoin. \u00c0 chaque appel d'une fonction, la valeur des registres \u00e0 sauvegarder est empil\u00e9e et au retour d'une fonction les registres sont d\u00e9pil\u00e9s si bien que la fonction d'appel retrouve le stack dans le m\u00eame \u00e9tat qu'il \u00e9tait avant l'appel d'une fonction enfant.</p>"}, {"location": "course-c/15-fundations/functions/#prototype", "title": "Prototype", "text": "<p>Le prototype d'une fonction est son interface avec le monde ext\u00e9rieur. Il d\u00e9clare la fonction, son type de retour et ses param\u00e8tres d'appel. Le prototype est souvent utilis\u00e9 dans un fichier d'en-t\u00eate pour construire des biblioth\u00e8ques logicielles. La fonction <code>printf</code> que nous ne cessons pas d'utiliser voit son prototype r\u00e9sider dans le fichier <code>&lt;stdio.h&gt;</code> et il est d\u00e9clar\u00e9 sous la forme\u2009:</p> <pre><code>\u200bint printf(const char* format, ...);\n</code></pre> <p>Notons qu'il n'y a pas d'accolades ici.</p> <p>Rappelons-le, C est un langage imp\u00e9ratif et d\u00e9claratif, c'est-\u00e0-dire que les instructions sont s\u00e9quentielles et que les d\u00e9clarations du code sont interpr\u00e9t\u00e9es dans l'ordre ou elles apparaissent. Si bien si je veux appeler la fonction <code>make_coffee</code>, il faut qu'elle ait \u00e9t\u00e9 d\u00e9clar\u00e9e avant, c'est \u00e0 dire plus haut.</p> <p>Le code suivant fonctionne\u2009:</p> <pre><code>int make_coffee(void) {\n    printf(\"Please wait...\\n)\";\n}\n\nint main(void) {\n    make_coffee();\n}\n</code></pre> <p>Mais celui-ci ne fonctionnera pas, car <code>make_coffee</code> n'est pas connu au moment de l'appel\u2009:</p> <pre><code>int main(void) {\n    make_coffee();\n}\n\nint make_coffee(void) {\n    printf(\"Please wait...\\n)\";\n}\n</code></pre> <p>Si pour une raison connue seule du d\u00e9veloppeur on souhaite d\u00e9clarer la fonction apr\u00e8s <code>main</code>, on peut ajouter le prototype de la fonction avant cette derni\u00e8re. C'est ce que l'on appelle la d\u00e9claration avanc\u00e9e ou forward declaration.</p> <pre><code>int make_coffee(void);\n\nint main(void) {\n    make_coffee();\n}\n\nint make_coffee(void) {\n    printf(\"Please wait...\\n\");\n}\n</code></pre> <p>Un prototype de fonction diff\u00e8re de son impl\u00e9mentation par le fait qu'il ne dispose pas du code, mais simplement sa d\u00e9finition, permettant au compilateur d'\u00e9tablir les conventions d'appel  de la fonction.</p>"}, {"location": "course-c/15-fundations/functions/#syntaxe", "title": "Syntaxe", "text": "<p>La syntaxe d'\u00e9criture d'une fonction peut \u00eatre assez compliqu\u00e9e et la source de v\u00e9rit\u00e9 est issue de la grammaire du langage, qui n'est pas n\u00e9cessairement accessible au profane. Or, depuis C99, une fonction prend la forme\u2009:</p> <pre><code>&lt;storage-class&gt; &lt;return-type&gt; &lt;function-name&gt; (\n    &lt;parameter-type&gt; &lt;parameter-name&gt;, ... )\n</code></pre> <code>&lt;storage-class&gt;</code> <p>Classe de stockage, elle n'est pas utile \u00e0 ce stade du cours, nous aborderons plus tard les mots cl\u00e9s <code>extern</code>, <code>static</code> et <code>inline</code>.</p> <code>&lt;return-type&gt;</code> <p>Le type de retour de la fonction, s'agit-il d'un <code>int</code>, d'un <code>float</code> ? Le type de retour est anonyme, il n'a pas de nom et ce n'est pas n\u00e9cessaire.</p> <code>&lt;function-name&gt;</code> <p>Il s'agit d'un identificateur qui repr\u00e9sente le nom de la fonction. G\u00e9n\u00e9ralement on pr\u00e9f\u00e8re choisir un verbe, quelquefois associ\u00e9 \u00e0 un nom\u2009: <code>compute_norm</code>, <code>make_coffee</code>, ... N\u00e9anmoins, lorsqu'il n'y a pas d'ambig\u00fcit\u00e9, on peut choisir des termes plus simples tels que <code>main</code>, <code>display</code> ou <code>dot_product</code>.</p> <code>&lt;parameter-type&gt; &lt;parameter-name&gt;</code> <p>La fonction peut prendre en param\u00e8tre z\u00e9ro \u00e0 plusieurs param\u00e8tres o\u00f9 chaque param\u00e8tre est d\u00e9fini par son type et son nom tel que\u2009: <code>double real, double imag</code> pour une fonction qui prendrait en param\u00e8tre un nombre complexe.</p> <p>Apr\u00e8s la fermeture de la parenth\u00e8se de la liste des param\u00e8tres, deux possibilit\u00e9s\u2009:</p> Prototype <p>On clos la d\u00e9claration avec un <code>;</code></p> Impl\u00e9mentation <p>On poursuit avec l'impl\u00e9mentation du code <code>{ ... }</code></p>"}, {"location": "course-c/15-fundations/functions/#void", "title": "void", "text": "<p>Le type <code>void</code> est \u00e0 une signification particuli\u00e8re dans la syntaxe d'une fonction. Il peut \u00eatre utilis\u00e9 de trois mani\u00e8res diff\u00e9rentes\u2009:</p> <ul> <li> <p>Pour indiquer l'absence de valeur de retour\u2009:</p> <pre><code>void foo(int a, int b);\n</code></pre> </li> <li> <p>Pour indiquer l'absence de param\u00e8tres\u2009:</p> <pre><code>int bar(void);\n</code></pre> </li> <li> <p>Pour indiquer que la valeur de retour n'est pas utilis\u00e9e par le parent\u2009:</p> <pre><code>(void) foo(23, 11);\n</code></pre> </li> </ul> <p>La d\u00e9claration suivante est formellement fausse, car la fonction ne poss\u00e8de pas un prototype complet. En effet, le nombre de param\u00e8tres n'est pas contraint et le code suivant est valide au sens de C99.</p> <pre><code>void dummy() {}\n\nint main(void) {\n    dummy(1, 2, 3);\n    dummy(120, 144);\n}\n</code></pre> <p>Aussi, il est imp\u00e9ratif de toujours \u00e9crire des prototypes complets et d'explicitement utiliser <code>void</code> lorsque la fonction ne prend aucun param\u00e8tre en entr\u00e9e. Si vous utilisez un compilateur C++, une d\u00e9claration incompl\u00e8te g\u00e9n\u00e8rera une erreur.</p>"}, {"location": "course-c/15-fundations/functions/#parametres", "title": "Param\u00e8tres", "text": "<p>Comme nous l'avons vu plus haut, pour de meilleures performances \u00e0 l'ex\u00e9cution, il est pr\u00e9f\u00e9rable de s'en tenir \u00e0 un maximum de trois param\u00e8tres, c'est \u00e9galement plus lisible pour le d\u00e9veloppeur, mais rien n'emp\u00eache d'en avoir plus.</p> <p>En plus de cela, les param\u00e8tres peuvent \u00eatre pass\u00e9s de deux mani\u00e8res\u2009:</p> <ul> <li>Par valeur</li> <li>Par r\u00e9f\u00e9rence</li> </ul> <p>En C, fondamentalement, tous les param\u00e8tres sont pass\u00e9s par valeur, c'est-\u00e0-dire que la valeur d'une variable est copi\u00e9e \u00e0 l'appel de la fonction. Dans l'exemple suivant, la valeur affich\u00e9e sera bel et bien <code>33</code> et non. <code>42</code></p> <pre><code>void alter(int a) {\n    a = a + 9;\n}\n\nvoid main(void) {\n    int a = 33;\n    alter(a);\n    printf(\"%d\\n\", a);\n}\n</code></pre> <p>Dans certains cas, on souhaite utiliser plus d'une valeur de retour et l'on peut utiliser un tableau. Dans l'exemple suivant, la valeur affich\u00e9e sera cette fois-ci <code>42</code> et non <code>33</code>.</p> <pre><code>void alter(int array[]) {\n    array[0] += 9;\n}\n\nvoid main(void) {\n    int array[] = {33, 34, 35};\n    alter(array);\n    printf(\"%d\\n\", array[0]);\n}\n</code></pre> <p>Par abus de langage et en comparaison avec d'autres langages de programmation, on appellera ceci un passage par r\u00e9f\u00e9rence, car ce n'est pas une copie du tableau qui est pass\u00e9e \u00e0 la fonction <code>alter</code>, mais seulement une r\u00e9f\u00e9rence sur ce tableau.</p> <p>En des termes plus corrects, mais nous verrons cela au chapitre sur les pointeurs, c'est bien un passage par valeur dans lequel la valeur d'un pointeur sur un tableau est pass\u00e9e \u00e0 la fonction <code>alter</code>.</p> <p>Retenez simplement que lors d'un passage par r\u00e9f\u00e9rence, on cherche \u00e0 rendre la valeur pass\u00e9e en param\u00e8tre modifiable par le caller.</p>"}, {"location": "course-c/15-fundations/functions/#exemples-de-fonctions", "title": "Exemples de fonctions", "text": ""}, {"location": "course-c/15-fundations/functions/#suite-de-fibonacci", "title": "Suite de Fibonacci", "text": "<p>La suite de Fibonacci est une suite d'entiers dans laquelle chaque terme est la somme des deux termes pr\u00e9c\u00e9dents. La suite commence par 0 et 1. La suite commence donc par 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...</p> <p>Voici une impl\u00e9mentation de la suite de Fibonacci en utilisant une approche it\u00e9rative\u2009:</p> <pre><code>int fib(int n)\n{\n    int sum = 0;\n    int t1 = 0, t2 = 1;\n    int next_term;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        sum += t1;\n        next_term = t1 + t2;\n        t1 = t2;\n        t2 = next_term;\n    }\n    return sum;\n}\n</code></pre>"}, {"location": "course-c/15-fundations/functions/#exercices-de-revision", "title": "Exercices de r\u00e9vision", "text": "<p>Exercise\u2009: Dans la moyenne</p> <p>\u00c9crire une fonction <code>mean</code> qui re\u00e7oit 3 param\u00e8tres r\u00e9els et qui retourne la moyenne.</p> Solution <pre><code>double mean(double a, double b, double c) {\n    return (a + b + c) / 3.;\n}\n</code></pre> <p>Exercise\u2009: Le plus petit</p> <p>\u00c9crire une fonction <code>min</code> qui re\u00e7oit 3 param\u00e8tres r\u00e9els et qui retourne la plus petite valeur.</p> Solution <pre><code>double min(double a, double b, double c) {\n    double min_value = a;\n    if (b &lt; min_value)\n        min_value = b;\n    if (c &lt; min_value)\n        min_value = c;\n    return min_value;\n}\n</code></pre> <p>Une mani\u00e8re plus compacte, mais moins lisible serait\u2009:</p> <pre><code>double min(double a, double b, double c) {\n    return (a = (a &lt; b ? a : b)) &lt; c ? a : c;\n}\n</code></pre> <p>Exercise\u2009: Algorithme de retour de monnaie</p> <p>On consid\u00e8re le cas d'une caisse automatique de parking. Cette caisse d\u00e9livre des tickets au prix unique de CHF 0.50 et dispose d'un certain nombre de pi\u00e8ces de 10 et 20 centimes pour le rendu de monnaie.</p> <p>Dans le code du programme, les trois variables suivantes seront utilis\u00e9es\u2009:</p> <pre><code>// Available coins in the parking ticket machine\nunsigned int ncoin_10, ncoin_20;\n\n// How much money the user inserted into the machine (in cents)\nunsigned int amount_payed;\n</code></pre> <p>\u00c9crivez l'algorithme de rendu de la monnaie tenant compte du nombre de pi\u00e8ces de 10 et 20 centimes restants dans l'appareil. Voici un exemple du fonctionnement du programme\u2009:</p> <pre><code>$ echo \"10 10 20 20 20\" | ./ptm 30 1\nticket\n20\n10\n</code></pre> <p>Le programme re\u00e7oit sur <code>stdin</code> les pi\u00e8ces introduites dans la machine. Les deux arguments pass\u00e9s au programme <code>ptm</code> sont 1. le nombre de pi\u00e8ces de 10 centimes disponibles et 2. le nombre de pi\u00e8ces de 20 centimes disponibles. <code>stdout</code> contient les valeurs rendues \u00e0 l'utilisateur. La valeur <code>ticket</code> correspond au ticket distribu\u00e9.</p> <p>Le cas \u00e9ch\u00e9ant, s'il n'est possible de rendre la monnaie, aucun ticket n'est distribu\u00e9 et l'argent donn\u00e9 est rendu.</p> Solution <p>Voici une solution partielle\u2009:</p> <pre><code>#define TICKET_PRICE 50\n\nvoid give_coin(unsigned int value) { printf(\"%d\\n\", value); }\nvoid give_ticket(void) { printf(\"ticket\\n\"); }\n\nbool no_ticket = amount_payed &lt; TICKET_PRICE;\n\nint amount_to_return = amount_payed - TICKET_PRICE;\ndo {\n    while (amount_to_return &gt; 0) {\n        if (amount_to_return &gt;= 20 &amp;&amp; ncoin_20 &gt; 0) {\n            give_coin(20);\n            amount_to_return -= 20;\n            ncoin_20--;\n        } else if (amount_to_return &gt;= 10 &amp;&amp; ncoin_10 &gt; 0) {\n            give_coin(10);\n            amount_to_return -= 10;\n            ncoin_10--;\n        } else {\n            no_ticket = true;\n            break;\n        }\n    }\n} while (amount_to_return &gt; 0);\n\nif (!no_ticket) {\n    give_ticket();\n}\n</code></pre> <p>Exercise\u2009: La fonction f</p> <p>Consid\u00e9rons le programme suivant\u2009:</p> <pre><code>int f(float x) {\n    int i;\n    if (x &gt; 0.0)\n        i = (int)(x + 0.5);\n    else\n        i = (int)(x - 0.5);\n    return i;\n}\n</code></pre> <p>Quel sont les types et les valeurs retourn\u00e9es par les expressions ci-dessous\u2009?</p> <pre><code>f(1.2)\nf(-1.2)\nf(1.6)\nf(-1.6)\n</code></pre> <p>Quel est votre conclusion sur cette fonction\u2009?</p> <p>Exercise\u2009: Mauvaise somme</p> <p>Le programme suivant compile sans erreurs graves, mais ne fonctionne pas correctement.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;\n\nlong get_integer()\n{\n    bool ok;\n    long result;\n    do\n    {\n        printf(\"Enter a integer value: \");\n        fflush(stdin); // Empty input buffer\n        ok = (bool)scanf(\"%ld\", &amp;result);\n        if (!ok)\n            printf(\"Incorrect value.\\n\");\n    }\n    while (!ok);\n    return result;\n}\n\nint main(void)\n{\n    long a = get_integer;\n    long b = get_integer;\n\n    printf(\"%d\\n\", a + b);\n}\n</code></pre> <p>Quel est le probl\u00e8me\u2009? \u00c0 titre d'information voici ce que le programme donne, notez que l'invit\u00e9 de saisie n'est jamais apparu\u2009:</p> <pre><code>$ ./sum\n8527952\n</code></pre>"}, {"location": "course-c/15-fundations/grammar/", "title": "Grammar", "text": ""}, {"location": "course-c/15-fundations/grammar/#la-grammaire", "title": "La grammaire", "text": "<p>Dans un langage formel, la grammaire est l'ensemble des r\u00e8gles qui r\u00e9gissent la construction des phrases. Elle est essentielle pour comprendre et produire un texte correctement. En fran\u00e7ais, la grammaire est complexe et comporte de nombreuses r\u00e8gles et exceptions.</p> <p>En programmation informatique, la grammaire est \u00e9galement tr\u00e8s importante. Elle d\u00e9finit la syntaxe du langage de programmation, c'est-\u00e0-dire la mani\u00e8re dont les instructions doivent \u00eatre \u00e9crites pour \u00eatre comprises par l'ordinateur. Une erreur de syntaxe peut emp\u00eacher un programme de fonctionner correctement, voire de compiler.</p> <p>L'ordinateur ne lit pas une phrase comme vous, elle ne peut pas ignorer les fautes de frappe, les erreurs de syntaxe ou les erreurs d'accord, car le compilateur doit \u00eatre capable d'interpr\u00e9ter le code source sans aucune ambigu\u00eft\u00e9.</p> <p>La grammaire d'un langage de programmation est g\u00e9n\u00e9ralement d\u00e9finie par un document appel\u00e9 \u00ab\u2009grammaire formelle\u2009\u00bb. Elle va d\u00e9finir les composants des \u00e9l\u00e9ments de votre code. Prenons par exemple le programme suivant\u2009:</p> <pre><code>int main() {\n    const int n = 23 + 42;\n    for (int j = 0; j &lt; n; ++j) {\n        printf(\"%d \", j);\n    }\n    return 0;\n}\n</code></pre> <p>On peut hi\u00e9rarchiser les \u00e9l\u00e9ments de ce programme de la mani\u00e8re suivante\u2009:</p> <p> Exemple d'arbre syntaxique (AST)</p> <p>La grammaire formelle du langage C est tr\u00e8s complexe et comporte de nombreuses r\u00e8gles. Elle est d\u00e9finie par le standard du langage C, qui est un document officiel publi\u00e9 par l'ANSI (American National Standards Institute) et l'ISO (International Organization for Standardization).</p> <p>Une grammaire formelle est souvent \u00e9crite en utilisant une notation appel\u00e9e \u00ab\u2009Backus-Naur Form\u2009\u00bb (BNF). Cette notation est tr\u00e8s pr\u00e9cise et permet de d\u00e9crire de mani\u00e8re formelle la syntaxe d'un langage de programmation. Pour le C voici un extrait de la grammaire utilis\u00e9e par le compilateur\u2009:</p> <pre><code>&lt;translation_unit&gt; ::= {&lt;external_declaration&gt;}*\n\n&lt;external_declaration&gt; ::= &lt;function_definition&gt;\n                        | &lt;declaration&gt;\n\n&lt;function_definition&gt; ::= {&lt;declaration_specifier&gt;}* &lt;declarator&gt; {&lt;declaration&gt;}* &lt;compound_statement&gt;\n\n&lt;declaration_specifier&gt; ::= &lt;storage_class_specifier&gt;\n                            | &lt;type_specifier&gt;\n                            | &lt;type_qualifier&gt;\n\n&lt;storage_class_specifier&gt; ::= \"auto\"\n                            | \"register\"\n                            | \"static\"\n                            | \"extern\"\n                            | \"typedef\"\n\n&lt;type_specifier&gt; ::= \"void\"\n                    | \"char\"\n                    | \"short\"\n                    | \"int\"\n                    | \"long\"\n                    | \"float\"\n                    | \"double\"\n                    | \"signed\"\n                    | \"unsigned\"\n                    | &lt;struct_or_union_specifier&gt;\n                    | &lt;enum_specifier&gt;\n                    | &lt;typedef_name&gt;\n\n&lt;struct_or_union_specifier&gt; ::= &lt;struct_or_union&gt; &lt;identifier&gt; { {&lt;struct_declaration&gt;}+ }\n                                | &lt;struct_or_union&gt; { {&lt;struct_declaration&gt;}+ }\n                                | &lt;struct_or_union&gt; &lt;identifier&gt;\n\n&lt;struct_or_union&gt; ::= \"struct\"\n                    | \"union\"\n\n&lt;struct_declaration&gt; ::= {&lt;specifier_qualifier&gt;}* &lt;struct_declarator_list&gt;\n\n&lt;specifier_qualifier&gt; ::= &lt;type_specifier&gt;\n                        | &lt;type_qualifier&gt;\n\n&lt;struct_declarator_list&gt; ::= &lt;struct_declarator&gt;\n                            | &lt;struct_declarator_list&gt; \",\" &lt;struct_declarator&gt;\n\n&lt;struct_declarator&gt; ::= &lt;declarator&gt;\n                        | &lt;declarator&gt; \":\" &lt;constant_expression&gt;\n                        | \":\" &lt;constant_expression&gt;\n\n&lt;declarator&gt; ::= {&lt;pointer&gt;}? &lt;direct_declarator&gt;\n\n&lt;pointer&gt; ::= * {&lt;type_qualifier&gt;}* {&lt;pointer&gt;}?\n\n&lt;type_qualifier&gt; ::= \"const\"\n                    | \"volatile\"\n\n&lt;direct_declarator&gt; ::= &lt;identifier&gt;\n                        | ( &lt;declarator&gt; )\n                        | &lt;direct_declarator&gt; \"[\" {&lt;constant_expression&gt;}? \"]\"\n                        | &lt;direct_declarator&gt; \"(\" &lt;parameter_type_list&gt; \")\"\n                        | &lt;direct_declarator&gt; \"(\" {&lt;identifier&gt;}* \")\"\n</code></pre> <p>Ce que l'on observe par exemple c'est que la grammaire du C est r\u00e9cursive. Cela signifie que l'on peut d\u00e9finir un \u00e9l\u00e9ment en fonction de lui-m\u00eame. Par exemple, un <code>declarator</code> peut contenir un <code>pointer</code> qui peut lui-m\u00eame contenir un <code>pointer</code>.</p> <p>Comment est-ce que cela fonctionne derri\u00e8re les coulisses\u2009?</p> <p>Le compilateur va tout d'abord convertir votre code source en un arbre de syntaxe abstraite (AST) qui va repr\u00e9senter la structure de votre programme (c'est grosso modo la figure montr\u00e9e plus haut). Ensuite, il va v\u00e9rifier que cet arbre respecte les r\u00e8gles du standard C. Si ce n'est pas le cas, il va vous renvoyer une erreur de compilation. Si cela passe \u00e0 cette \u00e9tape, il va ensuite pouvoir assembler votre programme en convertissant cette repr\u00e9sentation interne en du code assembleur. Ce dernier peut ensuite \u00eatre optimis\u00e9 pour \u00eatre plus rapide ou plus petit.</p> <p>La grammaire est donc un \u00e9l\u00e9ment important de la programmation et elle explique pourquoi un simple <code>;</code> manquant peut vous co\u00fbter quelques cheveux arrach\u00e9s car l'analyseur syntaxique ne sait pas comment d\u00e9couper votre code en phrases.</p> <p>Pour les curieux, vous pouvez consulter la grammaire compl\u00e8te du C dans le standard du langage C (ISO/IEC 9899:2018) dans l'annexe A.</p>"}, {"location": "course-c/15-fundations/grammar/#definir-mon-propre-langage", "title": "D\u00e9finir mon propre langage", "text": "<p>Imaginons que l'on souaite r\u00e9aliser notre propre langage formel, par exemple pour analyser une expression math\u00e9matique de la forme</p> <pre><code>3 + 4 * 5 + ( sin(3.14) + sqrt(2) / 8 )\n</code></pre> <p>On pourrait d\u00e9finir une grammaire formelle pour ce langage de la mani\u00e8re suivante\u2009:</p> <pre><code>&lt;expression&gt; ::= &lt;term&gt; { \"+\" &lt;term&gt; | \"-\" &lt;term&gt; }*\n\n&lt;term&gt; ::= &lt;factor&gt; { \"*\" &lt;factor&gt; | \"/\" &lt;factor&gt; }*\n\n&lt;factor&gt; ::= &lt;number&gt; | \"(\" &lt;expression&gt; \")\" | &lt;function&gt; \"(\" &lt;expression&gt; \")\"\n\n&lt;number&gt; ::= [0-9]+(\".\"[0-9]*)?\n&lt;function&gt; ::= \"sin\" | \"cos\" | \"sqrt\"\n</code></pre> <p>Des outils comme <code>lex</code> et <code>yacc</code> permettent de g\u00e9n\u00e9rer un analyseur lexical et un analyseur syntaxique utilisables en C \u00e0 partir de cette grammaire. Ces outils sont tr\u00e8s puissants et sont utilis\u00e9s dans de nombreuses biblioth\u00e8ques et logiciels pour analyser des fichiers de configuration ou des syntaxes sp\u00e9cifiques.</p>"}, {"location": "course-c/15-fundations/operators/", "title": "Op\u00e9rateurs", "text": "<p>En programmation, un op\u00e9rateur est une fonction qui effectue une op\u00e9ration. sur des valeurs. Les op\u00e9rateurs utilisent des identificateurs sp\u00e9cifiques propres \u00e0 chaque langage de programmation, ce qui permet de simplifier l'\u00e9criture des expressions. Par exemple, l'op\u00e9rateur d'addition <code>+</code> permet d'additionner deux valeurs.</p> <p>L'unit\u00e9 de calcul arithm\u00e9tique du processeur est responsable d'effectuer les op\u00e9rations fondamentales. Un ordinateur \u00e0 2 GHz pourrait par exemple effectuer plus de 2'000'000'000 op\u00e9rations par seconde.</p> <p>Un op\u00e9rateur prend habituellement deux op\u00e9randes et retourne un r\u00e9sultat. On dit alors que cette classe d'op\u00e9rateurs a une arit\u00e9 de 2. Il existe \u00e9galement des op\u00e9rateurs \u00e0 arit\u00e9 de 1, aussi appel\u00e9s op\u00e9rateurs unaires comme pour obtenir l'oppos\u00e9 d'un nombre (\\(-x\\)). Connaissant le compl\u00e9ment \u00e0 deux, on sait que pour obtenir l'oppos\u00e9 d'un nombre, il suffit d'inverser tous les bits et d'ajouter 1. C'est-\u00e0-dire de faire l'op\u00e9ration de n\u00e9gation <code>~</code> puis de faire une addition <code>+1</code>.</p> <p>Un op\u00e9rateur poss\u00e8de plusieurs propri\u00e9t\u00e9s\u2009:</p> Une priorit\u00e9 <p>La multiplication <code>*</code> est plus prioritaire que l'addition <code>+</code></p> Une associativit\u00e9 <p>L'op\u00e9rateur d'affectation <code>=</code> poss\u00e8de une associativit\u00e9 \u00e0 droite, c'est-\u00e0-dire que l'op\u00e9rande \u00e0 droite de l'op\u00e9rateur sera \u00e9valu\u00e9 en premier</p> Un point de s\u00e9quence <p>Certains op\u00e9rateurs comme <code>&amp;&amp;</code>, <code>||</code>, <code>?</code> ou <code>,</code> poss\u00e8dent un point de s\u00e9quence garantissant que l'ex\u00e9cution s\u00e9quentielle du programme sera respect\u00e9e avant et apr\u00e8s ce point. Par exemple si dans l'expression <code>i &lt; 12 &amp;&amp; j &gt; 2</code> la valeur de <code>i</code> est plus grande que 12, le test <code>j &gt; 2</code> ne sera jamais effectu\u00e9. L'op\u00e9rateur <code>&amp;&amp;</code> garantit l'ordre des choses, ce qui n'est pas le cas avec l'affectation <code>=</code>.</p>"}, {"location": "course-c/15-fundations/operators/#alu-arithmetic-logic-unit", "title": "ALU (Arithmetic Logic Unit)", "text": "<p>Dans un ordinateur, ou sur un microcontr\u00f4leur, c'est l'unit\u00e9 de calcul arithm\u00e9tique ALU qui est en charge d'effectuer les op\u00e9rations fondamentales. Cette unit\u00e9 de calcul est consensuellement repr\u00e9sent\u00e9e comme illustr\u00e9e \u00e0 la figure suivante\u2009:</p> <p> ALU</p> <p>L'unit\u00e9 de calcul arithm\u00e9tique (ALU) repr\u00e9sent\u00e9e est compos\u00e9e de deux entr\u00e9es <code>A</code> et <code>B</code>, d'une sortie <code>C</code> et d'un mode op\u00e9ratoire <code>O</code>. Sur de petites architectures mat\u00e9rielles, l'ALU peut \u00eatre limit\u00e9 aux op\u00e9rations d'addition <code>+</code>, d'inversion bit \u00e0 bit <code>~</code>, de d\u00e9calage vers la gauche <code>&lt;&lt;</code> et vers la droite <code>&gt;&gt;</code> et de l'op\u00e9ration bit \u00e0 bit logique <code>&amp;</code> pour la conjonction ainsi que <code>|</code> pour la disjonction.</p> <p>Si l'on souhaite faire une addition, on peut \u00e9crire en C\u2009:</p> <pre><code>c = a + b;\n</code></pre> <p></p>"}, {"location": "course-c/15-fundations/operators/#types-doperateurs", "title": "Types d'op\u00e9rateurs", "text": "<p>Le langage C d\u00e9finit un certain nombre d'op\u00e9rateurs qui peuvent \u00eatre class\u00e9s en plusieurs cat\u00e9gories\u2009:</p> <ul> <li>Les op\u00e9rateurs arithm\u00e9tiques</li> <li>Les op\u00e9rateurs relationnels</li> <li>Les op\u00e9rateurs logiques</li> <li>Les op\u00e9rateurs bit \u00e0 bit</li> <li>Les op\u00e9rateurs d'affectation</li> <li>Les op\u00e9rateurs de pointeurs</li> <li>Les op\u00e9rateurs de taille</li> <li>Les op\u00e9rateurs de s\u00e9quence</li> <li>Les op\u00e9rateurs de pr\u00e9/post-incr\u00e9mentation</li> <li>Les op\u00e9rateurs de condition</li> </ul> <p>Nous allons tous les voir un par un\u2009; ce chapitre est long...</p>"}, {"location": "course-c/15-fundations/operators/#operateurs-arithmetiques", "title": "Op\u00e9rateurs arithm\u00e9tiques", "text": "<p>Aux 4 op\u00e9rations de base (+, -, \u00d7, \u00f7) le C ajoute l'op\u00e9ration modulo, qui est le reste d'une division enti\u00e8re.</p>  Op\u00e9rateurs arithm\u00e9tiques Op\u00e9rateur Abr\u00e9viation Description Assertion vraie <code>+</code> add Addition <code>5 == 2 + 3</code> <code>-</code> sub Soustraction <code>8 == 12 - 4</code> <code>*</code> mul Multiplication <code>42 == 21 * 2</code> <code>/</code> div Division <code>2 == 5 / 2</code> <code>%</code> mod Modulo <code>13 % 4 == 1</code> <p>Lors d'op\u00e9rations il faut faire attention aux types des variables impliqu\u00e9es. La division <code>5 / 2</code> donnera <code>2</code> et non, <code>2.5</code> car les deux valeurs fournies sont enti\u00e8res et le r\u00e9sultat est donc un entier. Pour obtenir un r\u00e9sultat flottant, il faut que l'une des valeurs soit un flottant, ici le <code>5</code> est exprim\u00e9 en <code>double</code>, la propagation de type fera que le r\u00e9sultat sera aussi un <code>double</code> :</p> <pre><code>int a = 5 / 2;      // 2\ndouble b = 5.0 / 2; // 2.5\n</code></pre> <p>Le modulo (mod, <code>%</code>) est le reste de la division enti\u00e8re. L'assertion suivante est donc vraie, car 13 divis\u00e9 par 4 \u00e9gal 3 et il reste 1\u2009:</p> <pre><code>assert(13 % 4 == 1)\n</code></pre> \\[ \\begin{array}{rr|l}   1 &amp; 3 &amp; 4 \\\\ \\hline  - &amp; 8   &amp; \\textbf{2} \\\\   &amp; \\textbf{5}   &amp; \\\\   &amp; &amp; \\end{array} \\] <p>Il est important de noter aussi que les op\u00e9rateurs arithm\u00e9tiques sont tributaires des types sur lesquels ils s'appliquent. Par exemple, l'addition de deux entiers 8 bits <code>120 + 120</code> ne fera pas, <code>240</code> car le type ne permet pas de stocker des valeurs plus grandes que <code>127</code> :</p> <pre><code>int8_t too_small = 120 + 120;\nassert(too_small != 120 + 120);\n</code></pre> <p>Nous l'avons tous appris dans les petites \u00e9coles, les op\u00e9rations arithm\u00e9tiques s'effectuent de droite \u00e0 gauche et chiffre \u00e0 chiffre. Lorsque le r\u00e9sultat de l'op\u00e9ration d\u00e9passe la capacit\u00e9 d'un chiffre, on retient une unit\u00e9 et on la reporte \u00e0 la colonne suivante. L'addition de \\(123\\) et \\(89\\) en base \\(10\\) donne \\(212\\).</p> \\[ \\begin{array}{lrrr} \\phantom{1}&amp; _1 &amp; _1 &amp;  \\\\            &amp; 1           &amp; 2 &amp; 3_{~10} \\\\          + &amp; \\phantom{0} &amp; 8 &amp; 9_{~10} \\\\ \\hline            &amp;           2 &amp; 1 &amp; 2_{~10} \\\\ \\end{array} \\] <p>L'exemple reste valable quelque soit la base, en binaire par exemple, on commence par additionner les bits de poids faible et on reporte les retenues. Ainsi en premier lieu on aura \\(1_2 + 1_2 = 10_2\\). Donc le r\u00e9sultat est \\(0\\) et la retenue (carry) est \\(1\\) :</p> \\[ \\begin{array}{lrrrrrrrr}   &amp; _1 &amp; _1 &amp; _1 &amp; _1 &amp;  &amp; _1 &amp; _1 &amp;  \\\\     &amp; &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 0 &amp; 1 &amp; 1_{~2} \\\\  +  &amp; &amp; 1 &amp; 0 &amp; 1 &amp; 1 &amp; 0 &amp; 0 &amp; 1_{~2} \\\\ \\hline   &amp;1 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 1 &amp; 0 &amp; 0_{~2} \\\\ \\end{array} \\] <p>En alg\u00e8bre de Boole, l'addition de deux chiffres n'a que \\(2^2 = 4\\) cas de figure (contre \\(10^2=100\\) en base \\(10\\)).</p> <p>L'addition de deux bits \\(A\\) et \\(B\\) est donn\u00e9e par la table suivante o\u00f9 <code>C</code> est la retenue engendr\u00e9e par l'addition\u2009:</p>  Addition binaire A B   A + B  C  0 0 0 0 0 1 1 0 1 0 1 0 1 1 0 1 <p>Le cas de la soustraction</p> <p>La soustraction reste une addition mais elle s'effectue sur les nombres repr\u00e9sent\u00e9s en compl\u00e9ment \u00e0 deux. On pourrait s'amuser \u00e0 soustraire deux nombres en base \\(10\\) en les repr\u00e9sentant en compl\u00e9ment \u00e0 neuf plus 1. Par exemple, pour soustraire \\(23\\) de \\(12\\) il faut repr\u00e9senter \\(12\\) en compl\u00e9ment \u00e0 neuf plus un.</p> <p>La m\u00e9thode est la m\u00eame, on effectue le compl\u00e9ment \u00e0 \\(9\\) de \\(12\\), soit \\(87\\) et on ajoute \\(1\\) pour obtenir \\(88\\). Ensuite on peut faire l'addition en \u00e9liminant le chiffre suppl\u00e9mentaire qui d\u00e9passe\u2009:</p> \\[ \\begin{array}{lrrr} &amp; _1 &amp; _1 &amp;  \\\\ &amp; 0 &amp; 2 &amp; 3_{~10} \\\\ +  &amp; 0 &amp; 8 &amp; 8_{~10} \\\\ \\hline &amp; 1 &amp; 1 &amp; 1_{~10} \\\\ \\end{array} \\] <p>L'int\u00e9r\u00eat de cette m\u00e9thode c'est qu'il s'agisse d'une addition ou d'une soustraction, c'est la m\u00eame op\u00e9ration calcul\u00e9e par l'unit\u00e9 arithm\u00e9tique et logique.</p> <p>Exercise\u2009: Additions binaires</p> <p>Une unit\u00e9 de calcul arithm\u00e9tique (ALU) est capable d'effectuer les 4 op\u00e9rations de bases comprenant additions et soustractions.</p> <p>Traduisez les op\u00e9randes ci-dessous en binaire, puis poser l'addition en binaire.</p> <ol> <li>\\(1 + 51\\)</li> <li>\\(51 - 7\\)</li> <li>\\(204 + 51\\)</li> <li>\\(204 + 204\\) (sur 8-bits)</li> </ol> Solution <p>Voici la solution du calcul en binaire\u2009:</p> <ol> <li> <p>\\(1 + 51\\)</p> <pre><code>        \u00b9\u00b9\n         1\u2082\n+   110011\u2082  (2\u2075 + 2\u2074 + 2\u00b9+ 2\u2070 \u2261 51)\n----------\n    110100\u2082\n</code></pre> </li> <li> <p>\\(51 - 7\\)</p> <pre><code>  \u2026\u00b9\u00b9\u00b9  \u00b9\u00b9\n  \u2026000110011\u2082  (2\u2075 + 2\u2074 + 2\u00b9 + 2\u2070 \u2261 51)\n+ \u2026111111001\u2082  (compl\u00e9ment \u00e0 deux, 2\u00b3 + 2\u00b9 + 2\u2070 \u2261 111\u2082 \u2192 !7 + 1 \u2261 \u2026111001\u2082)\n  -----------\n  \u2026000101100\u2082  (2\u2075 + 2\u00b3 + 2\u2082 \u2261 44)\n</code></pre> </li> <li> <p>\\(204 + 51\\)</p> <pre><code>    11001100\u2082\n+     110011\u2082\n  -----------\n  \u2026011111111\u2082  (2\u2078 - 1 \u2261 255)\n</code></pre> </li> <li> <p>\\(204 + 204\\) (sur 8-bits)</p> <pre><code>    \u00b9|\u00b9  \u00b9\u00b9\n     |11001100\u2082\n +   |11001100\u2082\n  ---+--------\n    1|10011000\u2082  (152, le r\u00e9sultat complet devrait \u00eatre 2\u2078 + 152 \u2261 408)\n</code></pre> </li> </ol>"}, {"location": "course-c/15-fundations/operators/#operateurs-relationnels", "title": "Op\u00e9rateurs relationnels", "text": "<p>Les op\u00e9rateurs relationnels permettent de comparer deux valeurs. Le r\u00e9sultat d'un op\u00e9rateur relationnel est toujours un bool\u00e9en c'est-\u00e0-dire que le r\u00e9sultat d'une comparaison est soit vrai, soit faux.</p> <p>Rappelons qu'en C et dans la plupart des langages de programmation, une valeur vraie est repr\u00e9sent\u00e9e par <code>1</code> et une valeur fausse par <code>0</code>.</p> <p>Les op\u00e9rateurs relationnels sont les suivants\u2009:</p>  Op\u00e9rateurs relationnels Op\u00e9rateur Abr\u00e9viation Description Exemple vrai <code>==</code> eq \u00c9gal <code>42 == 0x101010</code> <code>!=</code> ne Diff\u00e9rent <code>'a' != 'c'</code> <code>&gt;=</code> ge Sup\u00e9rieur ou \u00e9gal <code>9 &gt;= 9</code> <code>&lt;=</code> le Inf\u00e9rieur ou \u00e9gal <code>-8 &lt;= 8</code> <code>&gt;</code> gt Strictement sup\u00e9rieur <code>0x31 &gt; '0'</code> <code>&lt;</code> lg Strictement inf\u00e9rieur <code>8 &lt; 12.33</code> <p>Un op\u00e9rateur relationnel est plus prioritaire qu'un op\u00e9rateur d'affectation et donc l'\u00e9criture suivante applique le test d'\u00e9galit\u00e9 entre <code>a</code> et <code>b</code> et le r\u00e9sultat de ce test <code>1</code> ou <code>0</code> sera affect\u00e9 \u00e0 la variable <code>c</code> :</p> <pre><code>int a = 2, b = 3;\nint c = a == b;\n</code></pre> <p>Les op\u00e9rateurs relationnels sont le plus souvent utilis\u00e9s dans des structures de contr\u00f4les\u2009:</p> <pre><code>if (a == b) {\n    printf(\"Les op\u00e9randes sont \u00e9gaux.\\n\");\n} else {\n    printf(\"Les op\u00e9randes ne sont pas \u00e9gaux.\\n\");\n}\n</code></pre> <p>Astuce</p> <p>Programmer c'est \u00eatre minimaliste, d\u00e8s lors il serait possible de simplifier l'\u00e9criture ci-dessus de la fa\u00e7on suivante\u2009:</p> <pre><code>printf(\"Les op\u00e9randes %s \u00e9gaux.\\n\", a == b ? \"sont\" : \"ne sont pas\");\n</code></pre> <p>Dans se cas on utilise l'op\u00e9rateur ternaire <code>? :</code> qui permet de s'affranchir d'une structure de contr\u00f4le explicite.</p> <p>Attention lors de l'utilisation du test d'\u00e9galit\u00e9 avec des valeurs flottantes, ces derni\u00e8res sont des approximations et il est possible que deux valeurs qui devraient \u00eatre \u00e9gales ne le soient pas.</p> <p>Par exemple, cette assertion est fausse\u2009:</p> <pre><code>assert(0.1 + 0.2 == 0.3) // false\n</code></pre> <p>Pour comparer des valeurs flottantes, il est recommand\u00e9 d'utiliser une fonction de comparaison qui prend en compte une marge d'erreur. Par exemple, on pourrait \u00e9crire une fonction <code>float_eq</code> qui compare deux valeurs flottantes avec une marge d'erreur de <code>0.0001</code> :</p> <pre><code>bool float_eq(float a, float b) {\n    return fabs(a - b) &lt; 0.0001;\n}\n</code></pre> <p>Alternativement on peut utiliser la d\u00e9finition <code>FLT_EPSILON</code> qui est la plus petite valeur positive telle que <code>1.0 + FLT_EPSILON != 1.0</code> :</p> <pre><code>assert(fabs(0.1 + 0.2 - 0.3) &lt; FLT_EPSILON);\n</code></pre> <p>Voici une d\u00e9monstration\u2009:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;float.h&gt;\n#include &lt;math.h&gt;\nint main() {\n    double u1 = 0.3, u2 = 0.1 + 0.2;\n    long long int i1 = *(long int*)&amp;u1;\n    long long int i2 = *(long int*)&amp;u2;\n    printf(\"Hex value of 0.3:\\t\\t0x%x\\n\", i1);\n    printf(\"Hex value of 0.3:\\t\\t0x%x\\n\", i2);\n\n    printf(\"Float value of 0.3:\\t\\t%.20f\\n\", u1);\n    printf(\"Float value of 0.1 + 0.2:\\t%.20f\\n\", u2);\n\n    printf(\"0.1 + 0.2 == 0.3: %d\\n\", u1 == u2);\n    printf(\"0.1 + 0.2 == 0.3: %d\\n\", fabs(u1 - u2) &lt; DBL_EPSILON );\n}\n</code></pre> <p>Le r\u00e9sultat de ce programme est le suivant\u2009:</p> <pre><code>Hex value of 0.3:               0x33333333\nHex value of 0.3:               0x33333334\nFloat value of 0.3:             0.29999999999999998890\nFloat value of 0.1 + 0.2:       0.30000000000000004441\n0.1 + 0.2 == 0.3: 0\n0.1 + 0.2 == 0.3: 1\n</code></pre> <p>Confusion = et ==</p> <p>L'erreur est si vite commise, mais souvent fatale\u2009:</p> <pre><code>if (c = 'o') {\n\n}\n</code></pre> <p>L'effet contre-intuitif est que le test retourne toujours VRAI, car <code>'o' &gt; 0</code>. Ajoutons que la valeur de <code>c</code> est modifi\u00e9 au passage.</p> <p>Observations\u2009:</p> <ul> <li>Pour \u00e9viter toute ambigu\u00eft\u00e9, \u00e9viter les affectations dans les structures conditionnelles.</li> </ul> <p>Triple \u00e9galit\u00e9\u2009?</p> <p>Dans certains langages comme le JavaScript, il existe un op\u00e9rateur de comparaison <code>===</code> qui compare non seulement les valeurs mais aussi les types.</p> <p>En C, il n'existe pas d'op\u00e9rateur de comparaison de type, il faut donc faire attention \u00e0 ce que les types des op\u00e9randes soient compatibles.</p> <p>Voici une diff\u00e9rence entre C et JavaScript\u2009:</p> CJavaScript <pre><code>assert('4' == 4); // false\nassert(4 == 4.0); // true\n</code></pre> <pre><code>assert('4' == 4); // true\nassert('4' === 4); // false\n</code></pre>"}, {"location": "course-c/15-fundations/operators/#operateurs-bit-a-bit", "title": "Op\u00e9rateurs bit \u00e0 bit", "text": "<p>Les op\u00e9rations bit \u00e0 bit (bitwise) agissent sur chaque bit d'une valeur. Les disponibles en C sont les suivantes\u2009:</p>  Op\u00e9rateurs bit \u00e0 bit Op\u00e9rateur Description Exemple <code>&amp;</code> Conjonction (ET) <code>(0b1101 &amp; 0b1010) == 0b1000</code> <code>|</code> Disjonction (OU) <code>(0b1101 | 0b1010) == 0b1111</code> <code>^</code> XOR binaire <code>(0b1101 ^ 0b1010) == 0b0111</code> <code>~</code> Compl\u00e9ment \u00e0 un <code>~0b11011010 == 0b00100101</code> <code>&lt;&lt;</code> D\u00e9calage \u00e0 gauche <code>(0b1101 &lt;&lt; 3) == 0b1101000</code> <code>&gt;&gt;</code> D\u00e9calage \u00e0 droite <code>(0b1101 &gt;&gt; 2) == 0b11</code> <p>Important</p> <p>Ne pas confondre l'op\u00e9rateur <code>!</code> et l'op\u00e9rateur <code>~</code>. Le premier est la n\u00e9gation d'un nombre tandis que l'autre est l'inversion bit \u00e0 bit. La n\u00e9gation d'un nombre diff\u00e9rent de z\u00e9ro donnera toujours <code>0</code> et la n\u00e9gation de z\u00e9ro donnera toujours <code>1</code>.</p> <p></p>"}, {"location": "course-c/15-fundations/operators/#conjonction", "title": "Conjonction", "text": "<p>La conjonction ou ET logique (\\(\\wedge\\)) est identique \u00e0 la multiplication appliqu\u00e9e bit \u00e0 bit et ne g\u00e9n\u00e8re pas de retenue.</p>  Conjonction bit \u00e0 bit \\(A \u2227 B\\) \\(A=0\\) \\(A=1\\) \\(B=0\\) 0 0 \\(B=1\\) 0 1 <p>Avec cette op\u00e9ration l'\u00e9tat dominant est le <code>0</code> et l'\u00e9tat r\u00e9cessif est le <code>1</code>. Il suffit qu'une seule valeur soit \u00e0 z\u00e9ro pour forcer le r\u00e9sultat \u00e0 z\u00e9ro\u2009:</p> <pre><code>assert(0b1100 &amp; 0b0011 == 0b0000)\n</code></pre> <p>Cet op\u00e9rateur est d'ailleurs souvent utilis\u00e9 pour imposer une valeur nulle suivant une condition. Dans l'exemple suivant, le Balrog est r\u00e9duit \u00e0 n\u00e9ant par Gandalf le gris\u2009:</p> <pre><code>balrog = 0b1100110101;\ngandalf = 0;\n\nbalrog = balrog &amp; gandalf; // You shall not pass!\n</code></pre> <p></p>"}, {"location": "course-c/15-fundations/operators/#disjonction", "title": "Disjonction", "text": "<p>La disjonction ou OU logique (\\(\\lor\\)) s'apparente \u00e0 l'op\u00e9ration <code>+</code>.</p>  Disjonction bit \u00e0 bit \\(A \u2228 B\\) \\(A=0\\) \\(A=1\\) \\(B=0\\) 0 1 \\(B=1\\) 1 1 <p>Ici l'\u00e9tat dominant est le <code>1</code> car il force n'importe quel <code>0</code> \u00e0 changer d'\u00e9tat\u2009:</p> <pre><code>bool student = false; // Veut pas faire ses devoirs ?\nbool teacher = true;\n\nstudent = student | teacher; // Tes devoirs tu feras...\n</code></pre> <p></p>"}, {"location": "course-c/15-fundations/operators/#disjonction-exclusive", "title": "Disjonction exclusive", "text": "<p>Le OU exclusif (\\(\\oplus\\) ou \\(\\veebar\\)) est une op\u00e9ration curieuse, mais extr\u00eamement puissante et utilis\u00e9e massivement en cryptographie.</p> <p>En \u00e9lectronique sur les symboles CEI, l'op\u00e9ration logique est nomm\u00e9e, <code>=1</code> car si le r\u00e9sultat de l'addition des deux op\u00e9randes est diff\u00e9rent de <code>1</code>, la sortie sera nulle. Lorsque <code>A</code> et <code>B</code> valent <code>1</code> la somme vaut <code>2</code> et donc la sortie est nulle.</p>  Disjonction exclusive \\(A \\veebar B\\) \\(A=0\\) \\(A=1\\) \\(B=0\\) 0 1 \\(B=1\\) 1 0 <p>L'op\u00e9ration pr\u00e9sente une propri\u00e9t\u00e9 tr\u00e8s int\u00e9ressante\u2009: elle est r\u00e9versible.</p> <pre><code>assert(1542 ^ 42 ^ 42 == 1542)\n</code></pre> <p>Par exemple il est possible d'inverser la valeur de deux variables simplement\u2009:</p> <pre><code>int a = 123;\nint b = 651;\n\na ^= b;\nb ^= a;\na ^= b;\n\nassert(a == 651);\nassert(b == 123);\n</code></pre> <p>Attention</p> <p>Attention avec cet exemple, il ne fonctionne que si les deux valeurs <code>a</code> et <code>b</code> ont des adresses m\u00e9moires diff\u00e9rentes. Si les deux variables pointent vers la m\u00eame adresse m\u00e9moire, le r\u00e9sultat sera <code>0</code>.</p> <pre><code>int a = 123;\nint *b = &amp;a;\n\na ^= *b;\n*b ^= a;\na ^= *b;\n\nassert(a == 0);\nassert(*b == 0);\n</code></pre> <p></p>"}, {"location": "course-c/15-fundations/operators/#complement-a-un", "title": "Compl\u00e9ment \u00e0 un", "text": "<p>Le compl\u00e9ment \u00e0 un (\\(\\lnot\\)) est simplement la valeur qui permet d'inverser bit \u00e0 bit une valeur\u2009:</p>  Compl\u00e9ment \u00e0 un \\(A\\) \\(\\lnot~A\\) 0 1 1 0 <p>Info</p> <p>Pourquoi l'op\u00e9ration s'appelle le compl\u00e9ment \u00e0 un\u2009? Compl\u00e9menter \u00e0 \\(N\\) signifie trouver la valeur telle que \\(A + \\lnot A = N\\). Par exemple, en base 10, pour compl\u00e9menter \u00e0 \\(A = 9\\) il suffit de faire \\(9 - A\\).</p> <p>En base 10, le symbole le plus grand est <code>9</code>. En binaire le symbole le plus grand est <code>1</code>. Donc pour inverser un nombre on compl\u00e9mente chaque bit \u00e0 un.</p> <p> </p>"}, {"location": "course-c/15-fundations/operators/#decalages", "title": "D\u00e9calages", "text": "<p>Les op\u00e9rations de d\u00e9calage permettent de d\u00e9placer les bits d'une valeur vers la gauche ou vers la droite. Les bits d\u00e9cal\u00e9s sont perdus et remplac\u00e9s par des z\u00e9ros dans le cas d'une valeur non sign\u00e9e et par le bit de signe dans le cas d'une valeur sign\u00e9e.</p> <pre><code>assert(0b0000'1101 &lt;&lt; 2 == 0b0011'0100)\nassert(0b0001'0000 &gt;&gt; 4 == 0b0000'0001)\n\nchar a = 0b1000'0000;\nchar b = a &lt;&lt; 1;\nassert(b == 0x0000'0000);\n\nassert(-8 &gt;&gt; 1 == -4) // 0b1111'1000 &gt;&gt; 1 == 0b1111'1100\n</code></pre> <p>Avertissement</p> <p>Le standard ne d\u00e9finit pas le comportement des d\u00e9calages pour des valeurs de d\u00e9calage n\u00e9gatives (<code>a &gt;&gt; -2</code>). N\u00e9anmoins il n'y aura pas d'erreur de compilation, le comportement est simplement ind\u00e9fini et le r\u00e9sultat d\u00e9pend donc du compilateur utlis\u00e9.</p>"}, {"location": "course-c/15-fundations/operators/#tester-un-bit", "title": "Tester un bit", "text": "<p>En micro-informatique, il est fr\u00e9quent de tester l'\u00e9tat d'un bit. Pour cela on utilise l'op\u00e9ration ET logique <code>&amp;</code> avec un masque. Par exemple, pour tester le bit de poids faible d'une valeur, <code>a</code> on peut \u00e9crire\u2009:</p> <pre><code>int a = 0b1101'1010;\nint mask = 0b0000'0001;\n\nif (a &amp; mask) {\n    printf(\"Le bit de poids faible est \u00e0 1.\\n\");\n} else {\n    printf(\"Le bit de poids faible est \u00e0 0.\\n\");\n}\n</code></pre> <p>En pratique il est pr\u00e9f\u00e9rable de num\u00e9roter le bit que l'on souhaite tester pour plus de clart\u00e9. On peut positionner un bit \u00e0 la position souhait\u00e9e avec l'op\u00e9ration de d\u00e9calage <code>&lt;&lt;</code> :</p> <pre><code>int a = 0b1101'1010;\nint bit = 1;\nprintf(\"Le bit %d \u00e0 %d.\\n\", bit, a &amp; (1 &lt;&lt; bit));\n</code></pre>"}, {"location": "course-c/15-fundations/operators/#inverser-un-bit", "title": "Inverser un bit", "text": "<p>Pour inverser un bit, on utilise l'op\u00e9ration XOR <code>^</code> avec un masque. Par exemple, pour inverser le bit de poids faible d'une valeur <code>a</code> on peut \u00e9crire\u2009:</p> <pre><code>int a = 0b1101'1010;\nint bit = 3;\nint b = a ^ (1 &lt;&lt; bit);\n</code></pre>"}, {"location": "course-c/15-fundations/operators/#forcer-un-bit-a-un", "title": "Forcer un bit \u00e0 un", "text": "<p>Pour forcer un bit \u00e0 un, on utilise l'op\u00e9ration OU <code>|</code> avec un masque. Par exemple, pour forcer le bit de poids faible d'une valeur <code>a</code> \u00e0 un on peut \u00e9crire\u2009:</p> <pre><code>int a = 0b1101'1010;\nint bit = 2;\nint b = a | (1 &lt;&lt; bit);\n</code></pre>"}, {"location": "course-c/15-fundations/operators/#forcer-un-bit-a-zero", "title": "Forcer un bit \u00e0 z\u00e9ro", "text": "<p>Pour forcer un bit \u00e0 z\u00e9ro, on utilise l'op\u00e9ration ET <code>&amp;</code> avec un masque invers\u00e9. Par exemple, pour forcer le bit de poids faible d'une valeur <code>a</code> \u00e0 z\u00e9ro on peut \u00e9crire\u2009:</p> <pre><code>int a = 0b1101'1010;\nint bit = 4;\nint b = a &amp; ~(1 &lt;&lt; bit);\n</code></pre>"}, {"location": "course-c/15-fundations/operators/#operations-logiques", "title": "Op\u00e9rations logiques", "text": "<p>Les op\u00e9rateurs logiques sont au nombre de deux et ne doivent pas \u00eatre confondus avec leur petits fr\u00e8res <code>&amp;</code> et <code>|</code>.</p>  Op\u00e9rateurs arithm\u00e9tiques Op\u00e9rateur ISO646 Description Assertion vraie <code>&amp;&amp;</code> and ET logique <code>true &amp;&amp; false == false</code> <code>||</code> or OU logique <code>true || false == true</code> <p>Le r\u00e9sultat d'une op\u00e9ration logique est toujours un <code>bool\u00e9en</code> (valeur 0 ou 1). Ainsi l'expression suivante affecte <code>1</code> \u00e0 <code>x</code> : <code>x = 12 &amp;&amp; 3 + 2</code>.</p> <p>La priorit\u00e9 des op\u00e9rateurs logiques est plus faible que celle des op\u00e9rateurs de comparaison et plus forte que celle des op\u00e9rateurs d'affectation. Ainsi l'expression <code>a == b &amp;&amp; c == d</code> est \u00e9quivalente \u00e0 <code>(a == b) &amp;&amp; (c == d)</code>. Les parenth\u00e8ses sont facultatives, mais permettent de clarifier l'expression.</p> <p>Avertissement</p> <p>La priorit\u00e9 de l'op\u00e9rateur <code>&amp;&amp;</code> est plus forte que celle de l'op\u00e9rateur <code>||</code>. Ainsi l'expression <code>a || b &amp;&amp; c</code> est \u00e9quivalente \u00e0 <code>a || (b &amp;&amp; c)</code>. C'est un pi\u00e8ge classique en programmation, pour l'\u00e9viter il est recommand\u00e9 d'utiliser des parenth\u00e8ses.</p> <p>Confusion <code>&amp;</code> et <code>&amp;&amp;</code></p> <p>Confondre le ET logique et le ET binaire est courant. Dans l'exemple suivant, le <code>if</code> n'est jamais ex\u00e9cut\u00e9\u2009:</p> <pre><code>int a = 0xA;\nint b = 0x5;\n\nif(a &amp; b) {\n\n}\n</code></pre>"}, {"location": "course-c/15-fundations/operators/#operateurs-daffectation", "title": "Op\u00e9rateurs d'affectation", "text": "<p>Les op\u00e9rateurs d'affectation permettent d'assigner de nouvelles valeurs \u00e0 une variable. En C, il existe des sucres syntaxiques permettant de simplifier l'\u00e9criture lorsqu'une affectation est coupl\u00e9e \u00e0 un autre op\u00e9rateur.</p> <p>Originellement, la syntaxe h\u00e9rit\u00e9e de l'Algol-68 \u00e9tait de positionner le symbole <code>=</code> \u00e0 gauche suivi de l'op\u00e9rateur arithm\u00e9tique. Cette forme \u00e9tait confuse car elle pouvait mener \u00e0 des incoh\u00e9rences d'\u00e9criture. Par exemple, l'expression <code>x =- 3</code> peut \u00eatre confondue avec <code>x = -3</code>. Pour \u00e9viter ces ambigu\u00eft\u00e9s, le C a invers\u00e9 la logique en pla\u00e7ant l'op\u00e9rateur arithm\u00e9tique \u00e0 gauche de l'op\u00e9rateur d'affectation. L'histoire apporte parfois des r\u00e9ponses l\u00e0 o\u00f9 la logique \u00e9choue...</p> <p>Voici la liste des diff\u00e9rents op\u00e9rateurs d'affectation\u2009:</p>  Op\u00e9rateurs d'affectation Op\u00e9rateur Description Exemple \u00c9quivalence <code>=</code> Affectation simple <code>x = y</code> <code>x = y</code> <code>+=</code> Affectation par addition <code>x += y</code> <code>x = x + y</code> <code>-=</code> Affectation par soustraction <code>x -= y</code> <code>x = x - y</code> <code>*=</code> Affectation par multiplication <code>x *= y</code> <code>x = x * y</code> <code>/=</code> Affectation par division <code>x /= y</code> <code>x = x / y</code> <code>%=</code> Affectation par modulo <code>x %= y</code> <code>x = x % y</code> <code>&amp;=</code> Affectation par conjonction <code>x &amp;= y</code> <code>x = x &amp; y</code> <code>|=</code> Affectation par disjonction <code>x |= y</code> <code>x = x | y</code> <code>^=</code> Affectation par XOR <code>x ^= y</code> <code>x = x ^ y</code> <code>&lt;&lt;=</code> Affectation par d\u00e9calage gauche <code>x &lt;&lt;= y</code> <code>x = x &lt;&lt; y</code> <code>&gt;&gt;=</code> Affectation par d\u00e9calage droite <code>x &gt;&gt;= y</code> <code>x = x &gt;&gt; y</code> <p>Un op\u00e9rateur d'affectation implique que la valeur \u00e0 gauche de l'\u00e9galit\u00e9 soit modifiable (lvalue). Ainsi l'expression <code>3 += 2</code> est incorrecte, car <code>3</code> est une constante et ne peut \u00eatre modifi\u00e9e.</p> <p>Exercise\u2009: R-value</p> <p>Est-ce que l'expression suivante est valide\u2009?</p> <pre><code>int a, b, c = 42;\na + b = c;\n</code></pre> <ul> <li>     Oui car la destination est une lvalue </li> <li>     Non car la destination est une rvalue </li> </ul> Solution <p>L'op\u00e9ration <code>+</code> entre deux nombre retourne une rvalue et ne peut donc pas \u00eatre affect\u00e9. L'expression est donc invalide.</p>"}, {"location": "course-c/15-fundations/operators/#operateurs-dincrementation", "title": "Op\u00e9rateurs d'incr\u00e9mentation", "text": "<p>Les op\u00e9rateurs d'incr\u00e9mentation sont r\u00e9guli\u00e8rement un motif primaire d'arrachage de cheveux pour les \u00e9tudiants. En effet, ces op\u00e9rateurs sont tr\u00e8s particuliers en ce sens qu'il se d\u00e9composent en deux \u00e9tapes\u2009: l'affectation et l'obtention du r\u00e9sultat. Il existe 4 op\u00e9rateurs d'incr\u00e9mentation\u2009:</p>  Op\u00e9rateurs arithm\u00e9tiques Op\u00e9rateur Description Assertion vraie <code>()++</code> Post-incr\u00e9mentation <code>i++</code> <code>++()</code> Pr\u00e9-incr\u00e9mentation <code>++i</code> <code>()--</code> Post-d\u00e9cr\u00e9mentation <code>i--</code> <code>--()</code> Pr\u00e9-d\u00e9cr\u00e9mentation <code>--i</code> <p>Ces op\u00e9rateurs furent con\u00e7u initialement par Ken Thompson pour le langage B, le pr\u00e9d\u00e9cesseur du C. Ils ont \u00e9t\u00e9 repris par Dennis Ritchie pour le C. Une croyance est que ces op\u00e9rateurs furent rest\u00e9s dans le langage car le PDP-11, la machine sur laquelle le C fut d\u00e9velopp\u00e9, poss\u00e9dait des instructions sp\u00e9cifiques pour ces op\u00e9rations.</p> <p>La pr\u00e9-incr\u00e9mentation ou pr\u00e9-d\u00e9cr\u00e9mentation effectue en premier la modification de la variable impliqu\u00e9e puis retourne le r\u00e9sultat de cette variable modifi\u00e9e. Dans le cas de la post-incr\u00e9mentation ou pr\u00e9-d\u00e9cr\u00e9mentation, la valeur actuelle de la variable est d'abord retourn\u00e9e, puis dans un second temps cette variable est incr\u00e9ment\u00e9e.</p> <p>Notons qu'on peut toujours d\u00e9composer ces op\u00e9rateurs en deux instructions explicites. Le code\u2009:</p> Forme r\u00e9duiteForme \u00e9tendue <pre><code>y = x++;\n\ny = ++x;\n</code></pre> <pre><code>y = x;\nx = x + 1;\n\nx = x + 1;\ny = x;\n</code></pre> <p>Astuce</p> <p>Pour r\u00e9soudre les ambigu\u00eft\u00e9s, on proc\u00e8de par \u00e9tape. Par exemple l'expression suivante n'est pas tr\u00e8s claire\u2009:</p> <pre><code>k = i++ * 4 + --j * 2\n</code></pre> <ol> <li> <p>On commence par r\u00e9soudre les pr\u00e9-incr\u00e9mentation et pr\u00e9-d\u00e9cr\u00e9mentation\u2009:</p> <pre><code>j = j - 1;\nk = i++ * 4 + j * 2\n</code></pre> </li> <li> <p>Ensuite on r\u00e9sout les post-incr\u00e9mentation\u2009:</p> <pre><code>j = j - 1;\nk = i * 4 + j * 2\ni = i + 1;\n</code></pre> </li> <li> <p>On peut utiliser les sucres syntaxiques pour simplifier l'\u00e9criture\u2009:</p> <pre><code>j -= 1;\nk = i * 4 + j * 2\ni += 1;\n</code></pre> </li> </ol> <p>\u00c9criture d\u00e9routante</p> <p>Selon la table de pr\u00e9c\u00e9dences on aura <code>i--</code> calcul\u00e9 en premier suivi de <code>- -j</code>:</p> <pre><code>k = i----j;\n</code></pre> <p>Observations\u2009:</p> <ul> <li>\u00c9viter les formes ambig\u00fces d'\u00e9criture</li> <li>Favoriser la pr\u00e9c\u00e9dence explicite en utilisant des parenth\u00e8ses</li> <li>S\u00e9parez vos op\u00e9rations par des espaces pour plus de lisibilit\u00e9\u2009: <code>k = i-- - -j</code></li> </ul> <p>Astuce</p> <p>Il est g\u00e9n\u00e9ralement pr\u00e9f\u00e9rable d'utiliser la pr\u00e9-incr\u00e9mentation ou la pr\u00e9-d\u00e9cr\u00e9mentation car elles sont plus efficaces. En effet, la post-incr\u00e9mentation ou la post-d\u00e9cr\u00e9mentation n\u00e9cessitent de stocker la valeur actuelle de la variable pour la retourner apr\u00e8s l'incr\u00e9mentation ou la d\u00e9cr\u00e9mentation.</p> <p>C'est particuli\u00e8rement le cas en C++ o\u00f9 la post-incr\u00e9mentation ou la post-d\u00e9cr\u00e9mentation n\u00e9cessitent de cr\u00e9er une copie de la variable avant de l'incr\u00e9menter ou de la d\u00e9cr\u00e9menter.</p> <p>En C++ on utilise la surcharge d'op\u00e9rateur pour d\u00e9finir le comportement de l'op\u00e9rateur <code>++</code> et <code>--</code> pour les classes personnalis\u00e9es. Ajouter \u00e0 une classe ce type de surcharge se fait comme ceci\u2009:</p> <pre><code>class MyClass {\npublic:\n    // Pr\u00e9-incr\u00e9mentation\n    auto operator++() {\n        return *this;\n    }\n\n    // Post-incr\u00e9mentation\n    auto operator++(int) {\n        MyClass tmp(*this);\n        operator++();\n        return tmp;\n    }\n};\n</code></pre> <p>On voit que la post-incr\u00e9mentation cr\u00e9e une copie de l'objet avant de l'incr\u00e9menter, elle est donc moins efficace.</p> <p>Donc dans une boucle <code>for</code> on pr\u00e9f\u00e9rera\u2009:</p> <pre><code>for (int i = 0; i &lt; 10; ++i) { }\n</code></pre> <p>Plut\u00f4t que</p> <pre><code>for (int i = 0; i &lt; 10; i++) { }\n</code></pre> <p></p>"}, {"location": "course-c/15-fundations/operators/#operateur-ternaire", "title": "Op\u00e9rateur ternaire", "text": "<p>L'op\u00e9rateur ternaire aussi appel\u00e9 op\u00e9rateur conditionnel permet de faire un test et de retourner soit le second op\u00e9rande, soit le troisi\u00e8me op\u00e9rande. C'est le seul op\u00e9rateur du C avec une <code>arit\u00e9</code> de 3. Chacun des op\u00e9randes est symbolis\u00e9 avec une paire de parenth\u00e8ses\u2009:</p> <pre><code>()?():()\n</code></pre> <p>Cet op\u00e9rateur permet sur une seule ligne d'\u00e9valuer une expression et de renvoyer une valeur ou une autre selon que l'expression est vraie ou fausse.</p> <pre><code>valeur = (condition ? valeur si condition vraie : valeur si condition fausse);\n</code></pre> <p>Note</p> <p>Seule la valeur utilis\u00e9e pour le r\u00e9sultat est \u00e9valu\u00e9e. Par exemple, dans le code <code>x &gt; y ? ++y : ++x</code>, seulement <code>x</code> ou <code>y</code> sera incr\u00e9ment\u00e9.</p> <p>On utilise volontiers cet op\u00e9rateur lorsque dans les deux cas d'un embranchement, la m\u00eame valeur est modifi\u00e9e\u2009:</p> <pre><code>if (a &gt; b)\n    max = a;\nelse\n    min = b;\n</code></pre> <p>On remarque dans cet exemple une r\u00e9p\u00e9tition <code>max =</code>. Une fa\u00e7on plus \u00e9l\u00e9gante et permettant de r\u00e9duire l'\u00e9criture est d'utiliser l'op\u00e9rateur ternaire\u2009:</p> <pre><code>max = a &gt; b ? a : b;\n</code></pre> <p>Avertissement</p> <p>Ne pas utiliser l'op\u00e9rateur ternaire si vous ne modifiez pas une valeur. L'op\u00e9rateur ternaire est un op\u00e9rateur de s\u00e9lection et non de modification.</p> Bon exempleMauvais exemple <pre><code>int max = a &gt; b ? a : b;\n</code></pre> <pre><code>a &gt; b ? max = a : min = b;\n</code></pre> <p>Cela va de m\u00eame pour afficher une valeur\u2009:</p> Bon exempleMauvais exemple <pre><code>printf(\"Le maximum est %d\\n\", a &gt; b ? a : b);\n</code></pre> <pre><code>a &gt; b ? printf(\"Le maximum est %d\\n\", a) : printf(\"Le maximum est %d\\n\", b);\n</code></pre> <p>Enfin, on notera que le r\u00e9sultat de l'op\u00e9rateur ternaire est une rvalue et ne peut donc pas \u00eatre modifi\u00e9e.</p> <p></p>"}, {"location": "course-c/15-fundations/operators/#operateur-de-transtypage", "title": "Op\u00e9rateur de transtypage", "text": "<p>Le <code>transtypage</code> ou cast permet de modifier explicitement le type apparent d'une variable. C'est un op\u00e9rateur particulier, car son premier op\u00e9rande doit \u00eatre un type et le second une valeur.</p> <pre><code>(type)(valeur)\n</code></pre> <p>Dans l'exemple suivant, le r\u00e9sultat de la division est un entier, car la promotion implicite de type reste un entier <code>int</code>. La valeur <code>c</code> vaudra donc le r\u00e9sultat de la division enti\u00e8re alors que dans le second cas, <code>b</code> est cast\u00e9 en un <code>double</code> ce qui force une division en virgule flottante.</p> <pre><code>int a = 5, b = 2;\ndouble c = a / b;\ndouble d = a / (double)(b);\nassert(c == 2.0 &amp;&amp; d == 2.5);\n</code></pre> <p></p>"}, {"location": "course-c/15-fundations/operators/#operateur-sequentiel", "title": "Op\u00e9rateur s\u00e9quentiel", "text": "<p>L'op\u00e9rateur s\u00e9quentiel (comma operator) permet l'ex\u00e9cution ordonn\u00e9e d'op\u00e9rations, et retourne la derni\u00e8re valeur. Son utilisation est couramment limit\u00e9e, soit aux d\u00e9clarations de variables, soit au boucles <code>for</code>:</p> <pre><code>for (size_t i = 0, j = 10; i != j; i++, j--) { /* ... */ }\n</code></pre> <p>Dans le cas ci-dessus, il n'est pas possible de s\u00e9parer les instructions <code>i++</code> et <code>j--</code> par un point-virgule, l'op\u00e9rateur virgule permet alors de combiner plusieurs instructions en une seule.</p> <p>Une particularit\u00e9 de cet op\u00e9rateur est que seule la derni\u00e8re valeur est retourn\u00e9e\u2009:</p> <pre><code>assert(3 == (1, 2, 3))\n</code></pre> <p>L'op\u00e9rateur agit \u00e9galement comme un Point de s\u00e9quence , c'est-\u00e0-dire que l'ordre des \u00e9tapes est respect\u00e9.</p> <p>Exercise\u2009: Op\u00e9rateur s\u00e9quentiel</p> <p>Que sera-t-il affich\u00e9 \u00e0 l'\u00e9cran\u2009?</p> <pre><code>int i = 0;\nprintf(\"%d\", (++i, i++, ++i));\n</code></pre>"}, {"location": "course-c/15-fundations/operators/#operateur-sizeof", "title": "Op\u00e9rateur sizeof", "text": "<p>Cet op\u00e9rateur est unaire et retourne la taille en byte de la variable ou du type pass\u00e9 en argument. Il n'existe pas de symbole particulier et son usage est tr\u00e8s similaire \u00e0 l'appel d'une fonction\u2009:</p> <pre><code>int32_t foo = 42;\nassert(sizeof(foo) == 4);\nassert(sizeof(int64_t) == 64 / 8);\n</code></pre> <p>L'op\u00e9rateur <code>sizeof</code> est tr\u00e8s utile durant le d\u00e9bogage pour conna\u00eetre la taille en m\u00e9moire d'une variable ou celle d'un type. On l'utilise en pratique pour conna\u00eetre la taille d'un tableau lors d'une boucle it\u00e9rative\u2009:</p> <pre><code>int32_t array[128];\nfor (int i = 0; i &lt; sizeof(array) / sizeof(array[0]); i++) {\n   array[i] = i * 10;\n}\n</code></pre> <p>Dans l'exemple ci-dessus, <code>sizeof(array)</code> retourne la taille de l'espace m\u00e9moire occup\u00e9 par le tableau <code>array</code>, soit \\(128 \\cdot 4\\) bytes. Pour obtenir le nombre d'\u00e9l\u00e9ments dans le tableau, il faut alors diviser ce r\u00e9sultat par la taille effective de chaque \u00e9l\u00e9ment du tableau. L'\u00e9l\u00e9ment <code>array[0]</code> est donc un <code>int32_t</code> et sa taille vaut donc 4 bytes.</p> <p>Note</p> <p>Dans l'exemple ci-dessus, il est possible de s'affranchir de la taille effective du tableau en utilisant une sentinelle. Si le dernier \u00e9l\u00e9ment du tableau \u00e0 une valeur particuli\u00e8re et que le reste est initialis\u00e9 \u00e0 z\u00e9ro, il suffit de parcourir le tableau jusqu'\u00e0 cette valeur\u2009:</p> <pre><code>int32_t array[128] = { [127]=-1 };\nint i = 0;\nwhile (array[i] != -1) {\n    array[i++] = i * 10;\n}\n</code></pre> <p>Cette \u00e9criture reste malgr\u00e9 tout tr\u00e8s mauvaise, car le tableau de 128 \u00e9l\u00e9ments doit \u00eatre initialis\u00e9 \u00e0 priori ce qui m\u00e8ne aux m\u00eames performances. D'autre part l'histoire racont\u00e9e par le d\u00e9veloppeur est moins claire que la premi\u00e8re impl\u00e9mentation.</p>"}, {"location": "course-c/15-fundations/operators/#priorite-des-operateurs", "title": "Priorit\u00e9 des op\u00e9rateurs", "text": "<p>La pr\u00e9c\u00e9dence est un anglicisme de precedence (priorit\u00e9) qui concerne la priorit\u00e9 des op\u00e9rateurs, ou l'ordre dans lequel les op\u00e9rateurs sont ex\u00e9cut\u00e9s.</p> <p>Chacun conna\u00eet la priorit\u00e9 des quatre op\u00e9rateurs de base (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>), mais le C et ses nombreux op\u00e9rateurs sont bien plus complexes.</p> <p>La table suivante indique les r\u00e8gles \u00e0 suivre pour les pr\u00e9c\u00e9dences des op\u00e9rateurs en C.</p>  Priorit\u00e9 des op\u00e9rateurs Priorit\u00e9 Op\u00e9rateur Description  Associativit\u00e9 1  <code>++</code>, <code>--</code> Postfix incr\u00e9ments/d\u00e9cr\u00e9ments Gauche \u00e0 Droite  <code>()</code> Appel de fonction <code>[]</code> Indexage des tableaux <code>.</code> \u00c9l\u00e9ment d'une structure <code>-&gt;</code> \u00c9l\u00e9ment d'une structure 2  <code>++</code>, <code>--</code> Pr\u00e9fixe incr\u00e9ments/d\u00e9cr\u00e9ments Droite \u00e0 Gauche  <code>+</code>, <code>-</code> Signe <code>!</code>, <code>~</code> NON logique et NON binaire <code>(type)</code> Cast (Transtypage) <code>*</code> Indirection, d\u00e9r\u00e9f\u00e9rencement <code>&amp;</code> Adresse de... <code>sizeof</code> Taille de... 3 <code>*</code>, <code>/</code>, <code>%</code> Multiplication, Division, Mod Gauche \u00e0 Droite  4 <code>+</code>, <code>-</code> Addition, soustraction 5 <code>&lt;&lt;</code>, <code>&gt;&gt;</code> D\u00e9calages binaires 6  <code>&lt;</code>, <code>&lt;=</code> Comparaison plus petit que <code>&gt;</code>, <code>&gt;=</code> Comparaison plus grand que 7 <code>==</code>, <code>!=</code> \u00c9galit\u00e9, non \u00e9galit\u00e9 8 <code>&amp;</code> ET binaire 9 <code>^</code> OU exclusif binaire 10 <code>|</code> OU inclusif binaire 11 <code>&amp;&amp;</code> ET logique 12 <code>||</code> OU logique 13 <code>?:</code> Op\u00e9rateur ternaire Droite \u00e0 Gauche  14  <code>=</code> Assignation simple <code>+=</code>, <code>-=</code> Assignation par somme/diff <code>*=</code>, <code>/=</code>, <code>%=</code> Assignation par produit/quotient/modulo <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code> Assignation par d\u00e9calage binaire 15 <code>,</code> Virgule Gauche \u00e0 Droite <p>Consid\u00e9rons l'exemple suivant\u2009:</p> <pre><code>int i[2] = {10, 20};\nint y = 3;\n\nx = 5 + 23 + 34 / ++i[0] &amp; 0xFF &lt;&lt; y;\n</code></pre> <p>Selon la pr\u00e9c\u00e9dence de chaque op\u00e9rateur ainsi que son associativit\u00e9 on a\u2009:</p> <pre><code>[]  1\n++  2\n/   3\n+   4\n+   4\n&lt;&lt;  5\n&amp;   8\n=   14\n</code></pre> <p>Notation polonaise invers\u00e9e</p> <p>La notation polonaise invers\u00e9e (Reverse Polish Notation) est une notation math\u00e9matique o\u00f9 les op\u00e9rateurs sont plac\u00e9s apr\u00e8s leurs op\u00e9randes.</p> <p>L'\u00e9criture en notation polonaise invers\u00e9e donnerait alors\u2009:</p> <pre><code>34, i, 0, [], ++,  /, 5, 23, +, +, 0xFF, y, &lt;&lt;, &amp;, x, =\n</code></pre> <p>C'est une notation tr\u00e8s utilis\u00e9e en informatique pour les calculatrices et les compilateurs car elle permet de simplifier l'\u00e9criture des expressions math\u00e9matiques, et surtout s'affranchir du probl\u00e8me des priorit\u00e9s d'op\u00e9rateurs.</p> <p>L'algorithme de Shunting Yard permet de convertir une expression en notation infix\u00e9e en une expression en notation polonaise invers\u00e9e.</p>"}, {"location": "course-c/15-fundations/operators/#associativite", "title": "Associativit\u00e9", "text": "<p>L'associativit\u00e9 des op\u00e9rateurs (operator associativity) d\u00e9crit la mani\u00e8re dont sont \u00e9valu\u00e9es les expressions.</p> <p>Une associativit\u00e9 \u00e0 gauche pour l'op\u00e9rateur <code>~</code> signifie que l'expression <code>a ~ b ~ c</code> sera \u00e9valu\u00e9e <code>((a) ~ b) ~ c</code> alors qu'une associativit\u00e9 \u00e0 droite sera <code>a ~ (b ~ (c))</code>.</p> <p>Note qu'il ne faut pas confondre l'associativit\u00e9 \u00e9valu\u00e9e de gauche \u00e0 droite qui est une associativit\u00e9 \u00e0 gauche.</p>"}, {"location": "course-c/15-fundations/operators/#promotion-de-type", "title": "Promotion de type", "text": "<p>Nous avons vu au chapitre sur les types de donn\u00e9es que les types C d\u00e9finis par d\u00e9faut sont repr\u00e9sent\u00e9s en m\u00e9moire sur 1, 2, 4 ou 8 octets. On comprend ais\u00e9ment que plus cette taille est importante, plus on gagne en pr\u00e9cision ou en grandeur repr\u00e9sentable. La promotion num\u00e9rique r\u00e9git les conversions effectu\u00e9es implicitement par le langage C lorsqu'on convertit une donn\u00e9e d'un type vers un autre. Cette promotion tend \u00e0 conserver le maximum de pr\u00e9cision lorsqu'on effectue des calculs entre types diff\u00e9rents (p.ex\u2009: l'addition d'un <code>int</code> avec un <code>double</code> donne un type <code>double</code>). Voici les r\u00e8gles de base\u2009:</p> <ul> <li>les op\u00e9rateurs ne peuvent agir que sur des types identiques\u2009;</li> <li>quand les types sont diff\u00e9rents, il y a conversion automatique vers le type ayant le plus grand pouvoir de repr\u00e9sentation\u2009;</li> <li>les conversions ne sont faites qu'au fur et \u00e0 mesure des besoins.</li> </ul> <p>La promotion est l'action de promouvoir un type de donn\u00e9e en un autre type de donn\u00e9e plus g\u00e9n\u00e9ral. On parle de promotion implicite des entiers lorsqu'un type est promu en un type plus grand automatiquement par le compilateur.</p>"}, {"location": "course-c/15-fundations/operators/#lois-de-de-morgan", "title": "Lois de De Morgan", "text": "<p>Les lois de De Morgan sont des identit\u00e9s logiques formul\u00e9es il y a pr\u00e8s de deux si\u00e8cles par Augustus De Morgan (1806-1871). \u00c0 noter que l'on peut prononcer d\u0259 m\u0254\u0281.g\u0251\u0303 (de Mort Gant) ou d\u0259 m\u0254\u0281.\u0261an (de Morgane).</p> <p>En logique classique, la n\u00e9gation d'une conjonction implique la disjonction des n\u00e9gations et la conjonction de n\u00e9gations implique la n\u00e9gation d'une disjonction. On peut donc \u00e9crire les relations suivantes\u2009:</p> \\[ \\begin{aligned} &amp; \\overline{P \\land Q} &amp;\\Rightarrow~&amp; \\overline{P} \\lor \\overline{Q} \\\\ &amp; \\overline{P} \\land \\overline{Q} &amp;\\Rightarrow~&amp; \\overline{P \\lor Q} \\end{aligned} \\] <p>Ces op\u00e9rations logiques sont tr\u00e8s utiles en programmation o\u00f9 elles permettent de simplifier certains algorithmes.</p> <p>\u00c0 titre d'exemple, les op\u00e9rations suivantes sont \u00e9quivalentes\u2009:</p> <pre><code>int a = 0b110010011;\nint b = 0b001110101;\n\nassert(a | b == ~a &amp; ~b);\nassert(~a &amp; ~b == ~(a | b));\n</code></pre> <p>En logique bool\u00e9enne on exprime la n\u00e9gation par une barre p.ex. \\(\\overline{P}\\).</p> <p>Exercise\u2009: De Morgan</p> <p>Utiliser les relations de De Morgan pour simplifier l'expression suivante</p> \\[ D \\cdot E + \\overline{D} + \\overline{E} \\] Solution <p>Si l'on applique De Morgan (\\(\\overline{XY} = \\overline{X} + \\overline{Y}\\)):</p> \\[ D \\cdot E + \\overline{D} + \\overline{E} \\]"}, {"location": "course-c/15-fundations/operators/#arrondis", "title": "Arrondis", "text": "<p>En programmation, la notion d'arrondi (rounding) est beaucoup plus d\u00e9licate que l'on peut l'imaginer de prime abord.</p> <p>Un nombre r\u00e9el dans \\(\\mathbb{R}\\) peut \u00eatre converti en un nombre entier de plusieurs mani\u00e8res dont voici une liste non exhaustive\u2009:</p> <ul> <li>tronqu\u00e9 (truncate) lorsque la partie fractionnaire est simplement enlev\u00e9e\u2009;</li> <li>arrondi \u00e0 l'entier sup\u00e9rieur (rounding up) ;</li> <li>arrondi \u00e0 l'entier inf\u00e9rieur (rounding down) ;</li> <li>arrondi en direction du z\u00e9ro (rounding towards zero) ;</li> <li>arrondi loin du z\u00e9ro (rounding away from zero) ;</li> <li>arrondi au plus proche entier (rounding to the nearest integer) ;</li> <li>arrondi la moiti\u00e9 en direction de l'infini (rounding half up).</li> </ul> <p>Selon le langage de programmation et la m\u00e9thode utilis\u00e9e, le m\u00e9canisme d'arrondi sera diff\u00e9rent. En C, la biblioth\u00e8que math\u00e9matique offre les fonctions <code>ceil</code> pour l'arrondi au plafond (entier sup\u00e9rieur), <code>floor</code> pour arrondi au plancher (entier inf\u00e9rieur) et <code>round</code> pour l'arrondi au plus proche (nearest). Il existe \u00e9galement une fonction <code>trunc</code> qui tronque la valeur en supprimant la partie fractionnaire.</p> <p>Le fonctionnement de la fonction <code>round</code> n'est pas unanime entre les math\u00e9maticiens et les programmeurs. C utilise l'arrondi au plus proche, c'est-\u00e0-dire que -23.5 donne -24 et 23.5 donnent 24.</p> <p>En Python ou en Java, c'est la m\u00e9thode du commercial rounding qui a \u00e9t\u00e9 choisie. Elle peut para\u00eetre contre-intuitive, car <code>round(3.5)</code> donne 4, mais <code>round(4.5)</code> donne 4 aussi.</p> <p>Pourquoi faire cela\u2009? Il y a deux raisons principales\u2009:</p> <ol> <li> <p>R\u00e9duction du biais cumulatif : Lorsque vous arrondissez toujours vers le haut ou vers le bas en cas de valeur \u00e0 mi-chemin (comme 0.5), cela introduit un biais syst\u00e9matique dans vos donn\u00e9es. Par exemple, si vous arrondissez toujours 0.5 vers le haut, la somme des valeurs arrondies sera syst\u00e9matiquement plus grande que la somme des valeurs originales.</p> </li> <li> <p>Statistiques plus pr\u00e9cises : En arrondissant les valeurs \u00e0 la paire la plus proche, vous distribuez les erreurs d'arrondissement de mani\u00e8re plus \u00e9quitable, ce qui donne des statistiques globales plus pr\u00e9cises.</p> </li> </ol> <p>Supposons que nous avons les montants suivants\u2009:</p> <pre><code>3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5\n</code></pre> <p>En utilisant l'arrondi classique (toujours vers le haut \u00e0 0.5), nous obtenons\u2009:</p> <pre><code>4 + 5 + 6 + 7 + 8 + 9 + 10 = 49\n</code></pre> <p>En utilisant l'arrondi commercial, nous obtenons\u2009:</p> <pre><code>4 + 4 + 6 + 6 + 8 + 8 + 10 = 46\n</code></pre> <p>Si on compare \u00e0 la somme r\u00e9elle des valeurs, on obtient\u2009:</p> <pre><code>3.5 + 4.5 + 5.5 + 6.5 + 7.5 + 8.5 + 9.5 = 45.5\n</code></pre> <p>La m\u00e9thode round half to even donne une somme arrondie (46) qui est plus proche de la somme r\u00e9elle (45.5) que la m\u00e9thode classique (49).</p> <p>L'utilisation cette m\u00e9thode est particuli\u00e8rement utile dans les domaines o\u00f9 l'exactitude statistique est cruciale et o\u00f9 les erreurs d'arrondissement peuvent s'accumuler sur de grands ensembles de donn\u00e9es, comme en finance, en analyse de donn\u00e9es, et en statistiques.</p> <p> </p>"}, {"location": "course-c/15-fundations/operators/#valeurs-gauches", "title": "Valeurs gauches", "text": "<p>Une <code>valeur gauche</code> (<code>lvalue</code>) est une particularit\u00e9 de certains langages de programmation qui d\u00e9finissent ce qui peut se trouver \u00e0 gauche d'une affectation. Ainsi dans <code>x = y</code>, <code>x</code> est une valeur gauche. N\u00e9anmoins, l'expression <code>x = y</code> est aussi une valeur gauche\u2009:</p> <pre><code>int x, y, z;\n\nx = y = z;    // 1\n(x = y) = z;  // 2\n</code></pre> <ol> <li> <p>L'associativit\u00e9 de <code>=</code> est \u00e0 droite donc cette expression est \u00e9quivalente \u00e0 <code>x = (y = (z))</code> qui \u00e9vite toute ambigu\u00eft\u00e9.</p> </li> <li> <p>En for\u00e7ant l'associativit\u00e9 \u00e0 gauche, on essaie d'assigner <code>z</code> \u00e0 une lvalue et le compilateur s'en plaint\u2009:</p> </li> </ol> <pre><code>4:8: error: lvalue required as left operand of assignment\n  (x = y) = z;\n          ^\n</code></pre> <p>Voici quelques exemples de valeurs gauches\u2009:</p> <ul> <li><code>x /= y</code></li> <li><code>++x</code></li> <li><code>(x ? y : z)</code></li> </ul> <p>Par analogie une rvalue est une valeur qui ne peut se trouver \u00e0 gauche d'une affectation. Ainsi <code>x + y</code> est une rvalue car elle ne peut \u00eatre affect\u00e9e. De m\u00eame que <code>x++</code> est une rvalue car elle ne peut \u00eatre affect\u00e9e.</p>"}, {"location": "course-c/15-fundations/operators/#optimisation", "title": "Optimisation", "text": "<p>Le compilateur est en r\u00e8gle g\u00e9n\u00e9ral plus malin que le d\u00e9veloppeur. L'optimiseur de code (lorsque compil\u00e9 avec <code>-O2</code> sous <code>gcc</code>), va regrouper certaines instructions, modifier l'ordre de certaines d\u00e9clarations pour r\u00e9duire soit l'empreinte m\u00e9moire du code, soit acc\u00e9l\u00e9rer son ex\u00e9cution.</p> <p>Ainsi l'expression suivante, ne sera pas calcul\u00e9e \u00e0 l'ex\u00e9cution, mais \u00e0 la compilation\u2009:</p> <pre><code>int num = (4 + 7 * 10) &gt;&gt; 2;\n</code></pre> <p>De m\u00eame que ce test n'effectuera pas une division, mais testera simplement le dernier bit de <code>a</code>:</p> <pre><code>if (a % 2) {\n    puts(\"Pair\");\n} else {\n    puts(\"Impair\");\n}\n</code></pre>"}, {"location": "course-c/15-fundations/operators/#isoiec-646", "title": "ISO/IEC 646", "text": "<p>La biblioth\u00e8que standard <code>&lt;iso646.h&gt;</code> appartient \u00e0 la norme C90 et d\u00e9finit des macros pour les op\u00e9rateurs logiques. Ces macros sont les suivantes\u2009:</p>  Macros de l'ISO/IEC 646 Op\u00e9rateur Macro Description <code>&amp;&amp;</code> <code>and</code> ET logique <code>\\|\\|</code> <code>or</code> OU logique <code>!</code> <code>not</code> NON logique <code>!=</code> <code>not_eq</code> Diff\u00e9rent de <code>&amp;=</code> <code>and_eq</code> ET binaire <code>\\|=</code> <code>or_eq</code> OU binaire <code>^=</code> <code>xor_eq</code> OU exclusif binaire <code>^</code> <code>xor</code> OU exclusif binaire <code>~</code> <code>compl</code> Compl\u00e9ment binaire <p>Ces macros sont utiles pour les personnes qui ne peuvent pas taper certains caract\u00e8res sp\u00e9ciaux sur leur clavier. Elles sont \u00e9galement utiles pour les personnes qui veulent rendre leur code plus lisible. N\u00e9anmoins, elles ne sont pas tr\u00e8s utilis\u00e9es en pratique.</p> <pre><code>#include &lt;iso646.h&gt;\n\nint foo(int a, int b, int c) {\n    return a and b or not c;\n}\n</code></pre>"}, {"location": "course-c/15-fundations/operators/#exercices-de-revision", "title": "Exercices de r\u00e9vision", "text": "<p>Exercise\u2009: Parenth\u00e8ses superflues</p> <p>Dans les expressions suivantes, lesquelles contiennent des parenth\u00e8ses superflues qui peuvent \u00eatre retir\u00e9es sans changer le sens de l'expression\u2009?</p> <ul> <li> <code>a = (b + c) * d</code> </li> <li> <code>a = b + (c * d)</code> </li> <li> <code>(a &lt; b) &amp;&amp; (c &gt; d)</code> </li> <li> <code>a = (b + c) / (d + e)</code> </li> <li> <code>(a &amp;&amp; b) || (c &amp;&amp; d)</code> </li> <li> <code>(a || b) &amp;&amp; (c || d)</code> </li> <li> <code>a = (b + c) % (d + e)</code> </li> </ul> <p>Exercise\u2009: Quelle priorit\u00e9</p> <p>Quel est l'op\u00e9rateur qui a la priorit\u00e9 la plus basse\u2009?</p> <ul> <li> <code>+</code> </li> <li> <code>*</code> </li> <li> <code>||</code> </li> <li> <code>&amp;&amp;</code> </li> </ul> <p>Exercise\u2009: Masque binaire</p> <p>Soit les d\u00e9clarations suivantes\u2009:</p> <pre><code>char m, n = 2, d = 0x55, e = 0xAA;\n</code></pre> <p>Repr\u00e9senter en binaire et en hexad\u00e9cimal la valeur de tous les bits de la variable <code>m</code> apr\u00e8s ex\u00e9cution de chacune des instructions suivantes\u2009:</p> <ol> <li><code>m = 1 &lt;&lt; n;</code></li> <li><code>m = ~1 &lt;&lt; n;</code></li> <li><code>m = ~(1 &lt;&lt; n);</code></li> <li><code>m = d | (1 &lt;&lt; n);</code></li> <li><code>m = e | (1 &lt;&lt; n);</code></li> <li><code>m = d ^ (1 &lt;&lt; n);</code></li> <li><code>m = e ^ (1 &lt;&lt; n);</code></li> <li><code>m = d &amp; ~(1 &lt;&lt; n);</code></li> <li><code>m = e &amp; ~(1 &lt;&lt; n);</code></li> </ol> <p>Exercise\u2009: Registre syst\u00e8me</p> <p>Pour programmer les registres 16-bits d'un composant \u00e9lectronique charg\u00e9 de g\u00e9rer des sorties tout ou rien, on doit \u00eatre capable d'effectuer les op\u00e9rations suivantes\u2009:</p> <ul> <li>mettre \u00e0 1 le bit num\u00e9ro <code>n</code>, <code>n</code> \u00e9tant un entier entre 0 et 15\u2009;</li> <li>mettre \u00e0 0 le bit num\u00e9ro <code>n</code>, <code>n</code> \u00e9tant un entier entre 0 et 15\u2009;</li> <li>inverser le bit num\u00e9ro <code>n</code>, <code>n</code> \u00e9tant un entier entre 0 et 15\u2009;</li> </ul> <p>Pour des questions d'efficacit\u00e9, ces op\u00e9rations ne doivent utiliser que les op\u00e9rateurs bit \u00e0 bit ou d\u00e9calage. On appelle <code>r0</code> la variable d\u00e9signant le registre en m\u00e9moire et <code>n</code> la variable contenant le num\u00e9ro du bit \u00e0 modifier. \u00c9crivez les expressions permettant d'effectuer les op\u00e9rations demand\u00e9es.</p> <p>Exercise\u2009: Recherche d'expressions</p> <p>Consid\u00e9rant les d\u00e9clarations suivantes\u2009:</p> <pre><code>float a, b;\nint m, n;\n</code></pre> <p>Traduire en C les expressions math\u00e9matiques ci-dessous\u2009; pour chacune, proposer plusieurs \u00e9critures diff\u00e9rentes lorsque c'est possible. Le symbole \\(\\leftarrow\\) signifie assignation</p> <ol> <li>\\(n \\leftarrow 8 \\cdot n\\)</li> <li>\\(a \\leftarrow a + 2\\)</li> <li>\\(n \\leftarrow \\left\\{\\begin{array}{lr}m &amp; : m &gt; 0\\\\ 0 &amp; : \\text{sinon}\\end{array}\\right.\\)</li> <li>\\(a \\leftarrow n\\)</li> <li>\\(n \\leftarrow \\left\\{\\begin{array}{lr}0 &amp; : m~\\text{pair}\\\\ 1 &amp; : m~\\text{impair}\\end{array}\\right.\\)</li> <li>\\(n \\leftarrow \\left\\{\\begin{array}{lr}1 &amp; : m~\\text{pair}\\\\ 0 &amp; : m~\\text{impair}\\end{array}\\right.\\)</li> <li>\\(m \\leftarrow 2\\cdot m + 2\\cdot n\\)</li> <li>\\(n \\leftarrow n + 1\\)</li> <li>\\(a \\leftarrow \\left\\{\\begin{array}{lr}-a &amp; : b &lt; 0\\\\ a &amp; : \\text{sinon}\\end{array}\\right.\\)</li> <li>\\(n \\leftarrow \\text{la valeur des 4 bits de poids faible de}~n\\)</li> </ol> <p>Exercise\u2009: Nombres narcissiques</p> <p>Un nombre narcissique ou nombre d'Amstrong est un entier naturel <code>n</code> non nul qui est \u00e9gal \u00e0 la somme des puissances <code>p</code>-i\u00e8mes de ses chiffres en base dix, o\u00f9 <code>p</code> d\u00e9signe le nombre de chiffres de <code>n</code>:</p> \\[ n=\\sum_{k=0}^{p-1}x_k10^k=\\sum_{k=0}^{p-1}(x_k)^p\\quad\\text{avec}\\quad x_k\\in\\{0,\\ldots,9\\}\\quad\\text{et}\\quad x_{p-1}\\ne 0 \\] <p>Par exemple\u2009:</p> <ul> <li><code>9</code> est un nombre narcissique, car \\(9 = 9^1 = 9\\)</li> <li><code>153</code> est un nombre narcissique, car \\(153 = 1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153\\)</li> <li><code>10</code> n'est pas un nombre narcissique, car \\(10 \\ne 1^2 + 0^2 = 1\\)</li> </ul> <p>Implanter un programme permettant de v\u00e9rifier si un nombre d'entr\u00e9es est narcissique ou non. L'ex\u00e9cution est la suivante\u2009:</p> <pre><code>$ ./armstrong 153\n1\n\n$ ./armstrong 154\n0\n</code></pre> <p>Exercise\u2009: Swap sans valeur interm\u00e9diaire</p> <p>Soit deux variables enti\u00e8res <code>a</code> et <code>b</code>, chacune contenant une valeur diff\u00e9rente. \u00c9crivez les instructions permettant d'\u00e9changer les valeurs de a et de b sans utiliser de valeurs interm\u00e9diaires. Indice\u2009: utilisez l'op\u00e9rateur XOR <code>^</code>.</p> <p>Testez votre solution...</p> Solution <pre><code>a ^= b;\nb ^= a;\na ^= b;\n</code></pre>"}, {"location": "course-c/15-fundations/preprocessor/", "title": "Pr\u00e9processeur", "text": "<p> Illustration du m\u00e9canisme de pr\u00e9-processing avant la compilation</p> <p>Comme nous l'avons vu en introduction (Texte structur\u00e9) le langage C est bas\u00e9 sur une double grammaire, c'est-\u00e0-dire qu'avant la compilation du code, un autre processus est appel\u00e9 visant \u00e0 pr\u00e9parer le code source avant la compilation.</p> <p>Le c\u0153ur de cette op\u00e9ration est appel\u00e9 pr\u00e9processeur. Les instructions du pr\u00e9processeur C sont faciles \u00e0 reconna\u00eetre, car elles d\u00e9butent toutes par le croisillon <code>#</code> 0023, hash en anglais et utilis\u00e9 r\u00e9cemment comme hashtag sur les r\u00e9seaux sociaux. Notons au passage que ce caract\u00e8re \u00e9tait historiquement utilis\u00e9 par les Anglais sous le d\u00e9nominatif pound (livre). Lorsqu'il est apparu en Europe, il a \u00e9t\u00e9 confondu avec le caract\u00e8re di\u00e8se <code>\u266f</code> 266F pr\u00e9sent sur les pav\u00e9s num\u00e9riques de t\u00e9l\u00e9phone.</p> <p>Le vocabulaire du pr\u00e9processeur est le suivant\u2009:</p> Terme Description <code>#include</code> Inclus un fichier dans le fichier courant <code>#define</code> Cr\u00e9e une d\u00e9finition (Macro) <code>#undef</code> D\u00e9truit une d\u00e9finition existante <code>#if defined</code> Teste si une d\u00e9finition existe <code>#if</code> .. <code>#endif</code> Test conditionnel <code>#</code> Op\u00e9rateur de conversion en cha\u00eene de caract\u00e8res <code>##</code> Op\u00e9rateur de concat\u00e9nation de cha\u00eenes <code>#error \"error message\"</code> G\u00e9n\u00e8re une erreur <code>#pragma</code> Directive sp\u00e9cifique au compilateur <p>Le pr\u00e9processeur C est ind\u00e9pendant du langage C, c'est-\u00e0-dire qu'il peut \u00eatre ex\u00e9cut\u00e9 sur n'importe quel type de fichier.</p> <p>Prenons l'exemple d'une lettre g\u00e9n\u00e9rique d'un cabinet dentaire\u2009:</p> <pre><code>#ifdef FEMALE\n#    define NAME Madame\n#else\n#    define NAME Monsieur\n#endif\nBonjour NAME,\n\nVeuillez noter votre prochain rendez-vous le DATE, \u00e0 HOUR heure.\n\nVeuillez agr\u00e9er, NAME, nos meilleures salutations,\n\n#ifdef IS_BOSS\nLe directeur\n#elif defined IS_ASSISTANT\nLa secr\u00e9taire du directeur\n#elif defined OWNER_NAME\nOWNER_NAME\n#else\n#    error \"Lettre sans signature\"\n#endif\n</code></pre> <p>Il est possible d'appeler le pr\u00e9processeur directement avec l'option <code>-E</code> de gcc. Des directives <code>define</code> peuvent \u00eatre renseign\u00e9es depuis la ligne de commande\u2009:</p> <pre><code>$ gcc -xc -E test.txt \\\n    -DDATE=22 -DHOUR=9:00 \\\n    -DFEMALE \\\n    -DOWNER_NAME=\"Adam\" -DPOSITION=employee\n# 1 \"test.txt\"\n# 1 \"&lt;built-in&gt;\"\n# 1 \"&lt;command-line&gt;\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 1 \"&lt;command-line&gt;\" 2\n# 1 \"test.txt\"\nBonjour Madame,\n\nVeuillez noter votre prochain rendez-vous le 22, \u00e0 9:00 heure.\n\nVeuillez agr\u00e9er, Madame, nos meilleures salutations,\n\nAdam\n</code></pre> <p>Notez que les instructions du pr\u00e9processeur (\u00e0 l'exception des op\u00e9rateurs de concat\u00e9nation de conversion en cha\u00eene de caract\u00e8re) sont des instructions de ligne (line-wise), et doivent se terminer par un caract\u00e8re de fin de ligne.</p>"}, {"location": "course-c/15-fundations/preprocessor/#phases-de-traduction", "title": "Phases de traduction", "text": "<p>Le standard d\u00e9crit quatre phases de pr\u00e9-processing\u2009:</p> <ol> <li>Remplacement des caract\u00e8res sp\u00e9ciaux, d\u00e9codage des trigraphes, traitement des fin de lignes.</li> <li>Fusionne les lignes utilisant un retour virtuel <code>\\</code>.</li> <li>Supprime les commentaires, d\u00e9compose les symboles du pr\u00e9processeur</li> <li>Ex\u00e9cute les directives du pr\u00e9processeur (<code>#define</code> et <code>#include</code>)</li> </ol>"}, {"location": "course-c/15-fundations/preprocessor/#extensions-des-fichiers", "title": "Extensions des fichiers", "text": "<p>Par convention, et selon le standard GNU, les extensions suivantes sont en vigueur\u2009:</p> <code>.h</code> <p>Fichier d'en-t\u00eate ne comportant que des d\u00e9finitions pr\u00e9processeur, des d\u00e9clarations (structures, unions ...) et des prototypes de fonction, mais aucun code ex\u00e9cutable. Ce fichier sera soumis au pr\u00e9processeur.</p> <code>.c</code> <p>Fichier source C comportant les impl\u00e9mentations de fonction et les variables globales. Ce fichier sera soumis au pr\u00e9processeur.</p> <code>.i</code> <p>Fichier source C qui ne sera pas soumis au pr\u00e9processeur\u2009: <code>gcc -E -o foo.i foo.c</code></p> <code>.s</code> <p>Fichier assembleur non soumis au pr\u00e9processeur.</p> <code>.S</code> <p>Fichier assembleur soumis au pr\u00e9processeur. Notons toutefois que cette convention n'est pas  applicable sous Windows, car le syst\u00e8me de fichier n'est pas sensible \u00e0 la casse.</p>"}, {"location": "course-c/15-fundations/preprocessor/#inclusion-de-fichiers", "title": "Inclusion de fichiers", "text": ""}, {"location": "course-c/15-fundations/preprocessor/#include", "title": "#include", "text": "<p>La directive include peut prendre deux formes, l'inclusion locale et l'inclusion globale. Il s'agit d'ailleurs de l'une des questions les plus pos\u00e9es (c.f. cette question.).</p> <code>#include &lt;filename&gt;</code> <p>Le pr\u00e9processeur va chercher le chemin du fichier \u00e0 inclure dans les chemins de l'impl\u00e9mentation.</p> <code>#include \"filename\"</code> <p>Le pr\u00e9processeur cherche le chemin du fichier \u00e0 partir du chemin courant et les chemins donn\u00e9s par les des directives <code>-I</code>.</p> <p>L'inclusion de fichier est simplement du remplacement de cha\u00eenes\u2009:</p> <pre><code>$ echo \"Ce d\u00e9but de phrase est ici\" &gt; head.h\n$ echo \", mais cette fin est l\u00e0.\" &gt; tail.h\n$ echo -e '#include \"head.h\"\\n#include \"tail.h\"\\n' &gt; main.c\n$ gcc -E main.c -o-\n# 1 \"main.c\"\n# 1 \"&lt;built-in&gt;\"\n# 1 \"&lt;command-line&gt;\"\n# 31 \"&lt;command-line&gt;\"\n# 1 \"/usr/include/stdc-predef.h\" 1 3 4\n# 32 \"&lt;command-line&gt;\" 2\n# 1 \"main.c\"\n# 1 \"head.h\" 1\nCe d\u00e9but de phrase est ici\n# 2 \"main.c\" 2\n# 1 \"tail.h\" 1\n, mais cette fin est l\u00e0.\n# 3 \"main.c\" 2\n</code></pre> <p>La directive <code>#include</code> est principalement utilis\u00e9e pour inclure des fichiers d'en-t\u00eate (header), mais rarement (jamais), des fichiers C.</p>"}, {"location": "course-c/15-fundations/preprocessor/#definitions", "title": "D\u00e9finitions", "text": ""}, {"location": "course-c/15-fundations/preprocessor/#define", "title": "#define", "text": "<p>Les d\u00e9finitions sont des symboles g\u00e9n\u00e9ralement \u00e9crits en majuscule et qui sont remplac\u00e9s par le pr\u00e9processeur. Ces d\u00e9finitions peuvent \u00eatre utiles pour d\u00e9finir des constantes globales qui sont d\u00e9finies \u00e0 la compilation\u2009:</p> <pre><code>#ifndef WINDOW_SIZE\n#    define WINDOW_SIZE 10\n#endif\n\nint tab[WINDOW_SIZE];\n\nvoid init(void) {\n    for(size_t i = 0; i &lt; WINDOW_SIZE; i++)\n        tab[i] = i;\n}\n</code></pre> <p>Il est ainsi possible de d\u00e9finir la taille du tableau \u00e0 la compilation avec\u2009:</p> <pre><code>$ gcc main.c -DWINDOW_SIZE=42\n</code></pre> <p>Notons qu'au pr\u00e9-processing, toute occurrence d'un symbole d\u00e9fini est remplac\u00e9e par le contenu de sa d\u00e9finition. C'est un remplacement de cha\u00eene b\u00eate, idiot et na\u00eff. Il est par cons\u00e9quent possible d'\u00e9crire\u2009:</p> <pre><code>#define MAIN int main(\n#define BEGIN ) {\n#define END return 0; }\n#define EOF \"\\n\"\n\nMAIN\nBEGIN\n    printf(\"Hello\" EOF);\nEND\n</code></pre> <p>On rel\u00e8vera qu'il est aussi possible de commettre certaines erreurs\u2009:</p> <pre><code>#define ADD a + b\n\nint a = 12;\nint b = 23;\nint c = ADD * ADD\n</code></pre> <p>Apr\u00e8s pr\u00e9-processing on aura un comportement non d\u00e9sir\u00e9, car la multiplication est plus prioritaire que l'addition.</p> <pre><code>#define ADD a + b\n\nint a = 12;\nint b = 23;\nint c = a + b * a + b\n</code></pre> <p>Pour se pr\u00e9munir contre ces \u00e9ventuelles coquilles, on prot\u00e8gera toujours les d\u00e9finitions avec des parenth\u00e8ses <code>#define ADD (a + b)</code>.</p> <p></p>"}, {"location": "course-c/15-fundations/preprocessor/#if-defined", "title": "#if defined", "text": ""}, {"location": "course-c/15-fundations/preprocessor/#if", "title": "#if", "text": ""}, {"location": "course-c/15-fundations/preprocessor/#undef", "title": "#undef", "text": "<p>Un symbole d\u00e9fini soit par la ligne de commande <code>-DFOO=1</code>, soit par la directive <code>#define FOO 1</code> ne peut pas \u00eatre red\u00e9fini. C'est pourquoi il est possible d'utiliser <code>#undef</code> pour supprimer une directive pr\u00e9processeur\u2009:</p> <pre><code>#ifdef FOO\n#   undef FOO\n#endif\n#define FOO 1\n</code></pre> <p>G\u00e9n\u00e9ralement on \u00e9vitera de faire appel \u00e0 <code>#undef</code> car le bon programmeur aura forc\u00e9 la d\u00e9finition d'une directive en amont pour contraindre le d\u00e9veloppement en aval.</p>"}, {"location": "course-c/15-fundations/preprocessor/#debogage", "title": "D\u00e9bogage", "text": ""}, {"location": "course-c/15-fundations/preprocessor/#error", "title": "#error", "text": "<p>Cette directive g\u00e9n\u00e8re une erreur avec le texte qui suit la directive\u2009:</p> <pre><code>#if !(KERNEL_SIZE % 2)\n#    error Le noyau du filtre est pair\n#endif\n</code></pre>"}, {"location": "course-c/15-fundations/preprocessor/#directives-speciales", "title": "Directives sp\u00e9ciales", "text": "<p>Le standard d\u00e9finit certains symboles utiles pour le d\u00e9bogage\u2009:</p> <code>__LINE__</code> <p>Est remplac\u00e9 par le num\u00e9ro de la ligne sur laquelle est plac\u00e9 ce symbole</p> <code>__FILE__</code> <p>Est remplac\u00e9 par le nom du fichier sur lequel est plac\u00e9 ce symbole</p> <code>__func__</code> <p>Est remplac\u00e9 par le nom de la fonction du bloc dans lequel la directive se trouve</p> <code>__STDC__</code> <p>Est remplac\u00e9 par 1 pour indiquer que l'impl\u00e9mentation est compatible avec C90</p> <code>__DATE__</code> <p>Est remplac\u00e9 par la date sous la forme <code>\"Mmm dd yyyy\"</code></p> <code>__TIME__</code> <p>Est remplac\u00e9 par l'heure au moment du pre-processing <code>\"hh:mm:ss\"</code></p>"}, {"location": "course-c/15-fundations/preprocessor/#caractere-dechappement", "title": "Caract\u00e8re d'\u00e9chappement", "text": "<p>L'anti-slash (<code>backslash</code>) est interpr\u00e9t\u00e9 par le pr\u00e9processeur comme un saut de ligne virtuel. Il permet par exemple de casser les longues lignes\u2009:</p> <pre><code>#define TRACE printf(\"Le programme est pass\u00e9 \" \\\n    \" dans le fichier %s\" \\\n    \" ligne %d\\n\", \\\n    __FILE__, __LINE__);\n</code></pre>"}, {"location": "course-c/15-fundations/preprocessor/#macros", "title": "Macros", "text": "<p>Une macro est une d\u00e9finition qui prend des arguments en param\u00e8tre\u2009:</p> <pre><code>#define MIN(x, y) ((x) &lt; (y) ? (x) : (y))\n</code></pre> <p>De la m\u00eame mani\u00e8re que pour les d\u00e9finitions simples, il s'agit d'un remplacement de cha\u00eene\u2009:</p> <pre><code>$ cat test.c\n#define MIN(x, y) ((x) &lt; (y) ? (x) : (y))\n\nint main(void) {\n    return MIN(23, 12);\n}\n\n$ gcc -E test.c -o-\nint main(void) {\n    return ((23) &lt; (12) ? (23) : (12));\n}\n</code></pre> <p>Notez que l'absence d'espace entre le nom de la macro et la parenth\u00e8se est importante. L'exemple suivant le d\u00e9montre\u2009:</p> <pre><code>$ cat test.c\n#define ADD (x, y) ((x) + (y))\n\nint main(void) {\n    return ADD(23, 12);\n}\n\n$ gcc -E test.c -o-\nint main(void) {\n    return (x, y) ((x) + (y))(23, 12);\n}\n</code></pre> <p>Macro avec param\u00e8tres</p> <p>Le pr\u00e9processeur interpr\u00e8te une macro avec param\u00e8tres que si la parenth\u00e8se ouvrante suit directement et sans espace le nom de la macro. Ainsi, consid\u00e9rant cet exemple\u2009:</p> <pre><code>#define f (x) ((x) + 1)\n\nint u = f(1)\n</code></pre> <p>Le pr\u00e9processeur g\u00e9n\u00e8re ceci et le compilateur retournera une erreur du type <code>identification x non d\u00e9clar\u00e9s</code>.</p> <pre><code>int u = (x) ((x) + 1)(1)\n</code></pre> <p>Observations\u2009:</p> <ul> <li>Ne jamais mettre d'espace entre le nom d'une macro et ses param\u00e8tres.</li> <li>\u00catre toujours pr\u00eat \u00e0 mettre en doute le code g\u00e9n\u00e9r\u00e9 par une macro.</li> </ul> <p>Param\u00e8tres de macro non prot\u00e9g\u00e9s</p> <p>On ne le r\u00e9p\u00e8tera jamais assez\u2009: une macro est un remplacement de cha\u00eene effectu\u00e9 par le pr\u00e9processeur. Donc \u00e9crire <code>#define m(x) x * 2</code> et <code>m(2 + 5)</code> sera remplac\u00e9 en <code>2 + 5 * 2</code>.</p> <p>Quel sera le probl\u00e8me dans le cas suivant\u2009?</p> <pre><code>#define ABS(x) x &gt;= 0 ? x: -x\n\nint foo(void) {\n    return ABS(5 - 8);\n}\n</code></pre> <p>Plus difficile, quel serait le probl\u00e8me ici\u2009:</p> <pre><code>#define ERROR(str) printf(\"Erreur: %s\\r\\n\", str); log(str);\n\nif (y &lt; 0)\n    ERROR(\"Zero division\");\nelse\n    x = x / y;\n</code></pre> <p>Observations\u2009:</p> <ul> <li> <p>Toujours prot\u00e9ger les param\u00e8tres des macros avec des parenth\u00e8ses</p> <pre><code>#define ABS(x) ((x) &gt;= 0 ? (x): -(x))\n</code></pre> </li> <li> <p>Toujours prot\u00e9ger une macro \u00e0 plusieurs instructions par une boucle vide\u2009:</p> <pre><code>#define ERROR(str) do { \\\n    printf(\"Erreur: %s\\r\\n\", str); \\\n    log(str); \\\n} while (0)\n</code></pre> </li> </ul> <p>Pr\u00e9/Post incr\u00e9mentation avec une macro</p> <p>On pourrait se dire qu'avec toutes les pr\u00e9cautions prises, il n'y aura plus d'ennuis possibles. Or, les post/pr\u00e9 incr\u00e9ments peuvent encore poser probl\u00e8me.</p> <pre><code>#define ABS(x) ((x) &gt;= 0 ? (x) : -(x))\n\nreturn ABS(x++)\n</code></pre> <p>On peut constater que x sera post-incr\u00e9ment\u00e9 deux fois au lieu d'une\u2009:</p> <pre><code>#define ABS(x) ((x) &gt;= 0 ? (x) : -(x))\n\nreturn ((x++) &gt;= 0 ? (x++) : -(x++))\n</code></pre> <p>Observations\u2009:</p> <ul> <li>\u00c9viter l'utilisation de la pre/post incr\u00e9mentation/d\u00e9cr\u00e9mentation dans l'appel de macros.</li> </ul> <p></p>"}, {"location": "course-c/15-fundations/preprocessor/#concatenation-de-chaines", "title": "Concat\u00e9nation de cha\u00eenes", "text": "<p>Parfois il est utile de vouloir concat\u00e9ner deux symboles comme si ce n'\u00e9tait qu'un seul. Attention, il est n\u00e9cessaire de passer par une macro pour que cela fonctionne\u2009:</p> <pre><code>int foobar = 42;\n\n#define CONCAT(a, b) a ## b\nprintf(\"%d\", CONCAT(foo, bar));\n</code></pre> <p>En appelant seulement le pr\u00e9processeur, on constate ce r\u00e9sultat\u2009:</p> <pre><code>$ gcc -E ww.c\nint foobar = 42;\n\nprintf(\"%d\", foobar);\n</code></pre> <p>L'usage le plus courant est de d\u00e9finir le mangling des noms de fonctions\u2009:</p> <pre><code>#define MANGLE(name) prefix_ ## name ## _suffix\n\nvoid MANGLE(foo)(void) {\n    printf(\"Hello\");\n}\n\nint main() {\n    MANGLE(foo)();\n}\n</code></pre> <p>En effet le langage C ne permet pas de d\u00e9finir des fonctions avec le m\u00eame nom, m\u00eame si elles ont des signatures diff\u00e9rentes et m\u00eame si elles sont dans deux fichiers s\u00e9par\u00e9s. Le mangling permet de contourner cette limitation.</p> <p>Par exemple si vous avez une biblioth\u00e8que qui permet de lire des fichiers XML, vous pourriez avoir une fonction <code>read</code> pour lire un fichier XML et une fonction <code>read</code> pour lire un fichier JSON. Si vous avez besoin des deux biblioth\u00e8ques et que le nom des fonctions est le m\u00eame, vous aurez un conflit.</p> <p>Les d\u00e9veloppeurs autorisent l'utilisateur de la biblioth\u00e8que, pour autant que l'utilisateur ait acc\u00e8s au code source, \u00e0 renommer les fonctions.</p> <p>En utilisant le mangling vous pourriez d\u00e9finir <code>xml_read</code> et <code>json_read</code> pour \u00e9viter les conflits.</p> <p></p>"}, {"location": "course-c/15-fundations/preprocessor/#conversion-en-chaine", "title": "Conversion en cha\u00eene", "text": "<p>Il est possible de convertir un symbole en cha\u00eene de caract\u00e8res avec l'op\u00e9rateur <code>#</code> :</p> <pre><code>#define STR(x) #x\nprintf(\"%s\", STR(42));\n</code></pre>"}, {"location": "course-c/15-fundations/preprocessor/#directives-conditionnelles", "title": "Directives conditionnelles", "text": "<p>Les directives <code>#if</code>, <code>#else</code>, <code>#elif</code> et <code>#endif</code> sont utiles pour rendre conditionnelle une section de code. Cela peut \u00eatre utilis\u00e9 pour d\u00e9finir une structure selon le boutisme de l'architecture cible\u2009:</p> <pre><code>#ifdef BIG_ENDIAN\ntypedef struct {\n    int header;\n    int body;\n    int tail;\n} Dataframe;\n#else\ntypedef struct {\n    int tail;\n    int body;\n    int header;\n} Dataframe;\n#endif\n</code></pre>"}, {"location": "course-c/15-fundations/preprocessor/#desactivation-de-code", "title": "D\u00e9sactivation de code", "text": "<p>On voit souvent des d\u00e9veloppeurs commenter des sections de code pour le d\u00e9bogage. Cette pratique n'est pas recommand\u00e9e, car les outils de refactoring (r\u00e9usinage de code), ne parviendront pas \u00e0 interpr\u00e9ter le code en commentaire jugeant qu'il ne s'agit pas de code, mais de texte insignifiant. Une m\u00e9thode plus robuste et plus sure consiste \u00e0 utiliser une directive conditionnelle\u2009:</p> <pre><code>#if 0 // TODO: Check if this code is still required.\nif (x &lt; 0) {\n    x = 0;\n}\n#endif\n</code></pre>"}, {"location": "course-c/15-fundations/preprocessor/#include-guard", "title": "Include guard", "text": "<p>La protection des fichiers d'en-t\u00eate permet d'\u00e9viter d'inclure un fichier s'il a d\u00e9j\u00e0 \u00e9t\u00e9 inclus.</p> <p>Imaginons que la constante <code>M_PI</code> soit d\u00e9finie dans le header <code>&lt;math.h&gt;</code>:</p> <pre><code>#define M_PI  3.14159265358979323846\n</code></pre> <p>Si ce fichier d'en-t\u00eate est inclus \u00e0 nouveau, le pr\u00e9processeur g\u00e9n\u00e9rera une erreur, car le symbole est d\u00e9j\u00e0 d\u00e9fini. Pour \u00e9viter ce genre d'erreur, les fichiers d'en-t\u00eate sont prot\u00e9g\u00e9s par un garde\u2009:</p> <pre><code>#ifndef MATH_H\n#define MATH_H\n\n...\n\n#endif\n</code></pre> <p>Si le fichier a d\u00e9j\u00e0 \u00e9t\u00e9 inclus, la d\u00e9finition <code>MATH_H</code> sera d\u00e9j\u00e0 d\u00e9clar\u00e9e et le fichier d'en-t\u00eate ne sera pas r\u00e9-inclus.</p> <p>On pr\u00e9f\u00e8rera utiliser la directive #pragma once qui est plus simple \u00e0 l'usage et \u00e9vite une collision de nom. N\u00e9anmoins et bien que cette directive ne soit pas standardis\u00e9e par l'ISO, elle est compatible avec la tr\u00e8s grande majorit\u00e9 des compilateurs C.</p> <pre><code>#pragma once\n\n...\n</code></pre>"}, {"location": "course-c/15-fundations/preprocessor/#commentaires", "title": "Commentaires", "text": "<p>Les commentaires C du type suivant sont aussi des directives du pr\u00e9processeur. Ils seront retir\u00e9s par le pr\u00e9processeur\u2009:</p> <pre><code>// Blabla\n\n/**\n * Le corbeau et le renard.\n */\n</code></pre> <p>Exercise\u2009: Macro compromise\u2009?</p> <p>Que pensez-vous de cette d\u00e9finition\u2009?</p> <pre><code>#define IS_OCTAL(c) ((c) &gt;= '0' &amp;&amp; (c) &lt;= '8')\n</code></pre>"}, {"location": "course-c/15-fundations/preprocessor/#usages-avances", "title": "Usages avanc\u00e9s", "text": ""}, {"location": "course-c/15-fundations/preprocessor/#pragma", "title": "#pragma", "text": "<p>La directive <code>#pragma</code> est une directive sp\u00e9cifique \u00e0 un compilateur. Elle permet de passer des options sp\u00e9cifiques au compilateur, elle n'est par cons\u00e9quent pas standardis\u00e9e. Par exemple, pour d\u00e9sactiver un warning\u2009:</p> <pre><code>#pragma GCC diagnostic ignored \"-Wformat\"\n</code></pre> <p>On utilise \u00e9galement <code>#pragma</code> forcer l'alignement m\u00e9moire d'une structure\u2009:</p> <pre><code>#pragma pack(push, 1)\ntypedef struct {\n    char a;\n    int b;\n} MyStruct;\n#pragma pack(pop)\n</code></pre>"}, {"location": "course-c/15-fundations/preprocessor/#simulation-dexceptions", "title": "Simulation d'exceptions", "text": "<p>Il est possible de simuler des exceptions en C en utilisant les directives du pr\u00e9processeur\u2009:</p> <pre><code>#define TRY do { jmp_buf ex_buf__; if (setjmp(ex_buf__) == 0) {\n#define CATCH } else {\n#define ETRY } } while (0)\n#define THROW longjmp(ex_buf__, 1)\n</code></pre>"}, {"location": "course-c/15-fundations/preprocessor/#debogage_1", "title": "D\u00e9bogage", "text": "<p>Il est possible de d\u00e9finir des macros pour le d\u00e9bogage\u2009:</p> <pre><code>#ifdef DEBUG\n#    define TRACE printf(\"Trace: %s:%d\\n\", __FILE__, __LINE__)\n#else\n#    define TRACE\n#endif\n</code></pre>"}, {"location": "course-c/15-fundations/scope/", "title": "Port\u00e9e et visibilit\u00e9", "text": "<p>Ce chapitre se concentre sur quatre caract\u00e9ristiques d'une variable\u2009:</p> <ul> <li>La port\u00e9e</li> <li>La visibilit\u00e9</li> <li>La dur\u00e9e de vie</li> <li>Son qualificatif de type</li> </ul> <p>Dans les quatre cas, elles d\u00e9crivent l'accessibilit\u00e9, c'est \u00e0 dire jusqu'\u00e0 ou jusqu'\u00e0 quand une variable est accessible, et de quelle mani\u00e8re</p> <p> Brouillard matinal sur le Golden Gate Bridge, San Francisco</p>"}, {"location": "course-c/15-fundations/scope/#espace-de-nommage", "title": "Espace de nommage", "text": "<p>L'espace de nommage ou <code>namespace</code> est un concept diff\u00e9rent de celui existant dans d'autres langages tel que C++. Le standard C99 d\u00e9crit 4 types possibles pour un identifiant\u2009:</p> <ul> <li>fonction et labels</li> <li>noms de structures (<code>struct</code>), d'unions (<code>union</code>), d'\u00e9num\u00e9ration (<code>enum</code>),</li> <li>identifiants</li> </ul>"}, {"location": "course-c/15-fundations/scope/#portee", "title": "Port\u00e9e", "text": "<p>La port\u00e9e ou scope d\u00e9crit jusqu'\u00e0 o\u00f9 une variable est accessible.</p> <p>Une variable est globale, c'est-\u00e0-dire accessible partout, si elle est d\u00e9clar\u00e9e en dehors d'une fonction\u2009:</p> <pre><code>int global_variable = 23;\n</code></pre> <p>Une variable est locale si elle est d\u00e9clar\u00e9e \u00e0 l'int\u00e9rieur d'un bloc, ou \u00e0 l'int\u00e9rieur d'une fonction. Elle sera ainsi visible de sa d\u00e9claration jusqu'\u00e0 la fin du bloc courant\u2009:</p> <pre><code>int main(int)\n{\n    {\n        int i = 12;\n        i += 2; // Valide\n    }\n    i++; // Invalide, `i` n'est plus visible.\n}\n</code></pre>"}, {"location": "course-c/15-fundations/scope/#variable-shadowing", "title": "Variable shadowing", "text": "<p>On dit qu'une variable est shadowed ou masqu\u00e9e si sa d\u00e9claration masque une variable pr\u00e9alablement d\u00e9clar\u00e9e\u2009:</p> <pre><code>int i = 23;\n\nfor(size_t i = 0; i &lt; 10; i++) {\n    printf(\"%ld\", i); // Acc\u00e8s \u00e0 `i` courant et non \u00e0 `i = 23`\n}\n\nprintf(\"%d\", i); // Acc\u00e8s \u00e0 `i = 23`\n</code></pre>"}, {"location": "course-c/15-fundations/scope/#visibilite", "title": "Visibilit\u00e9", "text": "<p>Selon l'endroit o\u00f9 est d\u00e9clar\u00e9e une variable, elle ne sera pas n\u00e9cessairement visible partout ailleurs. Une variable locale n'est accessible qu'\u00e0 partir de sa d\u00e9claration et jusqu'\u00e0 la fin du bloc dans laquelle elle est d\u00e9clar\u00e9e.</p> <p>L'exemple suivant montre la visibilit\u00e9 de plusieurs variables\u2009:</p> <pre><code>                  //   a\nvoid foo(int a) { //   \u252c b\n    int b;        //   \u2502 \u252c\n    ...           //   \u2502 \u2502\n    {             //   \u2502 \u2502 c\n       int c;     //   \u2502 \u2502 \u252c\n       ...        //   \u2502 \u2502 \u2502 d\n       int d;     //   \u2502 \u2502 \u2502 \u252c\n       ...        //   \u2502 \u2502 \u2502 \u2502\n    }             //   \u2502 \u2502 \u2534 \u2534\n    ...           //   \u2502 \u2502\n}                 //   \u2534 \u2534\n</code></pre> <p>Une variable d\u00e9clar\u00e9e globalement, c'est \u00e0 dire en dehors d'une fonction \u00e0 une dur\u00e9e de vie sur l'entier du module (translation unit) quel que soit l'endroit o\u00f9 elle est d\u00e9clar\u00e9e, en revanche elle n'est visible que depuis l'endroit ou elle est d\u00e9clar\u00e9e. Les deux variables <code>i</code> et <code>j</code> sont globales au module, c'est-\u00e0-dire qu'elles peuvent \u00eatre acc\u00e9d\u00e9es depuis n'importe quelle fonction contenue dans ce module.</p> <p>En revanche la variable <code>j</code>, bien qu'elle ait ait une dur\u00e9e de vie sur toute l'ex\u00e9cution du programme et que sa port\u00e9e est globale, elle ne pourra \u00eatre acc\u00e9d\u00e9e depuis, <code>main</code> car elle n'est pas visible.</p> <pre><code>#include &lt;stdio.h&gt;\n                             //  i\nint i;                       //  \u252c\n                             //  \u2502\nint main() {                 //  \u2502\n    printf(\"%d %d\\n\", i, j); //  \u2502\n}                            //  \u2502\n                             //  \u2502 j\nint j;                       //  \u2534 \u252c\n</code></pre> <p>Le mot cl\u00e9 <code>extern</code> permet non pas de d\u00e9clarer la variable, <code>j</code> mais de renseigner le compilateur qu'il existe ailleurs une variable <code>j</code>. C'est ce que l'on appelle une d\u00e9claration avanc\u00e9e ou forward-declaration. Dans ce cas, bien que <code>j</code> soit d\u00e9clar\u00e9e apr\u00e8s la fonction principale, elle est maintenant visible.</p> <pre><code>#include &lt;stdio.h&gt;\n\n                        // j\nextern int j;           // \u252c   D\u00e9claration en amont de `j`\n                        // \u2502\nint main() {            // \u2502\n    printf(\"%d\\n\", j);  // \u2502\n}                       // \u2502\n                        // \u2502\nint j;                  // \u2502\n                        // \u2502\n</code></pre> <p>Une particularit\u00e9 en C est que tout symbole global (variable ou fonction) a une accessibilit\u00e9 transversale. C'est-\u00e0-dire que dans le cas de la compilation s\u00e9par\u00e9e, une variable d\u00e9clar\u00e9e dans un fichier, peut \u00eatre acc\u00e9d\u00e9e depuis un autre fichier, il en va de m\u00eame pour les fonctions.</p> <p>L'exemple suivant implique deux fichiers <code>foo.c</code> et <code>main.c</code>. Dans l'un deux symboles sont d\u00e9clar\u00e9s, une variable et une fonction.</p> foo.c<pre><code>int foo;\n\nvoid do_foo() {\n    printf(\"Foo does...\");\n}\n</code></pre> <p>Depuis le programme principal, il est possible d'acc\u00e9der \u00e0 des symboles \u00e0 condition de renseigner sur le prototype de la fonction et l'existence de la variable\u2009:</p> main.c<pre><code>extern int foo;\nextern void do_foo(); // Non obligatoire\n\nint main() {\n    foo();\n}\n</code></pre> <p>Dans le cas o\u00f9 l'on voudrait restreindre l'accessibilit\u00e9 d'une variable au module dans lequel elle est d\u00e9clar\u00e9e, l'usage du mot cl\u00e9 <code>static</code> s'impose.</p> <p>En \u00e9crivant <code>static int foo;</code> dans <code>foo.c</code>, la variable n'est plus accessible en dehors du module m\u00eame avec une d\u00e9claration en avance. On dit que sa port\u00e9e est r\u00e9duite au module.</p>"}, {"location": "course-c/15-fundations/scope/#qualificatif-de-type", "title": "Qualificatif de type", "text": "<p>Les variables en C peuvent \u00eatre cr\u00e9\u00e9es de diff\u00e9rentes mani\u00e8res. Selon la mani\u00e8re dont elles pourront \u00eatre utilis\u00e9es, il est courant de les classer en cat\u00e9gories.</p> <p>Une classe de stockage peut \u00eatre implicite \u00e0 une d\u00e9claration de variable ou explicite, en ajoutant un attribut devant la d\u00e9claration de celle-ci.</p>"}, {"location": "course-c/15-fundations/scope/#auto", "title": "<code>auto</code>", "text": "<p>Cette classe est utilis\u00e9e par d\u00e9faut lorsqu'aucune autre classe n'est pr\u00e9cis\u00e9e. Les variables automatiques sont visibles uniquement dans le bloc o\u00f9 elles sont d\u00e9clar\u00e9es. Ces variables sont habituellement cr\u00e9\u00e9es sur la pile (stack), mais peuvent \u00eatre aussi stock\u00e9es dans les registres du processeur. C'est un choix qui incombe au compilateur.</p> <pre><code>auto type identificateur = valeur_initiale;\n</code></pre> <p>Pour les variables automatiques, le mot-cl\u00e9 auto n'est pas obligatoire, et n'est pas recommand\u00e9 en C99, car son utilisation est implicite.</p>"}, {"location": "course-c/15-fundations/scope/#register", "title": "<code>register</code>", "text": "<p>Ce mot cl\u00e9 incite le compilateur \u00e0 utiliser un registre processeur pour stocker la variable. Ceci permet de gagner en temps d'ex\u00e9cution, car la variable n'a pas besoin d'\u00eatre charg\u00e9e depuis et \u00e9crite vers la m\u00e9moire.</p> <p>Jadis, ce mot cl\u00e9 \u00e9tait utilis\u00e9 devant toutes les variables d'it\u00e9rations de boucles. La traditionnelle variable <code>i</code> utilis\u00e9e dans les boucles <code>for</code> \u00e9tait d\u00e9clar\u00e9e <code>register int i = 0;</code>. Les compilateurs modernes savent aujourd'hui identifier les variables les plus souvent utilis\u00e9es. L'usage de ce mot cl\u00e9 n'est donc plus recommand\u00e9 depuis C99.</p>"}, {"location": "course-c/15-fundations/scope/#const", "title": "<code>const</code>", "text": "<p>Ce mot cl\u00e9 rend une d\u00e9claration non modifiable par le programme lui-m\u00eame. N\u00e9anmoins il ne s'agit pas de constantes au sens strict du terme, car une variable de type <code>const</code> pourrait tr\u00e8s bien \u00eatre modifi\u00e9e par erreur en jardinant la m\u00e9moire. Quand ce mot cl\u00e9 est appliqu\u00e9 \u00e0 une structure, aucun des champs de la structure n'est accessible en \u00e9criture. Bien qu'il puisse para\u00eetre \u00e9trange de vouloir rendre \u00ab constante \u00bb une \u00ab variable \u00bb, ce mot cl\u00e9 a une utilit\u00e9. En particulier, il permet de faire du code plus s\u00fbr.</p>"}, {"location": "course-c/15-fundations/scope/#static", "title": "<code>static</code>", "text": "<p>Elle permet de d\u00e9clarer des variables dont le contenu est pr\u00e9serv\u00e9 m\u00eame lorsque l'on sort du bloc o\u00f9 elles ont \u00e9t\u00e9 d\u00e9clar\u00e9es.</p> <p>Elles ne sont donc initialis\u00e9es qu'une seule fois. L'exemple suivant est une fonction qui retourne \u00e0 chaque fois une valeur diff\u00e9rente, incr\u00e9ment\u00e9e de 1. La variable <code>i</code> agit ici comme une variable globale, elle n'est initialis\u00e9e qu'une seule fois \u00e0 0 et donc s'incr\u00e9mente d'appel en appel. En revanche, elle n'est pas accessible en dehors de la fonction\u2009; c'est donc une variable locale.</p> <pre><code>int iterate() {\n    static int i = 0;\n    return i++;\n}\n</code></pre> <p>Il n'est pas rare de voir des variables globales, ou des fonctions pr\u00e9c\u00e9d\u00e9es du mot cl\u00e9 <code>static</code>. Ces variables sont dites statiques au module. Elles ne sont donc pas accessibles depuis un autre module (translation unit)</p> <p>La fonction suivante est statique au module dans lequel elle est d\u00e9clar\u00e9e. Il ne sera donc pas possible d'y acc\u00e9der depuis un autre fichier C.</p> <pre><code>static int add(int a, int b) { return a + b; }\n</code></pre>"}, {"location": "course-c/15-fundations/scope/#volatile", "title": "<code>volatile</code>", "text": "<p>Cette classe de stockage indique au compilateur qu'il ne peut faire aucune hypoth\u00e8se d'optimisation concernant cette variable. Elle indique que son contenu peut \u00eatre modifi\u00e9 en tout temps en arri\u00e8re-plan par le syst\u00e8me d'exploitation ou le mat\u00e9riel. Ce mot cl\u00e9 est davantage utilis\u00e9 en programmation syst\u00e8me, ou sur microcontr\u00f4leurs.</p> <p>L'usage de cette classe de stockage r\u00e9duit les performances d'un programme puisqu'elle emp\u00eache l'optimisation du code et le contenu de cette variable devra \u00eatre recharg\u00e9 \u00e0 chaque utilisation</p> <p>Consid\u00e9rons le cas du programme suivant\u2009:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int i = 0;\n\n    i = 1;\n    i = 0;\n    i = 1;\n    i = 0;\n\n    printf(\"%d\", i);\n}\n</code></pre> <p>On notera que les 4 lignes o\u00f9 <code>i</code> successivement assign\u00e9 \u00e0 1 et 0 sont inutiles, car dans tous les cas, la valeur 0 sera affich\u00e9e. Si le programme est compil\u00e9, on obtient le listing suivant\u2009:</p> <pre><code>$ gcc main.c\n$ objdump -d a.out\n\na.out:     file format elf64-x86-64\n\nDisassembly of section .text:\n\n0000000000001149 &lt;main&gt;:\n    1149:       f3 0f 1e fa             endbr64\n    114d:       55                      push   %rbp\n    114e:       48 89 e5                mov    %rsp,%rbp\n    1151:       48 83 ec 10             sub    $0x10,%rsp\n    1155:       c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%rbp)\n    115c:       c7 45 fc 01 00 00 00    movl   $0x1,-0x4(%rbp)\n    1163:       c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%rbp)\n    116a:       c7 45 fc 01 00 00 00    movl   $0x1,-0x4(%rbp)\n    1171:       c7 45 fc 00 00 00 00    movl   $0x0,-0x4(%rbp)\n    1178:       8b 45 fc                mov    -0x4(%rbp),%eax\n    117b:       89 c6                   mov    %eax,%esi\n    117d:       48 8d 3d 80 0e 00 00    lea    0xe80(%rip),%rdi\n    1184:       b8 00 00 00 00          mov    $0x0,%eax\n    1189:       e8 c2 fe ff ff          callq  1050 &lt;printf@plt&gt;\n    118e:       b8 00 00 00 00          mov    $0x0,%eax\n    1193:       c9                      leaveq\n    1194:       c3                      retq\n    1195:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)\n    119c:       00 00 00\n    119f:       90                      nop\n</code></pre> <p>Les lignes <code>1155</code> \u00e0 <code>1171</code> refl\u00e8tent bien le comportement attendu. En revanche, si le programme est compil\u00e9 avec l'optimisation, notez la diff\u00e9rence\u2009:</p> <pre><code>$ gcc main.c -O2\n$ objdump -d a.out\n\na.out:     file format elf64-x86-64\n\nDisassembly of section .text:\n\n0000000000001060 &lt;main&gt;:\n    1060:       f3 0f 1e fa             endbr64\n    1064:       48 83 ec 08             sub    $0x8,%rsp\n    1068:       31 d2                   xor    %edx,%edx\n    106a:       48 8d 35 93 0f 00 00    lea    0xf93(%rip),%rsi\n    1071:       31 c0                   xor    %eax,%eax\n    1073:       bf 01 00 00 00          mov    $0x1,%edi\n    1078:       e8 d3 ff ff ff          callq  1050 &lt;__printf_chk@plt&gt;\n    107d:       31 c0                   xor    %eax,%eax\n    107f:       48 83 c4 08             add    $0x8,%rsp\n    1083:       c3                      retq\n    1084:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)\n    108b:       00 00 00\n    108e:       66 90                   xchg   %ax,%ax\n</code></pre> <p>Les lignes ont disparu\u2009!</p> <p>Afin d'\u00e9viter cette optimisation, il faut marquer la variable <code>i</code> comme <code>volatile</code>:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    volatile int i = 0;\n\n    i = 1;\n    i = 0;\n    i = 1;\n    i = 0;\n\n    printf(\"%d\", i);\n}\n</code></pre>"}, {"location": "course-c/15-fundations/scope/#extern", "title": "<code>extern</code>", "text": "<p>Cette classe est utilis\u00e9e pour signaler que la variable ou la fonction associ\u00e9e est d\u00e9clar\u00e9e dans un autre module (autre fichier). Ainsi le code suivant ne d\u00e9clare pas une nouvelle variable, <code>foo</code> mais s'attend \u00e0 ce que cette variable ait \u00e9t\u00e9 d\u00e9clar\u00e9e dans un autre fichier.</p> <pre><code>extern int foo;\n</code></pre>"}, {"location": "course-c/15-fundations/scope/#restrict", "title": "<code>restrict</code>", "text": "<p>En C, le mot cl\u00e9 <code>restrict</code>, apparu avec C99, est utilis\u00e9 uniquement pour des pointeurs. Ce qualificatif de type informe le compilateur que pour toute la dur\u00e9e de vie du pointeur, aucun autre pointeur ne pointera que sur la valeur qu'il pointe ou une valeur d\u00e9riv\u00e9e de lui-m\u00eame (p. ex\u2009: <code>p + 1</code>).</p> <p>En d'autres termes, le qualificatif indique au compilateur que deux pointeurs diff\u00e9rents ne peuvent pas pointer sur les m\u00eames r\u00e9gions m\u00e9moires.</p> <p>Prenons l'exemple simple d'une fonction qui met \u00e0 jour deux pointeurs avec une valeur pass\u00e9e en param\u00e8tre\u2009:</p> <pre><code>void update_ptr(size_t *a, size_t *b, const size_t *value) {\n    *a += *value;\n    *b += *value;\n}\n</code></pre> <p>Le compilateur, n'ayant aucune information sur les pointeurs fournis, ne peut faire aucune hypoth\u00e8se d'optimisation. En effet, ces deux pointeurs <code>a</code> et <code>b</code> ainsi que <code>value</code> pourraient tr\u00e8s bien pointer sur la m\u00eame r\u00e9gion m\u00e9moire, et dans ce cas <code>*a += *value</code> aurait pour effet d'incr\u00e9menter <code>value</code>. En revanche, dans le cas o\u00f9 la fonction est d\u00e9clar\u00e9e de la fa\u00e7on suivante\u2009:</p> <pre><code>void update_ptr(size_t *restrict a, size_t * restrict b, const size_t *restrict value) {\n    *a += *value;\n    *b += *value;\n}\n</code></pre> <p>le compilateur est inform\u00e9 qu'il peut faire l'hypoth\u00e8se que les trois pointeurs fournis en param\u00e8tres sont ind\u00e9pendants les uns des autres. Dans ce cas il peut optimiser le code. Voir restrict sur Wikipedia pour plus de d\u00e9tails.</p>"}, {"location": "course-c/15-fundations/stdio/", "title": "Entr\u00e9es Sorties", "text": "<p>Un programme informatique se compose d'entr\u00e9es (<code>stdin</code>) et de sorties (<code>stdout</code> et <code>stderr</code>).</p> <p>Pour faciliter la vie du programmeur, les biblioth\u00e8ques standard offrent toute une panoplie de fonctions pour formater les sorties et interpr\u00e9ter les entr\u00e9es.</p> <p>Les fonctions phares sont <code>printf</code> pour le formatage de cha\u00eene de caract\u00e8res et <code>scanf</code> pour la lecture de cha\u00eenes de caract\u00e8res. Ces derni\u00e8res fonctions se d\u00e9clinent en plusieurs variantes que nous verrons plus tard. La liste cit\u00e9e est non exhaustive, mais largement document\u00e9e ici\u2009: <code>&lt;stdio.h&gt;</code>.</p> <p>Les fonctions que nous allons aborder dans ce chapitre sont les suivantes\u2009:</p> Fonction Type Description putchar Sortie \u00c9crit un caract\u00e8re sur la sortie standard puts Sortie \u00c9crit une cha\u00eene de caract\u00e8res sur la sortie standard printf Sortie \u00c9crit une cha\u00eene de caract\u00e8res format\u00e9e sur la sortie standard getchar Entr\u00e9e Lit un caract\u00e8re sur l'entr\u00e9e standard gets Entr\u00e9e Lit une cha\u00eene de caract\u00e8res sur l'entr\u00e9e standard scanf Entr\u00e9e Lit une cha\u00eene de caract\u00e8res format\u00e9e sur l'entr\u00e9e standard"}, {"location": "course-c/15-fundations/stdio/#sorties-non-formatees", "title": "Sorties non format\u00e9es", "text": "<p>Ces fonctions sont tr\u00e8s basiques et permettent d'\u00e9crire des caract\u00e8res ou des cha\u00eenes de caract\u00e8res sur la sortie standard.</p> <p></p>"}, {"location": "course-c/15-fundations/stdio/#putchar_1", "title": "Putchar", "text": "<p>Cette fonction prend en param\u00e8tre un seul caract\u00e8re et l'\u00e9crit sur la sortie standard. Elle est d\u00e9finie dans la biblioth\u00e8que <code>stdio.h</code>.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    putchar('H');\n    putchar('e');\n    putchar('l');\n    putchar('l');\n    putchar('o');\n    putchar('\\n');\n}\n</code></pre> <p>Avertissement</p> <p>Attention \u00e0 utiliser des apostrophes simples <code>'</code> pour les caract\u00e8res. Si vous utilisez des guillemets doubles <code>\"</code> vous obtiendrez une erreur de compilation.</p> <p>On sait que les caract\u00e8res sont des entiers, donc on peut \u00e9crire <code>putchar(65)</code> pour \u00e9crire le caract\u00e8re <code>A</code>. Donc le programme suivant \u00e9crit la m\u00eame chose que le pr\u00e9c\u00e9dent\u2009:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    putchar(72);\n    putchar(101);\n    putchar(108);\n    putchar(108);\n    putchar(111);\n    putchar('\\n');\n}\n</code></pre> <p></p>"}, {"location": "course-c/15-fundations/stdio/#puts_1", "title": "Puts", "text": "<p>La fonction <code>puts</code> est une fonction de la biblioth\u00e8que standard C qui permet d'\u00e9crire une cha\u00eene de caract\u00e8res sur la sortie standard. Notons qu'elle ajoute automatiquement un retour \u00e0 la ligne \u00e0 la fin de la cha\u00eene.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    puts(\"hello, world\"); // Un retour \u00e0 la ligne est ajout\u00e9 automatiquement\n}\n</code></pre> <p>Notez ici qu'on utilise des guillemets doubles <code>\"</code> pour les cha\u00eenes de caract\u00e8res.</p>"}, {"location": "course-c/15-fundations/stdio/#sorties-formatees", "title": "Sorties format\u00e9es", "text": "<p>Convertir un nombre en une cha\u00eene de caract\u00e8res n'est pas trivial. Prenons l'exemple de la valeur <code>123</code>. Il faut pour cela diviser it\u00e9rativement le nombre par 10 et calculer le reste\u2009:</p> <pre><code>Etape  Op\u00e9ration  Resultat  Reste\n-----  ---------  --------  -----\n1      123 / 10   12        3\n2      12 / 10    1         2\n3      1 / 10     0         1\n</code></pre> <p>Comme on ne sait pas \u00e0 priori combien de caract\u00e8res on aura, et que ces caract\u00e8res sont fournis depuis le chiffre le moins significatif, il faudra inverser la cha\u00eene de caract\u00e8res produite.</p> <p>Voici un exemple possible d'impl\u00e9mentation\u2009:</p> <pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdbool.h&gt;\n\nvoid swap(char* a, char* b)\n{\n    char old_a = a;\n    a = b;\n    b = old_a;\n}\n\nvoid reverse(char* str, size_t length)\n{\n    for (size_t start = 0, end = length - 1; start &lt; end; start++, end--)\n    {\n        swap(str + start, str + end);\n    }\n}\n\nvoid my_itoa(int num, char* str)\n{\n    const unsigned int base = 10;\n    bool is_negative = false;\n    size_t i = 0;\n\n    if (num == 0) {\n        str[i++] = '0';\n        str[i] = '\\0';\n        return;\n    }\n\n    if (num &lt; 0) {\n        is_negative = true;\n        num = -num;\n    }\n\n    while (num != 0) {\n        int rem = num % 10;\n        str[i++] = rem + '0';\n        num /= base;\n    }\n\n    if (is_negative)\n        str[i++] = '-';\n\n    str[i] = '\\0';\n\n    reverse(str, i);\n}\n</code></pre> <p>Cette impl\u00e9mentation pourrait \u00eatre utilis\u00e9e de la fa\u00e7on suivante\u2009:</p> <pre><code>#include &lt;stdlib.h&gt;\n\nint main(void)\n{\n    int num = 123;\n    char buffer[10];\n\n    itoa(num, buffer);\n}\n</code></pre> <p></p>"}, {"location": "course-c/15-fundations/stdio/#printf_1", "title": "Printf", "text": "<p>Vous conviendrez que devoir manuellement convertir chaque valeur n'est pas des plus pratique, c'est pourquoi <code>printf</code> rend l'op\u00e9ration bien plus ais\u00e9e en utilisant des marques substitutives (placeholder). Ces sp\u00e9cifi\u00e9 d\u00e9butent par le caract\u00e8re <code>%</code> suivi du formatage que l'on veut appliquer \u00e0 une variable pass\u00e9e en param\u00e8tres. L'exemple suivant utilise <code>%d</code> pour formater un entier non sign\u00e9.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main()\n{\n    int32_t earth_perimeter = 40075;\n    printf(\"La circonf\u00e9rence de la terre vaut vaut %d km\", earth_perimeter);\n}\n</code></pre> <p>Le standard C d\u00e9fini le prototype de <code>printf</code> comme \u00e9tant\u2009:</p> <pre><code>int printf(const char *restrict format, ...);\n</code></pre> <p>Il d\u00e9finit que la fonction <code>printf</code> prend en param\u00e8tre un format suivi de <code>...</code>. La fonction <code>printf</code> comme toutes celles de la m\u00eame cat\u00e9gorie sont dites variadiques, c'est-\u00e0-dire qu'elles peuvent prendre un nombre variable d'arguments. Il y aura autant d'arguments additionnels que de marqueurs utilis\u00e9s dans le format. Ainsi le format <code>\"Mes nombres pr\u00e9f\u00e9r\u00e9s sont %d et %d, mais surtout %s\"</code> demandera trois param\u00e8tres additionnels\u2009:</p> <p>La fonction retourne le nombre de caract\u00e8res format\u00e9s ou <code>-1</code> en cas d'erreur.</p> <p>La construction d'un marqueur est loin d'\u00eatre simple, mais heureusement on n'a pas besoin de tout conna\u00eetre et la page Wikip\u00e9dia printf format string est d'une grande aide. Le format de construction est le suivant\u2009:</p> <pre><code>%[parameter][flags][width][.precision][length]type\n</code></pre> <code>parameter</code> (optionnel) <p>Num\u00e9ro de param\u00e8tre \u00e0 utiliser</p> <code>flags</code> (optionnel) <p>Modificateurs\u2009: pr\u00e9fixe, signe plus, alignement \u00e0 gauche ...</p> <code>width</code> (optionnel) <p>Nombre minimum de caract\u00e8res \u00e0 utiliser pour l'affichage de la sortie.</p> <code>.precision</code> (optionnel) <p>Nombre minimum de caract\u00e8res affich\u00e9s \u00e0 droite de la virgule. Essentiellement, valide pour les nombres \u00e0 virgule flottante.</p> <code>length</code> (optionnel) <p>Longueur en m\u00e9moire. Indique la longueur de la repr\u00e9sentation binaire.</p> <code>type</code> <p>Type de formatage souhait\u00e9</p> <p> Formatage d'un marqueur</p> <p>Voici quelques exemples\u2009:</p>  Exemple de formatage avec printf Exemple Sortie Taille <code>printf(\"%c\", 'c')</code> <code>c</code> 1 <code>printf(\"%d\", 1242)</code> <code>1242</code> 4 <code>printf(\"%10d\", 42)</code> <code>42</code> 10 <code>printf(\"%07d\", 42)</code> <code>0000042</code> 7 <code>printf(\"%+-5dfr\", 23)</code> <code>+23   fr</code> 6 <code>printf(\"%5.3f\", 314.15)</code> <code>314.100</code> 7 <code>printf(\"%*.*f\", 4, 2, 102.1)</code> <code>102.10</code> 7 <code>printf(\"%8x\", 57005)</code> <code>dead</code> 6 <code>printf(\"%s\", \"Hello\")</code> <code>Hello</code> 5 <p>On peut s'int\u00e9resser \u00e0 comment <code>printf</code> fonctionne en interne. Le premier argument est une cha\u00eene de caract\u00e8re qui est le motif de formatage. Il peut contenir des caract\u00e8res sp\u00e9ciaux placeholder qui seront intercept\u00e9s par <code>printf</code> pour \u00eatre remplac\u00e9s par les arguments suivants apr\u00e8s avoir \u00e9t\u00e9 convertis.</p> <p>Pour bien comprendre, on peut imaginer une impl\u00e9mentation na\u00efve de <code>printf</code> que nous appellerons <code>my_printf</code> et qui se basera sur une fonction de sortie non format\u00e9e <code>putchar</code>.</p> <p>Cette fonction ne sera capable que de traiter les marqueurs <code>%d</code> et <code>%c</code>, c'est suffisant pour comprendre le principe. \u00c9galement, elle prendra toujours deux arguments, donc une valeur \u00e0 afficher, ceci pour ne pas s'encombrer de la gestion de la liste variable d'arguments qui est un sujet avanc\u00e9.</p> <pre><code>void my_printf(char format[], int a) {\n    // On parcourt la cha\u00eene de caract\u00e8res tant que l'on ne rencontre\n    // pas le caract\u00e8re de fin de cha\u00eene\n    for (int i = 0; format[i] != '\\0'; i++) {\n        // Si on rencontre un caract\u00e8re %, on regarde le caract\u00e8re suivant\n        if (format[i] == '%') {\n            // Est-ce que ce caract\u00e8re est sp\u00e9cial ?\n            switch (format[++i]) {\n                case 'd': {\n                    char str[32] = {0};\n                    my_itoa(int a, str);\n                    for (int j = 0; str[j] != '\\0'; j++) {\n                        putchar(str[j]);\n                    }\n                    break;\n                }\n                case 'c':\n                    // Affiche le caract\u00e8re en ASCII\n                    putchar(a);\n                    break;\n                default:\n                    // On affiche le caract\u00e8re tel quel,\n                    // ce qui permet d'afficher le caract\u00e8re %\n                    putchar(format[i]);\n            }\n        } else {\n            putchar(format[i]);\n        }\n    }\n}\n</code></pre> <p>Exercise</p> <p>Indiquez les erreurs dans les instructions suivantes\u2009:</p> <pre><code>printf(\"Exercise: %d%d\\n\", 10, 20);\nprintf(\"%d, %d, %d\\n\", 10, 20);\nprintf(\"%d, %d, %d, %d\\n\", 10, 20, 30, 40.);\nprintf(\"%*d, %*d\\n\", 10, 20);\nprintf(\"%6.2f\\n\", 10);\nprintf(\"%10s\\n\", 0x9f);\n</code></pre>"}, {"location": "course-c/15-fundations/stdio/#entrees-non-formatees", "title": "Entr\u00e9es non format\u00e9es", "text": ""}, {"location": "course-c/15-fundations/stdio/#getchar_1", "title": "Getchar", "text": "<p>La fonction <code>getchar</code> est une fonction de la biblioth\u00e8que standard C qui permet de lire un caract\u00e8re sur l'entr\u00e9e standard. Elle est d\u00e9finie dans la biblioth\u00e8que <code>stdio.h</code>. Elle retourne un entier qui correspond \u00e0 la valeur ASCII du caract\u00e8re lu.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int c;\n    while ((c = getchar()) != EOF) {\n        printf(\"Caract\u00e8re lu : %c\\n\", c);\n    }\n}\n</code></pre> <p>Notez ici l'utilisation de <code>EOF</code> qui est une constante d\u00e9finie dans la biblioth\u00e8que <code>stdio.h</code> et qui signifie End Of File. Elle est utilis\u00e9e pour d\u00e9tecter la fin d'un fichier.</p> <p>Lorsque vous ex\u00e9cutez ce programme, vous pouvez saisir des caract\u00e8res au clavier. Pour terminer la saisie, vous pouvez utiliser la combinaison de touches ++Ctrl+D++ sur Linux ou ++Ctrl+Z++ sur Windows.</p> <p></p>"}, {"location": "course-c/15-fundations/stdio/#gets_1", "title": "Gets", "text": "<p>La fonction <code>gets</code> est une fonction de la biblioth\u00e8que standard C qui permet de lire une cha\u00eene de caract\u00e8res sur l'entr\u00e9e standard. Elle est d\u00e9finie dans la biblioth\u00e8que <code>stdio.h</code>.</p> <p>Elle est d\u00e9conseill\u00e9e, car elle ne permet pas de sp\u00e9cifier la taille maximale de la cha\u00eene \u00e0 lire. Cela peut entra\u00eener des d\u00e9bordements de m\u00e9moire si un utilisateur saisit une cha\u00eene de caract\u00e8res trop longue que le programme ne peut pas stocker.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    char str[128];\n    gets(str);\n    printf(\"Cha\u00eene lue : %s\\n\", str);\n}\n</code></pre> <p>Avertissement</p> <p>La fonction <code>gets</code> est d\u00e9conseill\u00e9e. Il est pr\u00e9f\u00e9rable d'utiliser la fonction <code>fgets</code> qui permet de sp\u00e9cifier la taille maximale de la cha\u00eene \u00e0 lire.</p>"}, {"location": "course-c/15-fundations/stdio/#entrees-formatees", "title": "Entr\u00e9es format\u00e9es", "text": "<p>Les fonctions de lecture de cha\u00eenes de caract\u00e8res sont plus complexes que les fonctions d'\u00e9criture. En effet, il est n\u00e9cessaire de sp\u00e9cifier le format de la cha\u00eene \u00e0 lire.</p> <p></p>"}, {"location": "course-c/15-fundations/stdio/#scanf_1", "title": "Scanf", "text": "<p>\u00c0 l'instar de la sortie format\u00e9e, il est possible de lire les saisies au clavier ou parser une cha\u00eene de caract\u00e8res, c'est-\u00e0-dire faire une analyse syntaxique de son contenu pour en extraire de l'information.</p> <p>La fonction <code>scanf</code> est par exemple utilis\u00e9e \u00e0 cette fin\u2009:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main()\n{\n    int favorite;\n\n    printf(\"Quelle est votre nombre favori ? \");\n    scanf(\"%d\", &amp;favorite);\n\n    printf(\"Saviez-vous que votre nombre favori, %d, est %s ?\\n\",\n        favorite,\n        favorite % 2 ? \"impair\" : \"pair\");\n}\n</code></pre> <p>Cette fonction utilise l'entr\u00e9e standard <code>stdin</code>. Il est donc possible soit d'ex\u00e9cuter ce programme en mode interactif\u2009:</p> <pre><code>$ ./a.out\nQuelle est votre nombre favori ? 2\nSaviez-vous que votre nombre favori, 2, est pair ?\n</code></pre> <p>soit d'ex\u00e9cuter ce programme en fournissant le n\u00e9cessaire \u00e0 stdin\u2009:</p> <pre><code>$ echo \"23\" | ./a.out\nQuel est votre nombre favori ? Saviez-vous que votre nombre favori, 23, est impair ?\n</code></pre> <p>On observe ici un comportement diff\u00e9rent, car le retour clavier lorsque la touche enter est press\u00e9e n'est pas transmis au programme, mais c'est le shell qui l'intercepte.</p> <p>Le format de <code>scanf</code> se rapproche de <code>printf</code> mais en plus simple. Le man scanf ou m\u00eame la page Wikip\u00e9dia de scanf renseigne sur son format.</p> <p>Cette fonction tient son origine une nouvelle fois de ALGOL 68 (<code>readf</code>), elle est donc tr\u00e8s ancienne.</p> <p>La compr\u00e9hension de <code>scanf</code> n'est pas \u00e9vidente et il est utile de se familiariser sur son fonctionnement \u00e0 l'aide de quelques exemples.</p> <p>Le programme suivant lit un entier et le place dans la variable <code>n</code>. <code>scanf</code> retourne le nombre d'assignements r\u00e9ussis. Ici, il n'y a qu'un placeholder, on s'attend naturellement \u00e0 lire <code>1</code> si la fonction r\u00e9ussit. Le programme \u00e9crit ensuite les nombres dans l'ordre d'apparition.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int i = 0, n;\n\n    while (scanf(\"%d\", &amp;n) == 1)\n        printf(\"%i\\t%d\\n\", ++i, n);\n    return 0;\n}\n</code></pre> <p>Si le code est ex\u00e9cut\u00e9 avec une suite arbitraire de nombres\u2009:</p> <pre><code>456 123 789     456 12\n456 1\n    2378\n</code></pre> <p>il affichera chacun des nombres dans l'ordre d'apparition\u2009:</p> <pre><code>$ cat &lt;&lt; EOF | ./a.out\n456 123 789     456 12\n456 1\n    2378\nEOF\n1       456\n2       123\n3       789\n4       456\n5       12\n6       456\n7       1\n8       2378\n</code></pre> <p>Voyons un exemple plus complexe (c.f. C99 \u00a77.19.6.2-19).</p> <pre><code>int count;\nfloat quantity;\nchar units[21], item[21];\n\ndo {\n    count = scanf(\"%f%20s de %20s\", &amp;quant, units, item);\n    scanf(\"%*[^\\n]\");\n} while (!feof(stdin) &amp;&amp; !ferror(stdin));\n</code></pre> <p>Lorsqu'ex\u00e9cut\u00e9 avec ce contenu\u2009:</p> <pre><code>2 litres de lait\n-12.8degr\u00e9s Celsius\nbeaucoup de chance\n10.0KG de\npoussi\u00e8re\n100ergs d\u2019\u00e9nergie\n</code></pre> <p>Le programme se d\u00e9roule comme suit\u2009:</p> <pre><code>quantity = 2; strcpy(units, \"litres\"); strcpy(item, \"lait\");\ncount = 3;\n\nquantity = -12.8; strcpy(units, \"degrees\");\ncount = 2; // \"C\" \u00e9choue lors du test de \"d\" (de)\n\ncount = 0; // \"b\" de \"beaucoup\" \u00e9choue contre \"%f\" s'attendant \u00e0 un float\n\nquantity = 10.0; strcpy(units, \"KG\"); strcpy(item, \"poussi\u00e8re\");\ncount = 3;\n\ncount = 0; // \"100e\" \u00e9choue contre \"%f\", car \"100e3\" serait un nombre valable\ncount = EOF; // Fin de fichier\n</code></pre> <p>Dans cet exemple, la boucle <code>do</code>... <code>while</code> est utilis\u00e9e, car il n'est pas simplement possible de traiter le cas <code>while(scanf(...) &gt; 0</code> puisque l'exemple cherche \u00e0 montrer les cas particuliers o\u00f9 justement, la capture \u00e9choue. Il est n\u00e9cessaire alors de faire appel \u00e0 des fonctions de plus bas niveau <code>feof</code> pour d\u00e9tecter si la fin du fichier est atteinte, et <code>ferror</code> pour d\u00e9tecter une \u00e9ventuelle erreur sur le flux d'entr\u00e9e.</p> <p>La directive <code>scanf(\"%*[^\\n]\");</code> \u00e9tant un peu particuli\u00e8re, il peut valoir la peine de s'y attarder un peu. Le flag <code>*</code>, diff\u00e9rent de <code>printf</code> indique d'ignorer la capture en cours. L'exemple suivant montre comment ignorer un mot.</p> <pre><code>#include &lt;assert.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    int a, b;\n    char str[] = \"24 kayaks 42\";\n\n    sscanf(str, \"%d%*s%d\", &amp;a, &amp;b);\n    assert(a == 24);\n    assert(b == 42);\n}\n</code></pre> <p>Ensuite, <code>[^\\n]</code>. Le marqueur <code>[</code>, termin\u00e9 par <code>]</code> cherche \u00e0 capturer une s\u00e9quence de caract\u00e8res parmi une liste de caract\u00e8res accept\u00e9s. Cette syntaxe est inspir\u00e9e des expressions r\u00e9guli\u00e8res tr\u00e8s utilis\u00e9es en informatique. Le caract\u00e8re <code>^</code> \u00e0 une signification particuli\u00e8re, il indique que l'on cherche \u00e0 capturer une s\u00e9quence de caract\u00e8res parmi une liste de caract\u00e8res qui ne sont pas accept\u00e9s. C'est une sorte de n\u00e9gation. Dans le cas pr\u00e9sent, cette directive <code>scanf</code> cherche \u00e0 consommer tous les caract\u00e8res jusqu'\u00e0 une fin de ligne, car, dans le cas ou la capture \u00e9choue \u00e0 <code>C</code> de <code>Celsius</code>, le pointeur de fichier est bloqu\u00e9 au caract\u00e8re <code>C</code> et au prochain tour de boucle, <code>scanf</code> \u00e9chouera au m\u00eame endroit. Cette instruction est donc utilis\u00e9e pour repartir sur des bases saines en sautant \u00e0 la prochaine ligne.</p> <p>Exercise\u2009: scanf sur des entiers et des r\u00e9els</p> <p>Consid\u00e9rant les d\u00e9clarations\u2009:</p> <pre><code>int i, j, k;\nfloat f;\n</code></pre> <p>Donnez les valeurs de chacune des variables apr\u00e8s ex\u00e9cution. Chaque ligne est ind\u00e9pendante des autres.</p> <pre><code>i = sscanf(\"1 12.5\", \"%d %d, &amp;j, &amp;k);\nsscanf(\"12.5\", \"%d %f\", &amp;j, %f);\ni = sscanf(\"123 123\", \"%d %f\", &amp;j, &amp;f);\ni = sscanf(\"123a 123\", \"%d %f\", &amp;j, &amp;f);\ni = sscanf(\"%2d%2d%f\", &amp;j, &amp;k, &amp;f);\n</code></pre> <p>Exercise\u2009: Saisie de valeurs</p> <p>Consid\u00e9rant les d\u00e9clarations suivantes, donner la valeur des variables apr\u00e8s l'ex\u00e9cution des instructions donn\u00e9es avec les captures associ\u00e9es\u2009:</p> <pre><code>int i = 0, j = 0, n = 0;\nfloat x = 0;\n</code></pre> <ol> <li><code>n = scanf(\"%1d%1d\", &amp;i, &amp;j);</code>, <code>12\\n</code></li> <li><code>n = scanf(\"%d%d\", &amp;i, &amp;j);</code>, <code>1 , 2\\n</code></li> <li><code>n = scanf(\"%d%d\", &amp;i, &amp;j);</code>, <code>-1   -2\\n</code></li> <li><code>n = scanf(\"%d%d\", &amp;i, &amp;j);</code>, <code>-  1  -  2\\n</code></li> <li><code>n = scanf(\"%d,%d\", &amp;i, &amp;j);</code>, <code>1  ,  2\\n</code></li> <li><code>n = scanf(\"%d ,%d\", &amp;i, &amp;j);</code>, <code>1  ,  2\\n</code></li> <li><code>n = scanf(\"%4d %2d\", &amp;i, &amp;j);</code>, <code>1 234\\n</code></li> <li><code>n = scanf(\"%4d %2d\", &amp;i, &amp;j);</code>, <code>1234567\\n</code></li> <li><code>n = scanf(\"%d%*d%d\", &amp;i, &amp;j);</code>, <code>123 456 789\\n</code></li> <li><code>n = scanf(\"i=%d , j=%d\", &amp;i, &amp;j);</code>, <code>1 , 2\\n</code></li> <li><code>n = scanf(\"i=%d , j=%d\", &amp;i, &amp;j);</code>, <code>i=1, j=2\\n</code></li> <li><code>n = scanf(\"%d%d\", &amp;i, &amp;j);</code>, <code>1.23 4.56\\n</code></li> <li><code>n = scanf(\"%d.%d\", &amp;i, &amp;j);</code>, <code>1.23 4.56\\n</code></li> <li><code>n = scanf(\"%x%x\", &amp;i, &amp;j);</code>, <code>12 2a\\n</code></li> <li><code>n = scanf(\"%x%x\", &amp;i, &amp;j);</code>, <code>0x12 0X2a\\n</code></li> <li><code>n = scanf(\"%o%o\", &amp;i, &amp;j);</code>, <code>12 018\\n</code></li> <li><code>n = scanf(\"%f\", &amp;x);</code>, <code>123\\n</code></li> <li><code>n = scanf(\"%f\", &amp;x);</code>, <code>1.23\\n</code></li> <li><code>n = scanf(\"%f\", &amp;x);</code>, <code>123E4\\n</code></li> <li><code>n = scanf(\"%e\", &amp;x);</code>, <code>12\\n</code></li> </ol> Solution <code>Q</code> <code>i</code> <code>j</code> <code>n</code> Remarque 1 <code>1</code> <code>2</code> <code>2</code> 2 <code>1</code> <code>0</code> <code>1.</code> <code>j</code> n'est pas lue car arr\u00eat pr\u00e9matur\u00e9 sur <code>,</code> 3 <code>-1</code> <code>-2</code> <code>2</code> 4 <code>0</code> <code>0</code> <code>0.</code> <code>i</code> n'est pas lue car arr\u00eat pr\u00e9matur\u00e9 sur <code>-</code> 5 <code>1</code> <code>0</code> <code>1.</code> 6 <code>1</code> <code>2</code> <code>2</code> 7 <code>1</code> <code>23</code> <code>2</code> 8 <code>1234</code> <code>56</code> <code>2</code> 9 <code>123</code> <code>789</code> <code>2</code> 10 <code>0</code> <code>0</code> <code>0</code> 11 <code>1</code> <code>2</code> <code>2</code> 12 <code>1</code> <code>0</code> <code>1</code> 13 <code>1</code> <code>23</code> <code>2</code> 14 <code>18</code> <code>42</code> <code>2</code> 15 <code>10</code> <code>1</code> <code>2.</code> Le chiffre 8 interdit en octal provoque un arr\u00eat <code>x</code> <code>n</code> 16 <code>123.</code> <code>1</code> 17 <code>1.23</code> <code>1</code> 18 <code>1.23E6</code> <code>1</code> 19 <code>12</code> <code>1</code> <p>Exercise\u2009: Cha\u00eenes de formats</p> <ol> <li>Saisir 3 caract\u00e8res cons\u00e9cutifs dans des variables <code>i</code>, <code>j</code>, <code>k</code>.</li> <li>Saisir 3 nombres de type float s\u00e9par\u00e9s par un point-virgule et un nombre quelconque d'espaces dans des variables <code>x</code>, <code>y</code> et <code>z</code>.</li> <li>Saisir 3 nombres de type double en affichant avant chaque saisie le nom de la variable et un signe <code>=</code>, dans des variables <code>t</code>, <code>u</code> et <code>v</code>.</li> </ol> Solution <ol> <li> <p>Saisir 3 caract\u00e8res cons\u00e9cutifs dans des variables <code>i</code>, <code>j</code>, <code>k</code>.</p> <pre><code>scanf(\"%c%c%c\", &amp;i, &amp;j, &amp;k);\n</code></pre> </li> <li> <p>Saisir 3 nombres de type float s\u00e9par\u00e9s par un point-virgule et un nombre quelconque d'espaces dans des variables <code>x</code>, <code>y</code> et <code>z</code>.</p> <pre><code>scanf(\"%f ;%f ;%f\", &amp;x, &amp;y, &amp;z);\n</code></pre> </li> <li> <p>Saisir 3 nombres de type double en affichant avant chaque saisie le nom de la variable et un signe <code>=</code>, dans des variables <code>t</code>, <code>u</code> et <code>v</code>.</p> <pre><code>printf(\"t=\"); scanf(\"%f\", &amp;t);\nprintf(\"u=\"); scanf(\"%f\", &amp;u);\nprintf(\"v=\"); scanf(\"%f\", &amp;v);\n</code></pre> </li> </ol>"}, {"location": "course-c/15-fundations/stdio/#saisie-de-chaine-de-caracteres", "title": "Saisie de cha\u00eene de caract\u00e8res", "text": "<p>Lors d'une saisie de cha\u00eene de caract\u00e8res, il est n\u00e9cessaire de toujours indiquer une taille maximum de cha\u00eene comme <code>%20s</code> qui limite la capture \u00e0 20 caract\u00e8res, soit une cha\u00eene de 21 caract\u00e8res avec son <code>\\0</code>. Sinon, il y a risque de fuite m\u00e9moire :</p> <pre><code>int main(void) {\n    char a[6];\n    char b[10] = \"R\u00e2teau\";\n\n    char str[] = \"jardinage\";\n    sscanf(str, \"%s\", a);\n\n    printf(\"a. %s\\nb. %s\\n\", a, b);\n}\n</code></pre> <pre><code>$ ./a.out\na. jardinage\nb. age\n</code></pre> <p>Ici la variable b contient <code>age</code> alors qu'elle devrait contenir <code>r\u00e2teau</code>. La raison est que le mot captur\u00e9 <code>jardinage</code> est trop long pour la variable <code>a</code> qui n'est dispos\u00e9e \u00e0 stocker que 5 caract\u00e8res imprimables. Il y a donc d\u00e9passement de m\u00e9moire et comme vous le constatez, le compilateur ne g\u00e9n\u00e8re aucune erreur. La bonne m\u00e9thode est donc de prot\u00e9ger la saisie ici avec <code>%5s</code>.</p> <p>En m\u00e9moire, ces deux variables sont adjacentes et naturellement <code>a[7]</code> est \u00e9quivalente \u00e0 dire la septi\u00e8me case m\u00e9moire \u00e0 partir du d\u00e9but de ``a``.</p> <pre><code>     a[6]              b[10]\n\u251e\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2526\u251e\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2526\n\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502\u2502R\u2502\u00e2\u2502t\u2502e\u2502a\u2502u\u2502 \u2502 \u2502 \u2502 \u2502\n\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n</code></pre>"}, {"location": "course-c/15-fundations/stdio/#saisie-arbitraire", "title": "Saisie arbitraire", "text": "<p>Comme bri\u00e8vement \u00e9voqu\u00e9 plus haut, il est possible d'utiliser le marqueur <code>[</code> pour capturer une s\u00e9quence de caract\u00e8res. Imaginons que je souhaite capturer un nombre en tetrasexagesimal (base 64). Je peux \u00e9crire\u2009:</p> <pre><code>char input[] = \"Q2hvY29sYXQ\";\nchar output[128];\nsscanf(input, \"%127[0-9A-Za-z+/]\", &amp;output);\n</code></pre> <p>Dans cet exemple je capture les nombres de 0 \u00e0 9 <code>0-9</code> (10), les caract\u00e8res majuscules et minuscules <code>A-Za-z</code> (52), ainsi que les caract\u00e8res <code>+</code>, <code>/</code> (2), soit 64 caract\u00e8res. Le buffer d'entr\u00e9e \u00e9tant fix\u00e9 \u00e0 128 positions, la saisie est contrainte \u00e0 127 caract\u00e8res imprimables.</p> <p>Exercise\u2009: Bugs</p> <p>Parmi les instructions ci-dessous, indiquez celles qui sont correctes et celle qui comporte des erreurs. Pour celles comportant des erreurs, d\u00e9taillez la nature des anomalies.</p> <pre><code>short i;\nlong j;\nunsigned short u;\nfloat x;\ndouble y;\nprintf(i);\nscanf(&amp;i);\nprintf(\"%d\", &amp;i);\nscanf(\"%d\", &amp;i);\nprintf(\"%d%ld\", i, j, u);\nscanf(\"%d%ld\", &amp;i, j);\nprintf(\"%u\", &amp;u);\nscanf(\"%d\", &amp;u);\nprintf(\"%f\", x);\nscanf(\"%f\", &amp;x);\nprintf(\"%f\", y);\nscanf(\"%f\", &amp;y);\n</code></pre> Solution <pre><code>// Incorrect ! Le premier param\u00e8tre de printf doit \u00eatre la cha\u00eene de format.\nprintf(i);\n\n// Incorrect ! Le premier param\u00e8tre de scanf doit \u00eatre la cha\u00eene de format.\nscanf(&amp;i);\n\n// Correct, mais surprenant.\n// Cette instruction affichera l\u2019adresse de I, et non pas sa valeur !\nprintf(\"%d\", &amp;i);\n\n// Incorrect. Le param\u00e8tre i est de type short, alors que la cha\u00eene de\n// format sp\u00e9cifie un type int. Fonctionnera sur les machines dont le type\n// short et int sont identiques\nscanf(\"%d\", &amp;i);\n\n// Incorrect, la troisi\u00e8me variable pass\u00e9e en param\u00e8tre ne sera pas affich\u00e9e.\nprintf(\"%d%ld\", i, j, u);\n\n// Incorrect ! Le premier param\u00e8tre est de type short alors que int\n// est sp\u00e9cifi\u00e9 dans la cha\u00eene de format.\n// Le deuxi\u00e8me param\u00e8tre n\u2019est pas pass\u00e9 par adresse, ce qui va\n// probablement causer une erreur fatale.\nscanf(\"%d%ld\", &amp;i, j);\n\n// Correct, mais \u00e9tonnant. Affiche l\u2019adresse de la variable u.\nprintf(\"%u\", &amp;u);\n\n// Incorrect ! Le param\u00e8tre est de type unsigned short, alors que\n// la cha\u00eene de format sp\u00e9cifie int. Fonctionnera pour les valeurs\n// positives sur les machines dont le type short et int sont identiques.\n// Pour les valeurs n\u00e9gatives, le r\u00e9sultat sera l\u2019interpr\u00e9tation non\n// sign\u00e9e de la valeur en compl\u00e9ment \u00e0 2.\nscanf(\"%d\", &amp;u);\n\n// Correct, mais x est trait\u00e9 comme double.\nprintf(\"%f\", x);\n\n// Correct.\nscanf(\"%f\", &amp;x);\n\n// Correct ! %f est trait\u00e9 comme double par printf !\nprintf(\"%f\", y);\n\n// Incorrect ! La cha\u00eene de format sp\u00e9cifie float,\n// le param\u00e8tre pass\u00e9 est l\u2019adresse d\u2019une variable de type double.\nscanf(\"%f\", &amp;y);\n</code></pre> <p>Exercise\u2009: Test de saisir correcte</p> <p>\u00c9crivez un programme d\u00e9clarant des variables r\u00e9elles <code>x</code>, <code>y</code> et <code>z</code>, permettant de saisir leur valeur en une seule instruction, et v\u00e9rifiant que les 3 valeurs ont bien \u00e9t\u00e9 assign\u00e9es. Dans le cas contraire, afficher un message du type \u00ab\u2009donn\u00e9es invalides\u2009\u00bb.</p> Solution <pre><code>int n;\nfloat x, y, z;\nprintf(\"Donnez les valeurs de x, y et z :\");\nn = scanf(\"%f%f%f\", &amp;x, &amp;y, &amp;z);\nif (n != 3)\nprintf(\"Erreur de saisie.\\n\");\n</code></pre> <p>Exercise\u2009: Produit scalaire</p> <p>\u00c9crire un programme effectuant les op\u00e9rations suivantes\u2009:</p> <ul> <li>Saisir les coordonn\u00e9es r\u00e9elles <code>x1</code> et <code>y1</code> d\u2019un vecteur <code>v1</code>.</li> <li>Saisir les coordonn\u00e9es r\u00e9elles <code>x2</code> et <code>y2</code> d\u2019un vecteur <code>v2</code>.</li> <li>Calculer le produit scalaire. Afficher un message indiquant si les vecteurs sont orthogonaux ou non.</li> </ul> Solution <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(void)\n{\n    float x1, y1\n    printf(\"Coordonn\u00e9es du vecteur v1 s\u00e9par\u00e9es par un \\\";\\\" :\\n\");\n    scanf(\"%f ;%f\", &amp;x1, &amp;y1);\n\n    float x2, y2;\n    printf(\"Coordonn\u00e9es du vecteur v2 s\u00e9par\u00e9es par un \\\";\\\" :\\n\");\n    scanf(\"%f ;%f\", &amp;x2, &amp;y2);\n\n    float dot_product = x1 * x2 + y1 * y2;\n    printf(\"Produit scalaire : %f\\n\", dot_product);\n    if (dot_product == 0.0)\n        printf(\"Les vecteurs sont orthogonaux.\\n\");\n}\n</code></pre> <p>Ce programme risque de ne pas bien d\u00e9tecter l\u2019orthogonalit\u00e9 de certains vecteurs, car le test d\u2019\u00e9galit\u00e9 \u00e0 0 avec les virgules flottantes pourrait mal fonctionner. En effet, pour deux vecteurs orthogonaux, les erreurs de calcul en virgule flottante pourraient amener \u00e0 un produit scalaire calcul\u00e9 tr\u00e8s proche, mais cependant diff\u00e9rent de z\u00e9ro. On peut corriger ce probl\u00e8me en modifiant le test pour v\u00e9rifier si le produit scalaire est tr\u00e8s petit, par exemple compris entre <code>-0.000001</code> et <code>+0.000001</code>:</p> <pre><code>if (dot_product &gt;= -1E-6 &amp;&amp; dot_product &lt;= 1E-6)\n</code></pre> <p>Ce qui peut encore s\u2019\u00e9crire en utilisant la fonction valeur absolue\u2009:</p> <pre><code>if (fabs(dot_product) &lt;= 1E-6)\n</code></pre> <p>Exercise\u2009: Crampes de doigts</p> <p>Votre coll\u00e8gue n'a pas cess\u00e9 de se plaindre de crampes... aux doigts... Il a \u00e9crit le programme suivant avant de prendre cong\u00e9 pour se rendre chez son m\u00e9decin.</p> <p>Gr\u00e2ce \u00e0 votre esprit affut\u00e9 et votre \u0153il per\u00e7ant, vous identifiez 13 erreurs. Lesquelles sont-elles\u2009?</p> <pre><code>#include &lt;std_io.h&gt;\n#jnclude &lt;stdlib.h&gt;\nINT Main()\n{\nint a, sum;\nprintf(\"Addition de 2 entiers a et b.\\n\");\n\nprintf(\"a: \")\nscanf(\"%d\", a);\n\nprintf(\"b: \");\nscanf(\"%d\", &amp;b);\n\n/* Affichage du r\u00e9sultat\nsomme = a - b;\nPrintf(\"%d + %d = %d\\n\", a, b, sum);\n\nretturn EXIT_FAILURE;\n}\n}\n</code></pre> Solution <p>Une fois la correction effectu\u00e9e, vous utilisez l'outil de <code>diff</code> pour montrer les diff\u00e9rences\u2009:</p> <pre><code>1,3c1,3\n&lt;         #include &lt;stdio.h&gt;\n&lt;         #include &lt;stdlib.h&gt;\n&lt;         int main()\n---\n&gt;         #include &lt;std_io.h&gt;\n&gt;         #jnclude &lt;stdlib.h&gt;\n&gt;         INT Main()\n5c5\n&lt;         int a, b, sum;\n---\n&gt;         int a, sum;\n9c9\n&lt;         scanf(\"%d\", &amp;a);\n---\n&gt;         scanf(\"%d\", a);\n14,16c14,16\n&lt;         /* Affichage du r\u00e9sultat */\n&lt;         sum = a + b;\n&lt;         printf(\"%d + %d = %d\\n\", a, b, sum);\n---\n&gt;         /* Affichage du r\u00e9sultat\n&gt;         somme = a - b;\n&gt;         Printf(\"%d + %d = %d\\n\", a, b, sum);\n18c18,19\n&lt;         return EXIT_SUCCESS;\n---\n&gt;         return EXIT_FAILURE;\n&gt;         }\n</code></pre> <p>Exercise\u2009: G\u00e9om\u00e9trie affine</p> <p>Consid\u00e9rez le programme suivant\u2009:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(void)\n{\n    float a;\n    printf(\"a = \");\n    scanf(\"%f\", &amp;a);\n\n    float b;\n    printf(\"b = \");\n    scanf(\"%f\", &amp;b);\n\n    float x;\n    printf(\"x = \");\n    scanf(\"%f\", &amp;x);\n\n    float y = a * x + b;\n\n    printf(\"y = %f\\n\", y);\n}\n</code></pre> <ol> <li>\u00c0 quelle ligne commence l'ex\u00e9cution de ce programme\u2009?</li> <li>Dans quel ordre s'ex\u00e9cutent les instructions\u2009?</li> <li>D\u00e9crivez ce que fait ce programme \u00e9tape par \u00e9tape</li> <li>Que verra l'utilisateur \u00e0 l'\u00e9cran\u2009?</li> <li>Quelle est l'utilit\u00e9 de ce programme\u2009?</li> </ol> Solution <ol> <li>Ligne 6</li> <li>C est un langage imp\u00e9ratif, l'ordre est s\u00e9quentiel du haut vers le bas</li> <li> <p>Les \u00e9tapes sont les suivantes\u2009:</p> <ol> <li>Demande de la valeur de <code>a</code> \u00e0 l'utilisateur</li> <li>Demande de la valeur de <code>b</code> \u00e0 l'utilisateur</li> <li>Demande de la valeur de <code>x</code> \u00e0 l'utilisateur</li> <li>Calcul de l'image affine de <code>x</code> (\u00e9quation de droite)</li> <li>Affichage du r\u00e9sultat</li> </ol> </li> <li> <p>Que verra l'utilisateur \u00e0 l'\u00e9cran\u2009?</p> <ul> <li>Il verra <code>y = 12</code> pour <code>a = 2; x = 5; b = 2</code></li> </ul> </li> <li> <p>Quelle est l'utilit\u00e9 de ce programme\u2009?</p> <ul> <li>Le calcul d'un point d'une droite</li> </ul> </li> </ol> <p>Exercise\u2009: \u00c9quation de droite</p> <p>L'exercice pr\u00e9c\u00e9dent souffre de nombreux d\u00e9fauts. Sauriez-vous les identifier et perfectionner l'impl\u00e9mentation de ce programme\u2009?</p> Solution <p>Citons les d\u00e9fauts de ce programme\u2009:</p> <ul> <li>Le programme ne peut pas \u00eatre utilis\u00e9 avec les arguments, uniquement en mode interactif</li> <li>Les invit\u00e9s de dialogue <code>a =</code>, <code>b =</code> ne sont pas clair, <code>a</code> et <code>b</code> sont associ\u00e9s \u00e0 quoi\u2009?</li> <li>La valeur de retour n'est pas exploitable directement.</li> <li>Le nom des variables utilis\u00e9 n'est pas clair.</li> <li>Aucune valeur par d\u00e9faut.</li> </ul> <p>Une solution possible serait\u2009:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(int argc, char* argv[])\n{\n    float x;\n    float offset;\n    float slope;\n\n    if (argc &gt; 2) {\n        offset = atof(argv[1]);\n        slope = atof(argv[2]);\n    } else {\n        float offset_default = 0.;\n        printf(\"Offset? [%f]: \", offset_default);\n        if (!scanf(\"%f\", &amp;offset)) {\n            offset = offset_default;\n        }\n\n        float slope_default = 1.;\n        printf(\"Pente? [%f]: \", slope_default);\n        if (!scanf(\"%f\", &amp;slope)) {\n            slope = slope_default;\n        }\n    }\n\n    if (argc == 2 || argc &gt; 3) {\n        slope = atof(argv[argc == 2 ? 2: 3]);\n    } else {\n        float x_default = 0;\n        printf(\"x (abscisse) [%f]:\", x_default);\n        if (!scanf(\"%f\", &amp;x)) {\n            x = x_default;\n        }\n    }\n\n    printf(\"%f\\n\", slope * x + offset);\n\n    return 0;\n}\n</code></pre> <p>Exercise\u2009: Loi d'Ohm</p> <p>\u00c9crivez un programme demandant deux r\u00e9els <code>tension</code> et <code>r\u00e9sistance</code>, et affichez ensuite le <code>courant</code>. Pr\u00e9voir un test pour le cas o\u00f9 la r\u00e9sistance serait nulle.</p> <p>Exercise\u2009: Tour Eiffel</p> <p>Consid\u00e9rons le programme suivant\u2009:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;\n\nint main()\n{\n    printf(\"Quel angle mesurez-vous en visant le sommet du b\u00e2timent (en degr\u00e9s): \");\n    float angle_degre;\n    scanf(\"%f\", &amp;angle_degrees);\n    float angle_radian = angle_degrees * M_PI / 45.;\n\n    printf(\"\u00c0 quelle distance vous trouvez vous du b\u00e2timent (en m\u00e8tres): \");\n    float distance;\n    scanf(\"%f\", &amp;distance);\n\n    float height = distance / tan(angle_radian);\n    printf(\"La hauteur du b\u00e2timent est : %g m\u00e8tres.\\n\", height);\n}\n</code></pre> <ol> <li>Que fait le programme \u00e9tape par \u00e9tape\u2009?</li> <li>Que verra l'utilisateur \u00e0 l'\u00e9cran\u2009?</li> <li>\u00c0 quoi sert ce programme\u2009?</li> <li>Euh, mais\u2009? Ce programme comporte des erreurs, lesquelles\u2009?</li> <li>Impl\u00e9mentez-le et testez-le.</li> </ol> <p>Exercise\u2009: Hyperloop</p> <p>Hyperloop (aussi orthographi\u00e9 Hyperl\u221ep) est un projet ambitieux d'Elon Musk visant \u00e0 construire un moyen de transport ultra rapide utilisant des capsules voyageant dans un tube sous vide. Ce projet est analogue \u00e0 celui \u00e9tudi\u00e9 en suisse et nomm\u00e9 Swissmetro, mais abandonn\u00e9 en 2009.</p> <p>N\u00e9anmoins, les ing\u00e9nieurs suisses avaient \u00e0 l'\u00e9poque \u00e9crit un programme pour calculer, compte tenu d'une vitesse donn\u00e9e, le temps de parcours entre deux villes de Suisse.</p> <p>\u00c9crire un programme pour calculer la distance entre deux villes de suisse parmi lesquelles propos\u00e9es sont\u2009:</p> <ul> <li>Gen\u00e8ve</li> <li>Z\u00fcrich</li> <li>B\u00e2le</li> <li>Bern</li> <li>St-Galle</li> </ul> <p>Consid\u00e9rez une acc\u00e9l\u00e9ration de 0.5 g pour le calcul de mouvement, et une vitesse maximale de 1220 km/h.</p>"}, {"location": "course-c/15-fundations/syntax/", "title": "Syntaxe", "text": "<p>Ce chapitre traite des \u00e9l\u00e9ments constitutifs et fondamentaux du langage C. Il traite des g\u00e9n\u00e9ralit\u00e9s propres au langage, mais aussi des notions \u00e9l\u00e9mentaires permettant d'interpr\u00e9ter du code source. Notons que ce chapitre est transversal, \u00e0 la sa premi\u00e8re lecture, le profane ne pourra tout comprendre sans savoir lu et ma\u00eetris\u00e9 les chapitres suivants, n\u00e9anmoins il retrouvera ici les aspects fondamentaux du langage.</p>"}, {"location": "course-c/15-fundations/syntax/#lalphabet", "title": "L'alphabet", "text": "<p>Fort heureusement pour nous occidentaux, l'alphabet de C est compos\u00e9 des 52 caract\u00e8res latins et de 10 chiffres indo-arabes :</p> <pre><code>A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\na b c d e f g h i j k l m n o p q r s t u v w x y z\n0 1 2 3 4 5 6 7 8 9\n</code></pre> <p>Pour comparaison, le syst\u00e8me d'\u00e9criture cor\u00e9en (Hangul) est alphasyllabique, c'est-\u00e0-dire que chaque caract\u00e8re repr\u00e9sente une syllabe. Les lettres de base sont compos\u00e9es de 14 consonnes de base et 10 voyelles. Quant aux chiffres ils sont les m\u00eames qu'en occident.</p> <pre><code>g n d r/l m b s ng j ch k t p h\n\u3131 \u3134 \u3137 \u3139 \u3141 \u3142 \u3145 \u3147 \u3148 \u314a \u314b \u314c \u314d \u314e\n\na ya eo yeo o yo u yu eu i\n\u314f \u3151 \u3153 \u3155 \u3157 \u315b \u315c \u3160 \u3161 \u3163\n</code></pre> <p>Les japonais quant \u00e0 eux utilisent trois syst\u00e8mes d'\u00e9criture, le Hiragana, le Katakana et le Kanji. Les deux premiers sont des syllabaires et le dernier est un syst\u00e8me d'\u00e9criture logographique. Le Hiragana et Katakana ont tous deux 46 caract\u00e8res de base. Voici l'exemple du Katakana\u2009:</p> <pre><code>\u3042 (a),  \u3044 (i),   \u3046 (u),   \u3048 (e),  \u304a (o)\n\u304b (ka), \u304d (ki),  \u304f (ku),  \u3051 (ke), \u3053 (ko)\n\u3055 (sa), \u3057 (shi), \u3059 (su),  \u305b (se), \u305d (so)\n\u305f (ta), \u3061 (chi), \u3064 (tsu), \u3066 (te), \u3068 (to)\n\u306a (na), \u306b (ni),  \u306c (nu),  \u306d (ne), \u306e (no)\n\u306f (ha), \u3072 (hi),  \u3075 (fu),  \u3078 (he), \u307b (ho)\n\u307e (ma), \u307f (mi),  \u3080 (mu),  \u3081 (me), \u3082 (mo)\n\u3084 (ya), \u3086 (yu),  \u3088 (yo)\n\u3089 (ra), \u308a (ri),  \u308b (ru),  \u308c (re), \u308d (ro)\n\u308f (wa), \u3092 (wo)\n\u3093 (n)\n</code></pre> <p>On notera que l'alphabet latin est tout particuli\u00e8rement adapt\u00e9 \u00e0 la programmation car, d'une part ce fut le premier alphabet \u00e0 \u00eatre utilis\u00e9 pour l'\u00e9criture de programmes informatiques et d'autre part, il reste assez simple pour \u00eatre utilis\u00e9 par des machines. On peut noter en outre que les pays qui utilisent leur propre alphabet doivent imp\u00e9rativement apprendre et ma\u00eetriser l'alphabet latin pour pouvoir programmer. Ceci implique qu'ils doivent \u00e9galement disposer d'un clavier latin pour pouvoir saisir leur code. Nous avons donc privil\u00e9gi\u00e9s nous francophones de ne pas devoir jongler avec plusieurs alphabets pour \u00e9crire du code...</p> <p>Outre ces caract\u00e8res, la s\u00e9paration des symboles est assur\u00e9e par une espace, une tabulation horizontale, une tabulation verticale, et un caract\u00e8re de retour \u00e0 la ligne. Ces caract\u00e8res ne sont pas imprimables, c'est-\u00e0-dire qu'ils ne sont pas directement visibles ni \u00e0 l'\u00e9cran ni \u00e0 l'impression (ni sur le papier d'ailleurs). Microsoft Word et d'autres \u00e9diteurs utilisent g\u00e9n\u00e9ralement le pied-de-mouche <code>\u00b6</code> 00B6 pour indiquer les fins de paragraphes qui sont \u00e9galement des caract\u00e8res non imprimables.</p> <p>On nomme les caract\u00e8res non imprimables soit par leur acronyme <code>LF</code> pour Line Feed ou soit par leur convention C \u00e9chapp\u00e9e par un backslash <code>\\n</code>:</p>  Caract\u00e8res non imprimables Acronyme \u00c9chapp\u00e9 Description LF <code>\\n</code> Retour \u00e0 la ligne VT <code>\\v</code> Tabulation verticale FF <code>\\f</code> Nouvelle page TAB <code>\\t</code> Tabulation horizontale CR <code>\\r</code> Retour charriot SPACE <code>\\040</code> Espace NUL <code>\\0</code> Caract\u00e8re nul <p>Voici en pratique comment ces caract\u00e8res peuvent \u00eatre utilis\u00e9s\u2009:</p> <p> Distinction de diff\u00e9rents caract\u00e8res non imprimables</p> <p>La ponctuation utilise les 29 symboles graphiques suivants\u2009:</p> <pre><code>! # % ^ &amp; * ( _ ) - + = ~ [ ] ' | \\ ; : \" { } , . &lt; &gt; / ?\n</code></pre>", "tags": ["hiragana", "tabulation", "katakana", "hangul", "alphasyllabique", "kanji", "ecriture-logographique"]}, {"location": "course-c/15-fundations/syntax/#la-machine-a-ecrire", "title": "La machine \u00e0 \u00e9crire", "text": "<p>Peut-\u00eatre avez-vous d\u00e9j\u00e0 \u00e9t\u00e9 confront\u00e9 \u00e0 une machine \u00e0 \u00e9crire m\u00e9canique. Elles disposent d'un levier sur la gauche du chariot qui a deux fonctionnalit\u00e9s. D'une part il permet de faire revenir le chariot au d\u00e9but de la ligne, mais \u00e9galement de faire avancer le papier d'une ligne. C'est ce levier qui a donn\u00e9 son nom au caract\u00e8re de retour \u00e0 la ligne <code>CR</code> pour Carriage Return. Quant au caract\u00e8re de nouvelle ligne <code>LF</code> pour Line Feed, il est associ\u00e9 \u00e0 la rotation du cylindre qui porte la feuille de papier.</p> <p> Machine \u00e0 \u00e9crire Herm\u00e8s 3000 h\u00e9bra\u00efque</p> <p>Historiquement il y a donc bien une distinction entre les deux caract\u00e8res, mais aujourd'hui, cela n'a plus vraiment de sens.</p> <p>Un autre point que l'on peut relever est que pour souligner un texte, on utilisait le caract\u00e8re de souligement (tiret bas, ou underscore) <code>_</code> pour mettre en emphase du texte d\u00e9j\u00e0 \u00e9crit. De m\u00eame pour barrer un texte, on utilisait le caract\u00e8re <code>-</code> pour faire reculer le chariot d'une demi-case et ensuite frapper le m\u00eame caract\u00e8re. Enfin pour ajouter un accent circonflexe, il fallait utiliser la touche <code>^</code> pour faire reculer le chariot d'une demi-case et ensuite frapper la lettre \u00e0 accentuer.</p> <p>Ces subtilit\u00e9s de la machine \u00e0 \u00e9crire ont \u00e9t\u00e9 partiellement reprises dans le format Unicode. Aussi pour \u00e9crire un accent aigu, il y a aujourd'hui plusieurs fa\u00e7ons de le faire.</p> <ol> <li>Utiliser le caract\u00e8re <code>e</code> 0065 suivi du caract\u00e8re <code>\u00b4</code> 0301 aussi appel\u00e9 combining acute accent pour obtenir <code>\u00e9</code>.</li> <li>Utiliser le caract\u00e8re <code>\u00e9</code> 00E9 directement.</li> </ol> <p>Ces h\u00e9ritages historiques font qu'il est difficile aujourd'hui de traiter sans bogue les textes multilingues. Les cas particuliers sont nombreux et bien souvent, les informaticiens utilisent des biblioth\u00e8ques logicielles pour g\u00e9rer ces cas particuliers.</p> <p>Un fait historique int\u00e9ressant est que les premiers ordinateurs ne disposaient pas d'un clavier ayant tous ces symboles et la commission responsable de standardiser C a int\u00e9gr\u00e9 au standard les trigraphes et plus tard les digraphes qui sont des combinaisons de caract\u00e8res de base qui remplacent les caract\u00e8res impossibles \u00e0 saisir directement. Ainsi <code>&lt;:</code> est le digraphe de <code>[</code> et <code>??&lt;</code> est le trigraphe de <code>{</code>. N\u00e9anmoins vous conviendrez cher lecteur que ces alternatives ne devraient \u00eatre utilis\u00e9es que dans des cas extr\u00eames et justifiables. Par ailleurs, le standard C et C++ songent \u00e0 les retirer.</p> <p>Retenez que C peut \u00eatre un langage extr\u00eamement cryptique tant il est permissif sur sa syntaxe. Il existe d'ailleurs un concours international d'obfuscation, le The International Obfuscated C Code Contest qui prime des codes les plus subtils et illisibles comme le code suivant \u00e9crit par Chris Mills. Il s'agit d'ailleurs d'un exemple qui compile parfaitement sur la plupart des compilateurs.</p> <pre><code>    int I=256,l,c, o,O=3; void e(\nint L){ o=0; for( l=8; L&gt;&gt;++l&amp;&amp;\n16&gt;l;                           o+=l\n&lt;&lt;l-                            1) ;\no+=l                     *L-(l&lt;&lt;l-1); { ; }\nif (                    pread(3,&amp;L,3,O+o/8)&lt;\n2)/*                    */exit(0);  L&gt;&gt;=7&amp;o;\nL%=1                     &lt;&lt;l; L&gt;&gt;8?256-L?e(\nL-1)                            ,c||\n(e(c                            =L),\nc=0)                            :( O\n+=(-I&amp;7)*l+o+l&gt;&gt;3,I=L):putchar(\n    L); }int main(int l,char**o){\n                for(\n            /*          ////      */\n            open(1[o],0); ; e(I++\n            ))                    ;}\n</code></pre> Exemple grivois <p>Ce code \u00e9galement issu du IOCCC est un exemple pas tr\u00e8s gracieux de ce qu'il est possible de faire en C. Il est \u00e0 noter que ce code compile parfaitement et affiche un message pas tr\u00e8s Catholique.</p> <pre><code>main(i){for(i=160;i--;putchar(i%32?\"\u0153\u2122c\u00e6RJ\"\"\\\\J\u2022\u00e4RJ\"\"\u0153]d\u00e4\"[i/8]&amp;1&lt;&lt;i%8?42:32:10));}\n</code></pre>", "tags": ["tiret-bas"]}, {"location": "course-c/15-fundations/syntax/#fin-de-lignes-eol", "title": "Fin de lignes (EOL)", "text": "<p>\u00c0 l'instar des premi\u00e8res machines \u00e0 \u00e9crire, les t\u00e9l\u00e9scripteurs poss\u00e9daient de nombreux caract\u00e8res de d\u00e9placement qui sont depuis tomb\u00e9s en d\u00e9su\u00e9tude et pr\u00eatent aujourd'hui \u00e0 confusion m\u00eame pour le plus aguerri des programmeurs. Maintenant que les ordinateurs poss\u00e8dent des \u00e9crans, la notion originale du terme retour chariot est compromise et comme il y a autant d'avis que d'ing\u00e9nieurs, les premiers PC IBM compatibles ont choisi qu'une nouvelle ligne d\u00fbt toujours se composer de deux caract\u00e8res\u2009: un retour chariot (<code>CR</code>) et une nouvelle ligne (<code>LF</code>) ou en C <code>\\r\\n</code>. Les premiers Macintosh d'Apple jugeant inutile de gaspiller deux caract\u00e8res pour chaque nouvelle ligne dans un fichier et ont d\u00e9cid\u00e9 d'associer le retour chariot et la nouvelle ligne dans le caract\u00e8re <code>\\r</code>. Enfin, les ordinateurs UNIX ont eu le m\u00eame raisonnement, mais ils ont choisi de ne garder que <code>\\n</code>.</p> <p>Fort heureusement depuis que Apple a migr\u00e9 son syst\u00e8me sur une base BSD (UNIX) en 2001, les syst\u00e8mes d'exploitation modernes ont adopt\u00e9 le standard UNIX et il n'y a plus de probl\u00e8me de compatibilit\u00e9 entre les syst\u00e8mes.</p> <p>En sommes, il existe aujourd'hui deux types de fin de ligne\u2009:</p> <ul> <li><code>LF</code> ou <code>\\n</code> sur les ordinateurs POSIX comme Linux, Android, Unix ou macOS</li> <li><code>CRLF</code> ou <code>\\r\\n</code> sur les ordinateurs Windows.</li> </ul> <p>Il n'y a pas de consensus \u00e9tabli sur lesquels des deux types de fin de ligne (<code>EOL</code>: End Of Line) il faut utiliser, faite preuve de bon sens et surtout, soyez coh\u00e9rent.</p>"}, {"location": "course-c/15-fundations/syntax/#mots-cles", "title": "Mots cl\u00e9s", "text": "<p>Le langage de programmation C tel que d\u00e9fini par C11 comporte environ 37 mots cl\u00e9s\u2009:</p> <pre><code>_Bool       do        int       switch\n_Complex    double    long      typedef\n_Imaginary  else      register  union\nauto        enum      restrict  unsigned\nbreak       extern    return    void\ncase        float     short     volatile\nchar        for       signed    while\nconst       goto      sizeof\ncontinue    if        static\ndefault     inline    struct\n</code></pre> <p>Dans ce cours, l'usage des mots cl\u00e9s suivants est d\u00e9courag\u00e9, car leur utilisation pourrait pr\u00eater \u00e0 confusion ou mener \u00e0 des in\u00e9l\u00e9gances d'\u00e9criture.</p> <pre><code>_Bool, _imaginary, auto, goto, inline, long, register, restrict, short\n</code></pre> <p>Il n'y a donc plus que 28 mots cl\u00e9s \u00e0 conna\u00eetre pour \u00eatre un bon d\u00e9veloppeur C.</p> <p>Notons que les mots cl\u00e9s <code>true</code> et <code>false</code> ne sont pas standardis\u00e9s en C, mais ils le sont en C++.  </p> <p>Ces mots cl\u00e9s font partie int\u00e9grante de la grammaire du langage et ne peuvent \u00eatre utilis\u00e9s pour identifier des variables, des fonctions ou des \u00e9tiquettes.</p> Nombre de mots cl\u00e9s <p>On peut se demander s'il est pr\u00e9f\u00e9rable pour un langage d'avoir plus ou moins de mots cl\u00e9s. En effet, plus il y a de mots cl\u00e9s, plus il est difficile d'apprendre le langage, mais plus il y a de mots cl\u00e9s, plus il est facile de comprendre le code des autres.</p> <p>C'est le m\u00eame dilemme entre les architectures processeur RISC et CISC. Les architectures RISC ont moins d'instructions, mais elles sont plus complexes \u00e0 utiliser, tandis que les architectures CISC ont plus d'instructions, mais elles sont plus simples \u00e0 utiliser.</p> <p>Le Perl par exemple n'a environ que 20 mots cl\u00e9s, mais il est r\u00e9put\u00e9 pour \u00eatre un langage difficile \u00e0 apprendre. Le C++ dans sa version 2020 en a plus de 84.</p> <p></p>"}, {"location": "course-c/15-fundations/syntax/#identificateurs", "title": "Identificateurs", "text": "<p>Un identificateur est une s\u00e9quence de caract\u00e8res repr\u00e9sentant une entit\u00e9 du programme et \u00e0 laquelle il est possible de se r\u00e9f\u00e9rer. Un identificateur est d\u00e9fini par une grammaire r\u00e9guli\u00e8re qui peut \u00eatre exprim\u00e9e comme suit\u2009:</p> <p> Grammaire d'un identificateur C</p> <p>La notation /[a-z]/ signifie que l'on peut utiliser n'importe quelle lettre minuscule de l'alphabet latin, /[A-Z]/ pour les lettres majuscules, /[0-9]/ pour les chiffres et <code>_</code> pour le caract\u00e8re soulign\u00e9.</p> <p>En addition de cette grammaire, voici quelques r\u00e8gles\u2009:</p> <ol> <li>Un identificateur ne peut pas \u00eatre l'un des mots cl\u00e9s du langage.</li> <li>Les identificateurs sont sensibles \u00e0 la casse (majuscule/minuscule).</li> <li>Le standard C99, se r\u00e9serve l'usage de tous les identificateurs d\u00e9butant par <code>_</code> suivi d'une lettre majuscule ou un autre underscore <code>_</code>.</li> <li>Le standard POSIX, se r\u00e9serve l'usage de tous les identificateurs finissant par <code>_t</code>.</li> </ol> <p>Expression r\u00e9guli\u00e8re</p> <p>Il est possible d'exprimer la syntaxe d'un identificateur \u00e0 l'aide de l'expression r\u00e9guli\u00e8re suivante\u2009:</p> <p>/^[a-zA-Z_][a-zA-Z0-9_]*$/</p> <p>Exercise\u2009: Validit\u00e9 des identificateurs</p> <p>Pour chacune des suites de caract\u00e8res ci-dessous, indiquez s'il s'agit d'un identificateur valide et utilisable en C. Justifier votre r\u00e9ponse.</p> <ul> <li>[ ] <code>2_pi</code></li> <li>[x] <code>x_2</code></li> <li>[x] <code>x___3</code></li> <li>[ ] <code>x 2</code></li> <li>[x] <code>positionRobot</code></li> <li>[x] <code>piece_presente</code></li> <li>[x] <code>_commande_vanne</code></li> <li>[ ] <code>-courant_sortie</code></li> <li>[x] <code>_alarme_</code></li> <li>[ ] <code>panne#2</code></li> <li>[ ] <code>int</code></li> <li>[ ] <code>d\u00e9faillance</code></li> <li>[ ] <code>f'</code></li> <li>[x] <code>INT</code></li> </ul> Solution <p>Une excellente approche serait d'utiliser directement l'expression r\u00e9guli\u00e8re fournie et d'utiliser l'outil en ligne regex101.com.</p> <ol> <li><code>2_pi</code> invalide, car commence par un chiffre</li> <li><code>x_2</code> valide</li> <li><code>x___3</code> valide</li> <li><code>x 2</code> invalide, car comporte un espace</li> <li><code>positionRobot</code> valide, notation camelCase</li> <li><code>piece_presente</code> valide, notation snake_case</li> <li><code>_commande_vanne</code> valide</li> <li><code>-courant_sortie</code> invalide, un identificateur ne peut pas commencer par le signe <code>-</code></li> <li><code>_alarme_</code> valide</li> <li><code>panne#2</code> invalide, le caract\u00e8re <code>#</code> n'est pas autoris\u00e9</li> <li><code>int</code> invalide, <code>int</code> est un mot r\u00e9serv\u00e9 du langage</li> <li><code>d\u00e9faillance</code> invalide, uniquement les caract\u00e8res imprimable ASCII sont autoris\u00e9s</li> <li><code>f'</code> invalide l'apostrophe n'est pas autoris\u00e9e</li> <li><code>INT</code> valide</li> </ol>"}, {"location": "course-c/15-fundations/syntax/#variables", "title": "Variables", "text": "<p>Une variable est un symbole qui associe un nom (identificateur) \u00e0 une valeur. Comme son nom l'indique, une variable peut voir son contenu varier au cours du temps.</p> <p>Une variable est d\u00e9finie par\u2009:</p> <ul> <li>Son nom (name), c'est-\u00e0-dire l'identificateur associ\u00e9 au symbole.</li> <li>Son type (type), qui est la convention d'interpr\u00e9tation du contenu binaire en m\u00e9moire.</li> <li>Sa valeur (value), qui est le contenu interpr\u00e9t\u00e9 connaissant son type.</li> <li>Son adresse (address) qui est l'emplacement m\u00e9moire ou la repr\u00e9sentation binaire sera enregistr\u00e9e.</li> <li>Sa port\u00e9e (scope) qui est la portion de code ou le symbole est d\u00e9finie et accessible.</li> <li>Sa visibilit\u00e9 (visibility) qui ne peut \u00eatre que public en C.</li> </ul> <p>Pour mieux comprendre ce concept fondamental, imaginons la plage de Donnant \u00e0 Belle-\u00cele-en-Mer. Quelqu'un a \u00e9crit sur le sable, bien visible depuis la colline adjacente, le mot <code>COIN</code>. L'identificateur c'est <code>Donnant</code>, la valeur c'est <code>COIN</code>, le type permet de savoir comment interpr\u00e9ter la valeur. Cela peut s'agir d'une pi\u00e8ce de monnaie en anglais, du coin d'une table en fran\u00e7ais ou du lapin en neerlandais.</p> <p>L'adresse est l'emplacement exact de la plage o\u00f9 le mot a \u00e9t\u00e9 \u00e9crit (47.32638670571\u00b0 N, 3.2363350691522\u00b0 W), la port\u00e9e est la plage de Donnant et la visibilit\u00e9 est la colline adjacente.</p> <p>On voit que sans conna\u00eetre le type de la variable, il est impossible de savoir comment interpr\u00e9ter sa valeur.</p> <p> La plage de Donnant</p> <p>En pratique l'adresse sera plut\u00f4t de la forme <code>0x7fffbf7f1b4c</code>, la valeur serait plut\u00f4t <code>0100001101001111010010010100111000000000</code> et le type serait une cha\u00eene de caract\u00e8res <code>char[]</code>.</p> <p>Variables initialis\u00e9es</p> <p>Le fait de d\u00e9clarer des variables dans en langage C implique que le logiciel doit r\u00e9aliser l'initialisation de ces variables au tout d\u00e9but de son ex\u00e9cution. De fait, on peut remarquer deux choses. Il y a les variables initialis\u00e9es \u00e0 la valeur z\u00e9ro et les variables initialis\u00e9es \u00e0 des valeurs diff\u00e9rentes de z\u00e9ro. Le compilateur regroupe en m\u00e9moire ces variables en deux cat\u00e9gories et ajoute un bout de code au d\u00e9but de votre application (qui est ex\u00e9cut\u00e9 avant le <code>main</code>).</p> <p>Ce code (que l'on n'a pas \u00e0 \u00e9crire) effectue les op\u00e9rations suivantes\u2009:</p> <ul> <li>mise \u00e0 z\u00e9ro du bloc m\u00e9moire contenant les variables ayant \u00e9t\u00e9   d\u00e9clar\u00e9es avec une valeur d'initialisation \u00e0 z\u00e9ro,</li> <li>recopie d'une zone m\u00e9moire contenant les valeurs initiales des   variables ayant \u00e9t\u00e9 d\u00e9clar\u00e9es avec une valeur d'initialisation   diff\u00e9rente de z\u00e9ro vers la zone de ces m\u00eames variables.</li> </ul> <p>Par ce fait, d\u00e8s que l'ex\u00e9cution du logiciel est effectu\u00e9e, on a, lors de l'ex\u00e9cution du <code>main</code>, des variables correctement initialis\u00e9es.</p>"}, {"location": "course-c/15-fundations/syntax/#declaration", "title": "D\u00e9claration", "text": "<p>Avant de pouvoir \u00eatre utilis\u00e9e, une variable doit \u00eatre d\u00e9clar\u00e9e afin que le compilateur puisse r\u00e9server un emplacement en m\u00e9moire pour stocker sa valeur.</p> <p>Voici quelques d\u00e9clarations valides\u2009:</p> <pre><code>char c = '\u20ac';\nint temperature = 37;\nfloat neptune_stone_height = 376.86;\nchar message[] = \"Jarvis, il faut parfois savoir \"\n                 \"courir avant de savoir marcher.\";\n</code></pre> <p>Il n'est pas n\u00e9cessaire d'associer une valeur initiale \u00e0 une variable, une d\u00e9claration peut se faire sans initialisation comme montr\u00e9 dans l'exemple suivant dans lequel on r\u00e9serve trois variables <code>i</code>, <code>j</code>, <code>k</code>.</p> <pre><code>int i, j, k;\n</code></pre> <p>Exercise\u2009: Affectation de variables</p> <p>Consid\u00e9rons les d\u00e9clarations suivantes\u2009:</p> <pre><code>int a, b, c;\nfloat x;\n</code></pre> <p>Notez apr\u00e8s chaque affectation, le contenu des diff\u00e9rentes variables\u2009:</p> Ligne Instruction <code>a</code> <code>b</code> <code>c</code> <code>x</code> 1 <code>a = 5;</code> 2 <code>b = c;</code> 3 <code>c = a;</code> 4 <code>a = a + 1;</code> 5 <code>x = a - ++c;</code> 6 <code>b = c = x;</code> 7 <code>x + 2. = 7.;</code> Solution Ligne Instruction <code>a</code> <code>b</code> <code>c</code> <code>x</code> 1 <code>a = 5;</code> 5 ? ? ? 2 <code>b = c;</code> 5 ? ? ? 3 <code>c = a;</code> 5 ? 5 ? 4 <code>a = a + 1;</code> 6 ? 5 ? 5 <code>x = a - ++c;</code> 6 ? 6 12 6 <code>b = c = x;</code> 6 12 12 12 7 <code>x + 2. = 7.;</code> - - - -"}, {"location": "course-c/15-fundations/syntax/#convention-de-nommage", "title": "Convention de nommage", "text": "<p> Diff\u00e9rentes casses illustr\u00e9es</p> <p>Il existe autant de conventions de nommage qu'il y a de d\u00e9veloppeurs, mais un consensus majoritaire, que l'on retrouve dans d'autres langages de programmation dit que\u2009:</p> <ul> <li>La longueur du nom d'une variable est g\u00e9n\u00e9ralement proportionnelle \u00e0 sa port\u00e9e et donc il est d'autant plus court que l'utilisation d'une variable est localis\u00e9e.</li> <li>Le nom doit \u00eatre concis et pr\u00e9cis et ne pas laisser place \u00e0 une quelconque ambigu\u00eft\u00e9.</li> <li>Le nom doit participer \u00e0 l'autodocumentation du code et permettre \u00e0 un lecteur de comprendre facilement le programme qu'il lit.</li> </ul> <p>Selon les standards adopt\u00e9s, chaque soci\u00e9t\u00e9 on trouve ceux qui pr\u00e9f\u00e8rent nommer les variables en utilisant un underscore (<code>_</code>) comme s\u00e9parateur et ceux qui pr\u00e9f\u00e8rent nommer une variable en utilisant des majuscules comme s\u00e9parateurs de mots.</p>  Conventions de nommage Convention Nom fran\u00e7ais Exemple camelcase Casse de chameau <code>userLoginCount</code> snakecase Casse de serpent <code>user_login_count</code> pascalcase Casse de Pascal <code>UserLoginCount</code> kebabcase Casse de kebab <code>user-login-count</code> <p>Note</p> <p>La casse de kebab n'est pas accept\u00e9e par le standard C car les noms form\u00e9s ne sont pas des identificateurs valides. N\u00e9anmoins cette notation est beaucoup utilis\u00e9e par exemple sur GitHub.</p>"}, {"location": "course-c/15-fundations/syntax/#variable-metasyntaxique", "title": "Variable m\u00e9tasyntaxique", "text": "<p>Souvent lors d'exemples donn\u00e9s en programmation, on utilise des variables g\u00e9n\u00e9riques dites m\u00e9tasyntaxiques. En fran\u00e7ais les valeurs <code>toto</code>, <code>titi</code>, <code>tata</code> et <code>tutu</code> sont r\u00e9guli\u00e8rement utilis\u00e9es tandis qu'en anglais <code>foo</code>, <code>bar</code>, <code>baz</code> et <code>qux</code> sont r\u00e9guli\u00e8rement utilis\u00e9s. Les valeurs <code>spam</code>, <code>ham</code> et <code>eggs</code> sont quant \u00e0 elles souvent utilis\u00e9e en Python, en r\u00e9f\u00e9rence au sketch Spam des Monthy Python.</p> <p>Leur usage est conseill\u00e9 pour appuyer le cadre g\u00e9n\u00e9rique d'un exemple sans lui donner la consonance d'un probl\u00e8me plus sp\u00e9cifique.</p> <p>On trouvera une table des diff\u00e9rents noms les plus courants utilis\u00e9s dans diff\u00e9rentes langues.</p> <p>Foo, Bar, Titi et Toto</p> <p>L'origine de <code>foo</code> et <code>bar</code> remonte \u00e0 la deuxi\u00e8me guerre mondiale o\u00f9 les militaires am\u00e9ricains utilisaient ces termes pour d\u00e9signer des objets non identifi\u00e9s.</p> <p>Titi et Toto sont des personnages de bande dessin\u00e9e cr\u00e9\u00e9s par Maurice Cuvillier en 1931.</p>"}, {"location": "course-c/15-fundations/syntax/#les-constantes", "title": "Les constantes", "text": "<p>Une constante par opposition \u00e0 une variable voit son contenu fixe et immuable.</p> <p>Formellement, une constante se d\u00e9clare comme une variable, mais pr\u00e9fix\u00e9e du mot-cl\u00e9 <code>const</code>.</p> <pre><code>const double scale_factor = 12.67;\n</code></pre> <p>La constante est principalement utilis\u00e9e pour indiquer au d\u00e9veloppeur que la valeur ne doit pas \u00eatre modifi\u00e9e. Le compilateur peut \u00e9galement s'en servir pour mieux optimiser le code et donc am\u00e9liorer les performances d'ex\u00e9cution.</p> <p>Avertissement</p> <p>Il ne faut pas confondre la constante qui est une variable immuable, stock\u00e9e en m\u00e9moire et une macro qui appartient au pr\u00e9processeur. Sur certaines plateformes, le fichier d'en-t\u00eate <code>math.h</code> d\u00e9finit par exemple la constante <code>M_PI</code> sous forme de macro.</p> <pre><code>#define M_PI 3.14159265358979323846\n</code></pre> <p>Cette m\u00eame constante peut \u00eatre d\u00e9finie comme une variable constante\u2009:</p> <pre><code>const double pi = 3.14159265358979323846;\n</code></pre> <p>En r\u00e9sum\u00e9, les constantes sont utilis\u00e9es pour\u2009:</p> <ul> <li>\u00c9viter les erreurs de programmation en \u00e9vitant de modifier une valeur qui ne devrait pas l'\u00eatre.</li> <li>Indiquer au compilateur que la valeur ne changera pas et qu'il peut optimiser le code en cons\u00e9quence.</li> <li>Indiquer au d\u00e9veloppeur que la valeur ne sera pas modifi\u00e9e plus tard dans le programme.</li> </ul>"}, {"location": "course-c/15-fundations/syntax/#constantes-litterales", "title": "Constantes litt\u00e9rales", "text": "<p>Les constantes litt\u00e9rales repr\u00e9sentent des grandeurs scalaires num\u00e9riques ou de caract\u00e8res et initialis\u00e9es lors de la phase de compilation.</p> <p>En effet, lorsque l'on veut saisir un nombre, on ne veut pas que le compilateur la comprenne comme un identificateur, mais bien comme une valeur num\u00e9rique. C'est d'ailleurs la raison pour laquelle un identificateur ne peut pas commencer par un chiffre.</p> <p>Les constantes litt\u00e9rales sont g\u00e9n\u00e9ralement identifi\u00e9es avec des pr\u00e9fixes et des suffixes pour indiquer leur nature. Voici quelques exemples\u2009:</p> <pre><code>6      // Grandeur valant le nombre d'heures sur l'horloge du Palais du Quirinal \u00e0 Rome\n12u    // Grandeur non sign\u00e9e\n6l     // Grandeur enti\u00e8re sign\u00e9e cod\u00e9e sur un entier long\n42ul   // Grandeur enti\u00e8re non sign\u00e9e cod\u00e9e sur un entier long\n010    // Grandeur octale valant 8 en d\u00e9cimal\n0xa    // Grandeur hexad\u00e9cimale valant 10 en d\u00e9cimal\n0b111  // Grandeur binaire valant 7 en d\u00e9cimal\n1.     // Grandeur r\u00e9elle exprim\u00e9e en virgule flottante\n'0'    // Grandeur caract\u00e8re valant 48 en d\u00e9cimal\n2e3    // Grandeur r\u00e9elle exprim\u00e9e en notation scientifique\n</code></pre> <p>Nous l'avons vu plus haut, le type d'une variable est important pour d\u00e9terminer comment une valeur est stock\u00e9e en m\u00e9moire.</p> <p>Nous le verrons dans le chapitre sur la num\u00e9ration, les valeurs num\u00e9riques peuvent \u00eatre stock\u00e9es en m\u00e9moire de diff\u00e9rentes mani\u00e8res. Ainsi, une valeur <code>48</code> peut \u00eatre stock\u00e9e sur un octet, un mot de 16 bits, un mot de 32 bits ou un mot de 64 bits. De plus, la valeur peut faire r\u00e9f\u00e9rence au caract\u00e8re <code>0</code> en ASCII, mais aussi au nombre <code>72</code> s'il est exprim\u00e9 en hexad\u00e9cimal.</p> <p>Aussi, on utilisera un pr\u00e9fixe devant un nombre <code>0x</code> pour indiquer qu'il est en hexad\u00e9cimal, <code>0b</code> pour indiquer qu'il est en binaire et <code>0</code> pour indiquer qu'il est en octal. Sans pr\u00e9fixe il s'agit d'un nombre d\u00e9cimal (base 10).</p> <p>On utilisera un suffixe <code>u</code> pour indiquer que le nombre est non sign\u00e9 (n\u2019admettant pas de valeurs n\u00e9gatives) et <code>l</code> pour indiquer qu'il est long ou <code>ll</code> pour indiquer qu'il est tr\u00e8s long.</p> <p>Quant aux guillemets simples <code>'</code>, ils sont utilis\u00e9s pour d\u00e9limiter un caract\u00e8re de la table ASCII.</p> Expressions r\u00e9guli\u00e8res <p>Il est plus facile pour un informaticien de comprendre la syntaxe des constantes litt\u00e9rales en utilisant des expressions r\u00e9guli\u00e8res. Voici les expressions r\u00e9guli\u00e8res qui d\u00e9finissent les diff\u00e9rentes constantes litt\u00e9rales\u2009:</p> Type Expression r\u00e9guli\u00e8re Exemple Nombre sign\u00e9 /[1-9][0-9]*/ <code>42</code> Nombre non sign\u00e9 /[1-9][0-9]*u/ <code>42u</code> Nombre hexad\u00e9cimal /0x[0-9a-fA-F]+/ <code>0x2a</code> Nombre octal /0[0-7]+/ <code>052</code> <p>Exercise\u2009: Constances litt\u00e9rales</p> <p>Pour les entr\u00e9es suivantes, indiquez lesquelles sont correctes.</p> <ul> <li>[x] <code>12.3</code></li> <li>[x] <code>12E03</code></li> <li>[x] <code>12u</code></li> <li>[ ] <code>12.0u</code></li> <li>[ ] <code>1L</code></li> <li>[ ] <code>1.0L</code></li> <li>[x] <code>.9</code></li> <li>[x] <code>9.</code></li> <li>[ ] <code>.</code></li> <li>[x] <code>0x33</code></li> <li>[ ] <code>0xefg</code></li> <li>[x] <code>0xef</code></li> <li>[x] <code>0xeF</code></li> <li>[ ] <code>0x0.2</code></li> <li>[x] <code>09</code></li> <li>[x] <code>02</code></li> </ul> <p>La notation scientifique, aussi appel\u00e9e notation exponentielle, est une mani\u00e8re d'\u00e9crire des nombres tr\u00e8s grands ou tr\u00e8s petits de mani\u00e8re plus compacte. Par exemple, <code>1.23e3</code> est \u00e9quivalent \u00e0 <code>1230.</code> et <code>1.23e-3</code> est \u00e9quivalent \u00e0 <code>0.00123</code>. Le caract\u00e8re <code>e</code> est utilis\u00e9 pour indiquer la puissance de 10 par laquelle le nombre doit \u00eatre multipli\u00e9. Il tire probablement son origine du Fortran qui l'utilisait d\u00e9j\u00e0 en 1957.</p> <p>Avertissement</p> <p>Il ne faut pas confondre l'exponentiation avec le nombre d'Euler (2.71828...) <code>e</code> avec la notation scientifique <code>e</code> qui est utilis\u00e9e pour indiquer une puissance de 10.</p>"}, {"location": "course-c/15-fundations/syntax/#operateur-daffectation", "title": "Op\u00e9rateur d'affectation", "text": "<p>Dans les exemples ci-dessus, on utilise l'op\u00e9rateur d'affectation pour associer une valeur \u00e0 une variable.</p> <p>Historiquement, et fort malheureusement, le symbole choisi pour cet op\u00e9rateur est le signe \u00e9gal <code>=</code> or, l'\u00e9galit\u00e9 est une notion math\u00e9matique qui n'est en aucun cas reli\u00e9e \u00e0 l'affectation.</p> <p>Pour mieux saisir la nuance, consid\u00e9rons le programme suivant\u2009:</p> <pre><code>a = 42;\na = b;\n</code></pre> <p>Math\u00e9matiquement, la valeur de <code>b</code> devrait \u00eatre \u00e9gale \u00e0 42 ce qui n'est pas le cas en C o\u00f9 il faut lire, s\u00e9quentiellement l'ex\u00e9cution du code, car oui, C est un langage imp\u00e9ratif. Ainsi, dans l'ordre, on lit\u2009:</p> <ol> <li>J'assigne la valeur 42 \u00e0 la variable symbolis\u00e9e par <code>a</code></li> <li>Puis, j'assigne la valeur de la variable <code>b</code> au contenu de <code>a</code>.</li> </ol> <p>Comme on ne conna\u00eet pas la valeur de <code>b</code>, avec cet exemple, on ne peut pas conna\u00eetre la valeur de <code>a</code>.</p> <p>Certains langages de programmation ont \u00e9t\u00e9 sensibilis\u00e9s \u00e0 l'importance de cette distinction et dans les langages F#, OCaml, R ou S, l'op\u00e9rateur d'affectation est <code>&lt;-</code> et une affectation pourrait s'\u00e9crire par exemple\u2009: <code>a &lt;- 42</code> ou <code>42 -&gt; a</code>.</p> <p>En C, l'op\u00e9rateur d'\u00e9galit\u00e9 que nous verrons plus loin s'\u00e9crit <code>==</code> (deux <code>=</code> concat\u00e9n\u00e9s).</p> <p>Remarquez ici que l'op\u00e9rateur d'affectation de C agit toujours de droite \u00e0 gauche c'est-\u00e0-dire que la valeur \u00e0 droite de l'op\u00e9rateur est affect\u00e9e \u00e0 la variable situ\u00e9e \u00e0 gauche de l'op\u00e9rateur.</p> <p>S'agissant d'un op\u00e9rateur il est possible de cha\u00eener les op\u00e9rations, comme on le ferait avec l'op\u00e9rateur <code>+</code> et dans l'exemple suivant il faut lire que <code>42</code> est assign\u00e9 \u00e0 <code>c</code>, que la valeur de <code>c</code> est ensuite assign\u00e9 \u00e0 <code>b</code> et enfin la valeur de <code>b</code> est assign\u00e9e \u00e0 <code>a</code>.</p> <pre><code>a = b = c = 42;\n</code></pre> <p>Nous verrons plus tard comment l'ordre des op\u00e9rations et l'associativit\u00e9 de chaque op\u00e9rateur.</p> <p>Exercise\u2009: Affectations simples</p> <p>Donnez les valeurs de <code>x</code>, <code>n</code>, <code>p</code> apr\u00e8s l'ex\u00e9cution des instructions ci-dessous\u2009:</p> <pre><code>float x;\nint n, p;\n\np = 2;\nx = 15 / p;\nn = x + 0.5;\n</code></pre> Solution <pre><code>p \u2261 2\nx \u2261 7\nn \u2261 7\n</code></pre> <p>Exercise\u2009: Trop d'\u00e9galit\u00e9s</p> <p>On consid\u00e8re les d\u00e9clarations suivantes\u2009:</p> <pre><code>int i, j, k;\n</code></pre> <p>Donnez les valeurs des variables <code>i</code>, <code>j</code> et <code>k</code> apr\u00e8s l'ex\u00e9cution de chacune des expressions ci-dessous. Qu'en pensez-vous\u2009?</p> <pre><code>/* 1 */ i = (k = 2) + (j = 3);\n/* 2 */ i = (k = 2) + (j = 2) + j * 3 + k * 4;\n/* 3 */ i = (i = 3) + (k = 2) + (j = i + 1) + (k = j + 2) + (j = k - 1);\n</code></pre> Solution <p>Selon la table de priorit\u00e9 des op\u00e9rateurs, on note\u2009:</p> <ul> <li><code>()</code> priorit\u00e9 1 associativit\u00e9 \u00e0 droite</li> <li><code>*</code> priorit\u00e9 3 associativit\u00e9 \u00e0 gauche</li> <li><code>+</code> priorit\u00e9 4 associativit\u00e9 \u00e0 droite</li> <li><code>=</code> priorit\u00e9 14 associativit\u00e9 \u00e0 gauche</li> </ul> <p>En revanche rien n'est dit sur les <code>point de s\u00e9quences &lt;https://en.wikipedia.org/wiki/Sequence_point&gt;</code>__. L'op\u00e9rateur d'affectation n'est pas un point de s\u00e9quence, autrement dit le standard C99 (Annexe C) ne d\u00e9finit pas l'ordre dans lequel les assignations sont effectu\u00e9es.</p> <p>Ainsi, seul le premier point poss\u00e8de une solution, les deux autres sont ind\u00e9termin\u00e9s</p> <ol> <li> <p><code>i = (k = 2) + (j = 3)</code></p> <ul> <li><code>i = 5</code></li> <li><code>j = 3</code></li> <li><code>k = 2</code></li> </ul> </li> <li> <p><code>i = (k = 2) + (j = 2) + j * 3 + k * 4</code></p> <ul> <li>R\u00e9sultat ind\u00e9termin\u00e9</li> </ul> </li> <li> <p><code>i = (i = 3) + (k = 2) + (j = i + 1) + (k = j + 2) + (j = k - 1)</code></p> <ul> <li>R\u00e9sultat ind\u00e9termin\u00e9</li> </ul> </li> </ol>"}, {"location": "course-c/15-fundations/syntax/#espaces-de-noms", "title": "Espaces de noms", "text": "<p>En C, il est possible d'utiliser le m\u00eame identificateur pour autant qu'il n'appartient pas au m\u00eame espace de nom. Il existe en C plusieurs espaces de noms\u2009:</p> <ul> <li>\u00e9tiquettes utilis\u00e9es pour l'instruction <code>goto</code>;</li> <li>tag de structures, d'\u00e9num\u00e9rations et d'union\u2009;</li> <li>membres de structures, d'\u00e9num\u00e9rations et d'union\u2009;</li> <li>identificateurs de variable ou fonctions\u2009;</li> </ul> <p>Ces espaces de noms sont ind\u00e9pendants les uns des autres, il est donc possible d'utiliser le m\u00eame nom sans conflit. Par exemple\u2009:</p> <pre><code>typedef struct x { // Espace de nom des structures\n    int x; // Membre de la structure point\n} x; // Espace de nom des types\n\nint main() {\n    x x = {.x = 42}; // x est une variable de type x\n}\n</code></pre>"}, {"location": "course-c/15-fundations/syntax/#commentaires", "title": "Commentaires", "text": "<p>Comme en fran\u00e7ais et ainsi qu'illustr\u00e9 par la figure suivante, il est possible d'annoter un programme avec des commentaires. Les commentaires n'ont pas d'incidence sur le fonctionnement d'un programme et ne peuvent \u00eatre lu que par le d\u00e9veloppeur qui poss\u00e8de le code source.</p> <p> Les carafes dans la Vivonne</p> <p>Il existe deux mani\u00e8res d'\u00e9crire un commentaire en C\u2009:</p> <p>Les commentaires de lignes (depuis C99):</p> <pre><code>// This is a single line comment.\n</code></pre> <p>Les commentaires de blocs\u2009:</p> <pre><code>/* This is a\n    Multi-line comment */\n</code></pre> <p>Les commentaires sont pars\u00e9s par le pr\u00e9processeur, aussi ils n'influencent pas le fonctionnement d'un programme, mais seulement sa lecture. Rappelons qu'un code est plus souvent lu qu'\u00e9crit, car on ne l'\u00e9crit qu'une seule fois, mais comme tout d\u00e9veloppement doit \u00eatre si possible r\u00e9utilisable, il est plus probable qu'il soit lu part d'autres d\u00e9veloppeurs.</p> <p>En cons\u00e9quence, il est important de clarifier toute zone d'ombre lorsque l'on s'\u00e9loigne des consensus \u00e9tablis, ou lorsque le code seul n'est pas suffisant pour bien comprendre son fonctionnement.</p> <p>D'une fa\u00e7on g\u00e9n\u00e9rale, les commentaires servent \u00e0 expliquer pourquoi et non comment. Un bon programme devrait pouvoir se passer de commentaires, mais un programme sans commentaires n'est pas n\u00e9cessairement un bon programme.</p> <p>Note</p> <p>Il est pr\u00e9f\u00e9rable d'utiliser le commentaire de ligne d\u00e8s que possible, car d'une part il y a moins de caract\u00e8res \u00e0 \u00e9crire, mais surtout les commentaires de blocs ne sont pas imbriquables (nestable).</p> <pre><code>/*\n// Autoris\u00e9\n*/\n</code></pre> <pre><code>/*\n/* Interdit */\n*/\n</code></pre> <p>Les commentaires de blocs peuvent \u00eatre utilis\u00e9s pour documenter une fonction ou un bloc de code, mais \u00e9galement pour ins\u00e9rer un commentaire \u00e0 l'int\u00e9rieur d'une ligne\u2009:</p> <pre><code>int deep_throught /* Name of the computer */ = 42; // The answer\n</code></pre>"}, {"location": "course-c/15-fundations/syntax/#commenter-du-code", "title": "Commenter du code\u2009?", "text": "<p>Lorsque vous d\u00e9veloppez, vous avez souvent besoin de d\u00e9sactiver des portions de code pour des raisons de d\u00e9bogage ou de test. Il est tentant de commenter ces portions de code plut\u00f4t que de les supprimer.</p> <p>N\u00e9anmoins une r\u00e8gle \u00e0 retenir est que l'on ne commente jamais des portions de code, et ce pour plusieurs raisons\u2009:</p> <ol> <li>Les outils de refactoring ne pourront pas acc\u00e9der du code comment\u00e9</li> <li>La syntaxe ne pourra plus \u00eatre v\u00e9rifi\u00e9e par l'IDE</li> <li>Les outils de gestion de configuration (e.g. Git) devraient \u00eatre utilis\u00e9s \u00e0 cette fin</li> </ol> <p>Si d'aventure vous souhaitez quand m\u00eame exclure temporairement du code de la compilation, il est recommand\u00e9 d'utiliser la directive de pr\u00e9processeur suivante, et n'oubliez pas d'expliquer pourquoi vous avez souhait\u00e9 d\u00e9sactiver cette portion de code.</p> <pre><code>#if 0 // TODO: Check if divisor could still be null at this point.\nif (divisor == 0) {\n    return -1; // Error\n}\n#endif\n</code></pre>"}, {"location": "course-c/15-fundations/syntax/#quelques-conseils", "title": "Quelques conseils", "text": "<p>D'une mani\u00e8re g\u00e9n\u00e9rale l'utilisation des commentaires ne devrait pas \u00eatre utilis\u00e9e pour\u2009:</p> <ul> <li>D\u00e9sactiver temporairement une portion de code sans l'effacer.</li> <li>Expliquer le comment du fonctionnement du code.</li> <li>Faire dans le dithyrambique pompeux et notarial, des phrases \u00e0 rallonge bien trop romanesques.</li> <li>Cr\u00e9er de jolies s\u00e9parations telles que <code>/*************************/</code>.</li> </ul> <p>Exemple d'ent\u00eate de fichier\u2009:</p> <p>SSOT</p> <p>Vous verrez souvent, trop souvent le nom de l'auteur et du fichiers dans les en-t\u00eates. Ce n'est pas une bonne pratique si vous utilisez Git, car ces informations sont d\u00e9j\u00e0 pr\u00e9sentes dans les m\u00e9tadonn\u00e9es du fichier.</p> <pre><code>/**\n * @brief Short description of the translation unit.\n *\n * @author John Doe &lt;john@doe.com&gt;\n * @date 2021-09-01\n * @file main.c\n *\n * Long description of the translation unit.\n *\n * NOTE: Important notes about this code\n * TODO: Things to fix...\n */\n</code></pre> <p>Voici un exemple de ce qu'il ne faut pas faire\u2009:</p> Pas bienBien <pre><code>/*****************************************************\n                                           _..._\n _   _    _    ____    _                .'     '.      _\n| \\ | |  / \\  / ___|  / \\              /    .-\"\"-\\   _/ \\\n|  \\| | / _ \\ \\___ \\ / _ \\          .-|   /:.   |  |   |\n| |\\  |/ ___ \\ ___) / ___ \\         |  \\  |:.   /.-'-./\n|_| \\_/_/   \\_\\____/_/   \\_\\        | .-'-;:__.'    =/\n                                  .'=  *=|NASA _.='\n                                 /   _.  |    ;\n                                ;-.-'|    \\   |\n                               /   | \\    _\\  _\\\n                               \\__/'._;.  ==' ==\\\n                                        \\    \\   |\n                                 jgs    /    /   /\n                                        /-._/-._/\nNational Aeronautics and Space          \\   `\\  \\\nAdministration.                          `-._/._/\n\n@file appolo11.c\n@brief Launch control module\n@author Margaret Hamilton\n@date 1969-07-16\n\nThis module is responsible for the launch of the Apollo\n11 mission. It is a critical part of the mission and\nshould not be modified.\n*******************************************************/\n</code></pre> <pre><code>/**\n * Launch control module.\n *\n * This module is responsible for the launch of the Apollo\n * 11 mission. It is a critical part of the mission and\n * should not be modified.\n */\n</code></pre> <p>Le format des commentaires est par essence libre au d\u00e9veloppeur, mais il est g\u00e9n\u00e9ralement souhait\u00e9 que\u2009:</p> <ul> <li>Les commentaires soient concis et pr\u00e9cis.</li> <li>Les commentaires soient \u00e9crits en anglais.</li> </ul> <p>Exercise\u2009: Verbosit\u00e9</p> <p>Comment r\u00e9cririez-vous ce programme\u2009?</p> <pre><code>for (register unsigned int the_element_index = 0;\n    the_element_index &lt; number_of_elements; the_element_index += 1)\n    array_of_elements[the_element_index] =  the_element_index;\n</code></pre> Solution <p>Une r\u00e8gle de programmation\u2009: le nom identifieurs doit \u00eatre proportionnel \u00e0 leur contexte. Plus le contexte de la variable est r\u00e9duit, plus le nom peut \u00eatre court. Le m\u00eame programme pourrait \u00eatre \u00e9crit comme suit\u2009:</p> <pre><code>for (size_t i; i &lt; nelems; i++)\n    elem[i] = i;\n</code></pre> <p>Un consensus assez bien \u00e9tabli est qu'une variable commen\u00e7ant par <code>n</code> peut signifier number of.</p>"}, {"location": "course-c/20-architecture-and-systems/computer/", "title": "L'ordinateur", "text": "<p>Un ordinateur personnel (PC pour Personal Computer) est un appareil \u00e9lectronique de petite taille destin\u00e9 \u00e0 un usage individuel. Il se distingue des ordinateurs centraux (ou mainframes) et des serveurs, qui sont destin\u00e9s \u00e0 un usage professionnel ou collectif.</p> <p>N\u00e9anmoins, quelle que soit la taille de l'ordinateur, les composants de base sont les m\u00eames. Un ordinateur est compos\u00e9 de plusieurs \u00e9l\u00e9ments principaux\u00a0:</p> <ul> <li>Un processeur (ou CPU pour Central Processing Unit) qui ex\u00e9cute les instructions des programmes.</li> <li>De la m\u00e9moire (ou RAM pour Random Access Memory) qui stocke les donn\u00e9es et les instructions des programmes en cours d'ex\u00e9cution.</li> <li>Un disque dur (ou HDD pour Hard Disk Drive) qui stocke les donn\u00e9es de mani\u00e8re permanente.</li> <li>Une carte graphique qui affiche les images \u00e0 l'\u00e9cran.</li> <li>Une carte m\u00e8re qui relie tous les composants entre eux.</li> </ul>"}, {"location": "course-c/20-architecture-and-systems/computer/#la-ram", "title": "La RAM", "text": "<p>La m\u00e9moire vive est une m\u00e9moire de stockage temporaire, on l'appelle \u00e9galement m\u00e9moire non volatile. Le plus souvent une m\u00e9moire vive est amovible, il s'agit d'une barrette enfichable sur la carte m\u00e8re. Avec l'\u00e9volution de la technologie, ces m\u00e9moires sont car\u00e9n\u00e9es et munies d'un dissipateur thermique\u2009:</p> <p> 2 x 16 GB DDR5 DIMM Corsair Vengeance</p> <p>Sous le cap\u00f4t, on peut voir les puces de m\u00e9moire\u00a0:</p> <p> Crucial DDR4 16 GB</p> <p>Cette m\u00e9moire dispose de 16 Gibioctets de m\u00e9moire, soit \\(16 \\times 2^30 = 17179869184\\) octets. Chaque octet est compos\u00e9 de \\(8\\) bits, soit \\(17179869184 \\times 8 = 137438953472\\) bits. Comme nous voyons \\(4\\) puces de m\u00e9moire, chaque puce contient \\(4\\) Gibioctets.</p> <p>G\u00e9n\u00e9ralement, ces m\u00e9moires sont vendues en nombre de bits, soit ici 32 Gibibits.</p> <p>Sur le circuit \u00e9lectronique ou PCB (Printed Circuit Board), on voit les 4 puces de m\u00e9moire soud\u00e9es. Il s'agit d'un composant de la soci\u00e9t\u00e9 Micron, un MT40A1G8. La structure interne de cette m\u00e9moire est donn\u00e9e par la datasheet du composant\u00a0:</p> <p> MT40A1G8</p> <p>Pour d\u00e9coder ce sch\u00e9ma, int\u00e9ressons-nous aux fl\u00e8ches de couleur. Il s'agit du bus d'adresse. Ce bus comporte 16 lignes en parall\u00e8le qui sont interfac\u00e9es \u00e0 deux blocs\u2009: le Row Address MUX et le Column address counter. Ces deux blocs permettent de s\u00e9lectionner une cellule m\u00e9moire selon la m\u00e9moire, une cellule peut valoir 4, 8, 16 ou 32 bits.</p> <p>Les cellules m\u00e9moires sont organis\u00e9es and matrice ligne/colonne et chaque matrice est organis\u00e9e en banque. C'est ce qu'on observe sur ce diagramme.</p> <p>Une m\u00e9moire volatile est une m\u00e9moire qui perd son contenu lorsqu'elle n'est plus aliment\u00e9e en \u00e9lectricit\u00e9. La raison est simple. Stocker un \u00e9tat \u00e9lectrique demande de l'\u00e9nergie pour accumuler des charges \u00e9lectriques. Si l'on fait l'analogie que l'\u00e9lectricit\u00e9 est de l'eau, alors chaque bit de la m\u00e9moire est un verre d'eau que l'on peut remplir ou vider. Le seul moyen de lire le contenu du verre est de voir s'il y a de l'eau dedans, c'est-\u00e0-dire de le vider. Si le verre est grand, alors il faut plus de temps pour le remplir et plus de temps pour le vider ceci pr\u00e9sente plusieurs inconv\u00e9nients\u2009:</p> <ol> <li>La vitesse de lecture est plus lente.</li> <li>La quantit\u00e9 d'eau (courant) pour remplir le verre est plus grande.</li> <li>L'encombrement est plus grand puisque le verre est plus volumineux.</li> </ol> <p>Aussi, le choix technologique est d'avoir des tout petits verres. Ils sont si petits que l'eau contenue s'\u00e9vapore tr\u00e8s vite. Pour \u00e9viter cela, on doit constamment remplir les verres. C'est ce que l'on appelle la rafra\u00eechissement de la m\u00e9moire. P\u00e9riodiquement, environ toutes les 64 ms, on doit r\u00e9\u00e9crire le contenu de la m\u00e9moire pour \u00e9viter que l'information ne se perde. Heureusement pour nous, cette op\u00e9ration est transparente pour l'utilisateur, c'est le contr\u00f4leur de m\u00e9moire qui s'en charge.</p> <p>Les caract\u00e9ristiques de la m\u00e9moire sont les suivantes\u00a0:</p> Caract\u00e9ristique Valeur Unit\u00e9 Capacit\u00e9 32 Gib Tension d'alimentation 1.2 V Fr\u00e9quence 1600 MHz Temps de rafra\u00eechissement 64 ms Nombre de banques 16 Technologie DDR4"}, {"location": "course-c/20-architecture-and-systems/computer/#technologies", "title": "Technologies", "text": "<p>Il existe plusieurs technologies de m\u00e9moire vive. Les plus courantes sont\u00a0: SDRAM, DDR, DDR2, DDR3, DDR4. Contrairement \u00e0 la SDRAM qui est une m\u00e9moire synchrone, les m\u00e9moires DDR (Double Data Rate) sont des m\u00e9moires asynchrones. Cela signifie que la m\u00e9moire peut lire et \u00e9crire des donn\u00e9es sur le flanc montant et descendant du signal d'horloge ce qui double la bande passante de la m\u00e9moire. Chaque g\u00e9n\u00e9ration am\u00e9liore les performances en augmentant la fr\u00e9quence de fonctionnement, la densit\u00e9 des puces m\u00e9moires et en r\u00e9duisant la tension d'alimentation.</p>"}, {"location": "course-c/20-architecture-and-systems/computer/#vitesse-de-la-lumiere", "title": "Vitesse de la lumi\u00e8re", "text": "<p> Autoroute de l'information</p> <p>La vitesse de la lumi\u00e8re est de 299 792 458 m/s. Elle est fix\u00e9e par la convention du m\u00e8tre. C'est la vitesse maximale que peut atteindre un objet dans l'univers. Pour donner un ordre de grandeur, un signal \u00e9lectrique se propage dans un c\u00e2ble \u00e0 environ \u2154 de la vitesse de la lumi\u00e8re. Cela signifie que pour parcourir 1 m\u00e8tre, un signal \u00e9lectrique met environ 5 ns.</p> <p>Plus haut on a vu que le bus de donn\u00e9es de la m\u00e9moire est souvent de 64-bits. Cela correspond \u00e0 une autoroute de 64 voies avec quelques limitations\u2009:</p> <ul> <li>Les voies sont unidirectionnelles, c'est-\u00e0-dire que l'on ne peut circuler que dans un sens.</li> <li>Les voies sont s\u00e9par\u00e9es par des barri\u00e8res, c'est-\u00e0-dire que l'on ne peut pas changer de voie.</li> <li>Les v\u00e9hicules se d\u00e9placent tous \u00e0 la vitesse d'environ 540 millions de km/h. Ils ne peuvent pas freiner, acc\u00e9l\u00e9rer ou s'arr\u00eater.</li> </ul> <p>Pour transmettre une information, par exemple un nombre entier de 64 bits (<code>long long</code> en C), il faut faire entrer 64 v\u00e9hicules sur chacune des voies. Chaque v\u00e9hicule repr\u00e9sente un bit. Pour que l'information soit transmise, il faut que les 64 v\u00e9hicules soient align\u00e9s et qu'ils arrivent tous au m\u00eame moment.</p> <p>Sur la figure suivante, on voit le routage d'un circuit \u00e9lectronique. En rose, ce sont les composants physiques. \u00c0 gauche un processeur et au milieu en bas deux circuits m\u00e9moire lab\u00e9lis\u00e9s DDR1 et DDR2. En bleu clair ce sont les lignes \u00e9lectriques qui relient les composants. On observe des tas de petites circonvolutions. Les lignes sont artificiellement rallong\u00e9es pour que la longueur de chaque voie de l'autoroute soit la m\u00eame, afin de garantir une vitesse de propagation identique pour chaque ligne de donn\u00e9e.</p> <p> Routage d'une m\u00e9moire</p> <p>Vous me direz, oui, mais 540 millions de km/h c'est super rapide et sur ce circuit les lignes ne font pas plus de 10 cm ce qui repr\u00e9sente 600 ps pour parcourir la distance. Oui, mais voil\u00e0, on communique sur cette autoroute \u00e0 2000 MT/s (m\u00e9gatransferts par seconde). Cela signifie que 2'000'000 de v\u00e9hicules entrent sur chaque voie de l'autoroute chaque seconde circuler sur chaque voie de l'autoroute chaque seconde. N'est-ce pas incroyable\u00a0?</p> <p>Malgr\u00e9 ces performances, la m\u00e9moire reste un goulot d'\u00e9tranglement pour les processeurs. En effet, les processeurs sont de plus en plus rapides et les m\u00e9moires ne suivent pas le rythme. Un processeur qui calcule \u00e0 4 GHz peut ex\u00e9cuter 4 milliards d'instructions par seconde. Si chaque instruction n\u00e9cessite un acc\u00e8s m\u00e9moire et que cet acc\u00e8s prend 100 cycles d'horloge, alors le processeur ne pourra ex\u00e9cuter que 40 millions d'instructions par seconde. Cela signifie que le processeur ne sera utilis\u00e9 qu'\u00e0 1% de sa capacit\u00e9.</p>"}, {"location": "course-c/20-architecture-and-systems/computer/#le-disque-dur", "title": "Le disque dur", "text": "<p> Disque dur</p> <p>Le disque dur est un dispositif de stockage de masse. Il est compos\u00e9 de plusieurs plateaux magn\u00e9tiques qui tournent \u00e0 grande vitesse. Un bras m\u00e9canique se d\u00e9place sur les plateaux pour lire ou \u00e9crire les donn\u00e9es. Les disques durs sont lents par rapport \u00e0 la m\u00e9moire vive. Ils sont utilis\u00e9s pour stocker des donn\u00e9es de mani\u00e8re permanente.</p> <p>De nos jours ces disques sont remplac\u00e9s par des disques SSD (Solid State Drive) qui sont plus rapides et plus fiables. Les disques SSD sont compos\u00e9s de m\u00e9moire flash qui ne n\u00e9cessite pas de pi\u00e8ces mobiles. Contrairement \u00e0 la m\u00e9moire vive, les disques SSD sont des m\u00e9moires non volatiles. Cela signifie que les donn\u00e9es sont conserv\u00e9es m\u00eame lorsque l'alimentation est coup\u00e9e.</p> <p> SSD de 2 TiB</p> <p>Mais si les SSD peuvent stocker beaucoup plus de donn\u00e9es sur le m\u00eame espace, pourquoi sont-ils plus lents que la m\u00e9moire vive\u00a0? La raison est simple. Les disques SSD sont organis\u00e9s en blocs de donn\u00e9es, que l'on appelle pages et clusters. Pour lire ou \u00e9crire une donn\u00e9e, il faut lire ou \u00e9crire tout le bloc. Cela signifie que si l'on veut lire un octet, il faut lire 4'096 octets. C'est ce que l'on appelle le page size.</p> <p>La communication entre le processeur et le disque SSD ou HDD utilise un protocole de communication s\u00e9rie appel\u00e9 SATA (Serial ATA). Ce protocole permet de transf\u00e9rer des donn\u00e9es \u00e0 une vitesse de 6 Gbit/s. Cela signifie que pour transf\u00e9rer un octet, il faut 8 bits, soit 8 ns. Cela semble rapide, mais si l'on veut lire un bloc de 4'096 octets, il faut 32'768 bits, soit 32'768 x 8 ns = 262'144 ns, soit 262 \u00b5s. C'est 262'144 fois plus lent que la m\u00e9moire vive.</p> <p>Pour interfacer le processeur avec le disque dur, on utilise un contr\u00f4leur de disque. Ce contr\u00f4leur est un circuit \u00e9lectronique qui g\u00e8re les acc\u00e8s disque. Il est compos\u00e9 lui-m\u00eame d'un microprocesseur, de m\u00e9moire vive et de m\u00e9moire flash.</p>"}, {"location": "course-c/20-architecture-and-systems/computer/#la-carte-mere", "title": "La carte m\u00e8re", "text": "<p> Carte m\u00e8re</p> <p>La carte m\u00e8re est le composant principal de l'ordinateur. C'est elle qui relie tous les composants entre eux. Elle est compos\u00e9e d'un circuit imprim\u00e9 sur lequel sont soud\u00e9s les diff\u00e9rents composants et une grande quantit\u00e9 de connecteurs.</p> <p>Le c\u0153ur de la carte m\u00e8re est le chipset. C'est un ensemble de circuits \u00e9lectroniques qui g\u00e8re les communications entre les diff\u00e9rents composants. Il est compos\u00e9 de deux parties\u00a0:</p> <ul> <li>Le Northbridge qui g\u00e8re les communications entre le processeur, la m\u00e9moire vive et la carte graphique.</li> <li>Le Southbridge qui g\u00e8re les communications entre les p\u00e9riph\u00e9riques de stockage, les ports USB, les ports SATA, etc.</li> </ul> <p>Le chipset est reli\u00e9 au processeur par un bus de donn\u00e9es appel\u00e9 FSB (Front Side Bus). Ce bus transporte les donn\u00e9es entre le processeur et le chipset. La configuration du chipset est stock\u00e9e dans une m\u00e9moire flash appel\u00e9e BIOS (Basic Input/Output System). Le BIOS est un logiciel qui permet de configurer les param\u00e8tres de la carte m\u00e8re.</p> <p>\u00c0 l'\u00e9poque le BIOS offrait un acc\u00e8s tr\u00e8s minimaliste \u00e0 l'utilisateur. On pouvait le configurer avec un clavier et un \u00e9cran qui n'affichait que des caract\u00e8res.</p> <p>De nos jours, le BIOS a \u00e9t\u00e9 remplac\u00e9 par l'UEFI (Unified Extensible Firmware Interface). L'UEFI est un logiciel plus \u00e9volu\u00e9 qui permet de configurer la carte m\u00e8re avec une interface graphique. Il est possible de configurer la carte m\u00e8re avec une souris et un \u00e9cran tactile.</p>"}, {"location": "course-c/20-architecture-and-systems/files/", "title": "Fichiers", "text": ""}, {"location": "course-c/20-architecture-and-systems/files/#systeme-de-fichiers", "title": "Syst\u00e8me de fichiers", "text": "<p>Dans un environnement POSIX tout est fichier. <code>stdin</code> est un fichier, une souris USB est un fichier, un clavier est un fichier, un terminal est un fichier, un programme est un fichier.</p> <p>Les fichiers sont organis\u00e9s dans une arborescence g\u00e9r\u00e9e par un syst\u00e8me de fichiers. Sous Windows l'arborescence classique est\u2009:</p> <pre><code>C :\n\u251c\u2500\u2500 Program Files         Programmes install\u00e9s\n\u251c\u2500\u2500 Users                 Comptes utilisateur\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 John\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 Desktop\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 Documents\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 Music\n\u2514\u2500\u2500 Windows\n    \u251c\u2500\u2500 Fonts             Polices de caract\u00e8res\n    \u251c\u2500\u2500 System32          Syst\u00e8me d'exploitation 64-bits (oui, oui)\n    \u2514\u2500\u2500 Temp              Fichiers temporaires\n</code></pre> <p>Il y a une arborescence par disque physique <code>C:</code>, <code>D:</code>, une arborescence par chemin r\u00e9seau <code>\\\\eistore2</code>, etc. Sous POSIX, la strat\u00e9gie est diff\u00e9rente, car il n'existe qu'un seul syst\u00e8me de fichier dont la racine est <code>/</code>.</p> <pre><code>/\n\u251c\u2500\u2500 bin                   Programmes ex\u00e9cutables cruciaux\n\u251c\u2500\u2500 dev                   P\u00e9riph\u00e9riques (clavier, souris ...)\n\u251c\u2500\u2500 usr\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 bin               Programmes install\u00e9s\n\u251c\u2500\u2500 mnt                   Points de montage (disques r\u00e9seaux, CD, cl\u00e9 USB)\n\u2502   \u2514\u2500\u2500 eistore2\n\u251c\u2500\u2500 tmp                   Fichiers temporaires\n\u251c\u2500\u2500 home                  Comptes utilisateurs\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 john\n\u2502\u00a0\u00a0     \u2514\u2500\u2500 documents\n\u2514\u2500\u2500 var                   Fichiers variables comme les logs ou les database\n</code></pre> <p>Chaque \u00e9l\u00e9ment qui contient d'autres \u00e9l\u00e9ments est appel\u00e9 un r\u00e9pertoire ou dossier, en anglais directory. Chaque r\u00e9pertoire contient toujours au minimum deux fichiers sp\u00e9ciaux\u2009:</p> <code>.</code> <p>Un fichier qui symbolise le r\u00e9pertoire courant, celui dans lequel je me trouve</p> <code>..</code> <p>Un fichier qui symbolise le r\u00e9pertoire parent, c'est \u00e0 dire <code>home</code> lorsque je suis dans <code>john</code>.</p> <p>La localisation d'un fichier au sein d'un syst\u00e8me de fichier peut \u00eatre soit absolue soit relative. Cette localisation s'appelle un chemin ou path. La convention est d'utiliser le symbole\u2009:</p> <ul> <li>Slash <code>/</code> sous POSIX</li> <li>Antislash <code>\\</code> sous Windows</li> </ul> <p>Le chemin <code>/usr/bin/.././bin/../../home/john/documents</code> est correct, mais il n'est pas canonique, on dit qu'il n'est pas r\u00e9solu. La forme canonique est <code>/home/john/documents</code>.</p> <p>Un chemin peut \u00eatre relatif s'il ne commence pas par un <code>/</code>: <code>../bin</code>. Sous Windows du m\u00eame acabit, mais la racine diff\u00e9remment selon le type de m\u00e9dia <code>C:\\</code>, <code>\\\\network</code>...</p> <p>Lorsqu'un programme s'ex\u00e9cute, son contexte d'ex\u00e9cution est toujours par rapport \u00e0 son emplacement dans le syst\u00e8me de fichier, donc le chemin peut \u00eatre soit relatif, soit absolu.</p>"}, {"location": "course-c/20-architecture-and-systems/files/#navigation", "title": "Navigation", "text": "<p>Sous Windows (PowerShell) ou un syst\u00e8me POSIX (Bash/Sh/Zsh), la navigation dans une arborescence peut \u00eatre effectu\u00e9e en ligne de commande \u00e0 l'aide des commandes (programmes) suivants\u2009:</p> <code>ls</code> <p>est un raccourci du nom list, ce programme permet d'afficher sur la sortie standard le contenu d'un r\u00e9pertoire.</p> <code>cd</code> <p>pour change directory permets de naviguer dans l'arborescence. Le programme prend en argument un chemin absolu ou relatif. En cas d'absence d'arguments, le programme redirige vers le r\u00e9pertoire de l'utilisateur courant.</p>"}, {"location": "course-c/20-architecture-and-systems/files/#format-dun-fichier", "title": "Format d'un fichier", "text": "<p>Un fichier peut avoir un contenu arbitraire\u2009; une suite de z\u00e9ro et d\u2019un binaire. Selon l'interpr\u00e9tation, un fichier pourrait contenir une image, un texte ou un programme. Le cas particulier ou le contenu est lisible par un \u00e9diteur de texte, on appelle ce fichier un fichier texte. C'est-\u00e0-dire que chaque caract\u00e8re est encod\u00e9 sur 8-bit et que la table ASCII est utilis\u00e9e pour traduire le contenu en un texte intelligible. Lorsque le contenu n'est pas du texte, on l'appelle un fichier binaire.</p> <p>La fronti\u00e8re est parfois assez mince, car parfois le fichier binaire peut contenir du texte intelligible, la preuve avec ce programme\u2009:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(int* argc, char* argv[])\n{\n    static const char password[] = \"un mot de passe secret\";\n    return strcmp(argv[1], password);\n}\n</code></pre> <p>Si nous le compilons et cherchons dans son code binaire\u2009:</p> <pre><code>$ gcc example.c\n$ hexdump -C a.out | grep -C3 sec\n06f0  f3 c3 00 00 48 83 ec 08  48 83 c4 08 c3 00 00 00 | ....H...H....... |\n0700  01 00 02 00 00 00 00 00  00 00 00 00 00 00 00 00 | ................ |\n0710  75 6e 20 6d 6f 74 20 64  65 20 70 61 73 73 65 20 | un mot de passe  |\n0720  73 65 63 72 65 74 00 00  01 1b 03 3b 3c 00 00 00 | secret.....;&lt;... |\n0730  06 00 00 00 e8 fd ff ff  88 00 00 00 08 fe ff ff | ................ |\n0740  b0 00 00 00 18 fe ff ff  58 00 00 00 22 ff ff ff | ........X...\"... |\n0750  c8 00 00 00 58 ff ff ff  e8 00 00 00 c8 ff ff ff | ....X........... |\n</code></pre> <p>Sous un syst\u00e8me POSIX, il n'existe aucune distinction formelle entre un fichier binaire et un fichier texte. En revanche sous Windows, il existe une subtile diff\u00e9rence concernant surtout le caract\u00e8re de fin de ligne. La commande <code>copy a.txt + b.txt c.txt</code> consid\u00e8re des fichiers textes et ajoutera automatiquement une fin de ligne entre chaque partie concat\u00e9n\u00e9e, mais celle-ci <code>copy /b a.bin + b.bin c.bin</code> ne le fera pas.</p>"}, {"location": "course-c/20-architecture-and-systems/files/#ouverture-dun-fichier", "title": "Ouverture d'un fichier", "text": "<p>Sous POSIX, un programme doit demander au syst\u00e8me d'exploitation l'acc\u00e8s \u00e0 un fichier soit en lecture, soit en \u00e9criture soit les deux. Le syst\u00e8me d'exploitation retourne un descripteur de fichier qui est simplement un entier unique pour le programme.</p> <pre><code>#include &lt;fcntl.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;sys/stat.h&gt;\n\nint main(void)\n{\n    int fd = open(\"toto\", O_RDONLY);\n    printf(\"%d\\n\", fd);\n    getchar();\n}\n</code></pre> <p>Lorsque le programme ci-dessus est ex\u00e9cut\u00e9, il va demander l'ouverture du fichier <code>toto</code> en lecture et recevoir un descripteur de fichier <code>fd</code> (file descriptor) positif en cas de succ\u00e8s ou n\u00e9gatif en cas d'erreur.</p> <p>Dans l'exemple suivant, on compile, puis ex\u00e9cute en arri\u00e8re-plan le programme qui ne se terminera pas puisqu'il attend un caract\u00e8re d'entr\u00e9e. L'appel au programme <code>ps</code> permet de lister la liste des processus en cours et la recherche de <code>test</code> permet de noter le num\u00e9ro du processus, ici <code>6690</code>. Dans l'arborescence de fichiers, il est possible d'aller consulter les descripteurs de fichiers ouverts pour le processus concern\u00e9.</p> <pre><code>$ gcc test.c -o test &amp;&amp; ./test &amp;\n$ ps -u | grep test\nycr       6690  0.0  0.0  10540   556 pts/4    T    11:19   0:00 test\n$ ls /proc/6690/fd\n0  1  2  3\n</code></pre> <p>On observe que trois descripteurs de fichiers sont ouverts.</p> <ul> <li><code>0</code> pour <code>STDIN</code></li> <li><code>1</code> pour <code>STDOUT</code></li> <li><code>2</code> pour <code>STDERR</code></li> <li><code>3</code> pour le fichier <code>toto</code> ouvert en lecture seule</li> </ul> <p>La fonction <code>open</code> est en r\u00e9alit\u00e9 un appel syst\u00e8me qui n'est standardis\u00e9 que sous POSIX, c'est-\u00e0-dire que son utilisation n'est pas portable. L'exemple cit\u00e9 est principalement \u00e9voqu\u00e9 pour mieux comprendre le m\u00e9canisme de fond pour l'acc\u00e8s aux fichiers.</p> <p>En r\u00e9alit\u00e9 la biblioth\u00e8que standard, respectueuse de C99, dispose d'une fonction <code>fopen</code> pour file open qui offre plus de fonctionnalit\u00e9s. Ouvrir un fichier se r\u00e9sume donc \u00e0</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    FILE *fp = fopen(\"toto\", \"r\");\n\n    if (fp == NULL) {\n        return -1; // Error the file cannot be accessed\n    }\n\n    // ...\n}\n</code></pre> <p>Le mode d'ouverture du fichier peut \u00eatre\u2009:</p> <code>r</code> <p>Ouverture en lecture seule depuis le d\u00e9but du fichier.</p> <code>r+</code> <p>Ouverture pour lecture et \u00e9criture depuis le d\u00e9but du fichier.</p> <code>w</code> <p>Ouverture en \u00e9criture. Le fichier est cr\u00e9\u00e9 s'il n'existe pas d\u00e9j\u00e0, sinon le contenu est effac\u00e9. Le pointeur de fichier est positionn\u00e9 au d\u00e9but de ce dernier.</p> <code>w+</code> <p>Ouverture en \u00e9criture et lecture. Le fichier est cr\u00e9\u00e9 s'il n'existe pas d\u00e9j\u00e0. Le pointeur de fichier est positionn\u00e9 au d\u00e9but de ce dernier.</p> <code>a</code> <p>Ouverture du fichier pour insertion. Le fichier est cr\u00e9\u00e9 s'il n'existe pas d\u00e9j\u00e0. Le pointeur est positionn\u00e9 \u00e0 la fin du fichier.</p> <code>a+</code> <p>Ouverture du fichier pour lecture et \u00e9criture. Le fichier est cr\u00e9\u00e9 s'il n'existe pas d\u00e9j\u00e0 et le pointeur du fichier est positionn\u00e9 \u00e0 la fin.</p> <p>Sous Windows et pour soucis de compatibilit\u00e9, selon la norme C99, le flag <code>b</code> pour binary existe. Pour ouvrir un fichier en mode binaire, on peut alors \u00e9crire <code>rb+</code>.</p> <p>L'ouverture d'un fichier cause, selon le mode, un acc\u00e8s exclusif au fichier. C'est-\u00e0-dire que d'autres programmes ne pourront pas acc\u00e9der \u00e0 ce fichier. Il est donc essentiel de toujours refermer l'acc\u00e8s \u00e0 un fichier d\u00e8s lors que l'op\u00e9ration de lecture ou d'\u00e9criture est termin\u00e9e\u2009:</p> <pre><code>flose(fp);\n</code></pre> <p>On peut noter que sous POSIX, \u00e9crire sur <code>stdout</code> ou <code>stderr</code> est exactement la m\u00eame chose qu'\u00e9crire sur un fichier, il n'y a aucune distinction.</p> <p>Exercise\u2009: Num\u00e9ro de ligne</p> <p>\u00c9crire un programme qui saisit le nom d'un fichier texte, ainsi qu'un texte \u00e0 rechercher. Le programme affiche ensuite le num\u00e9ro de toutes les lignes du fichier contenant le texte recherch\u00e9.</p> <pre><code>$ ./search\nFichier: foo.txt\nRecherche: bulbe\n\n4\n5\n19\n132\n981\n</code></pre> <p>Question subsidiaire\u2009: que fait le programme suivant\u2009:</p> <pre><code>$ grep foo.txt bulbe\n</code></pre>"}, {"location": "course-c/20-architecture-and-systems/files/#navigation-dans-un-fichier", "title": "Navigation dans un fichier", "text": "<p>Lorsqu'un fichier est ouvert, un curseur virtuel est positionn\u00e9 soit au d\u00e9but soit \u00e0 la fin du fichier. Lorsque des donn\u00e9es sont lues ou \u00e9crites, c'est \u00e0 la position de ce curseur, lequel peut \u00eatre d\u00e9plac\u00e9 en utilisant plusieurs fonctions utilitaires.</p> <p>La navigation dans un fichier n'est possible que si le fichier est seekable. G\u00e9n\u00e9ralement les pointeurs de fichiers <code>stdin</code>, <code>stdout</code> et <code>stderr</code> ne sont pas seekable, et il n'est pas possible de se d\u00e9placer dans le fichier, mais seulement \u00e9crire dedans.</p>"}, {"location": "course-c/20-architecture-and-systems/files/#fseek", "title": "fseek", "text": "<p>La fonction <code>fseek</code> permet de d\u00e9placer le curseur dans un fichier ouvert. La signature de la fonction est la suivante\u2009:</p> <pre><code>int fseek(FILE *stream, long int offset, int whence)\n</code></pre> <p>Le manuel man fseek indique les trois constantes possibles pour <code>whence</code>:</p> <code>SEEK_SET</code> <p>Positionne le curseur au d\u00e9but du fichier.</p> <code>SEEK_CUR</code> <p>Position courante du curseur. Permets d'ajouter un offset relatif \u00e0 la position courante.</p> <code>SEEK_END</code> <p>Positionne le curseur \u00e0 la fin du fichier.</p> <p>Si un fichier est seekable, il est possible de se d\u00e9placer dans le fichier. Par exemple, pour lire le dernier caract\u00e8re d'un fichier\u2009:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    FILE *fp = fopen(\"toto\", \"r\");\n\n    if (fp == NULL) return -1;\n\n    fseek(fp, -1, SEEK_END);\n    char c = fgetc\n    printf(\"%c\\n\", c);\n}\n</code></pre>"}, {"location": "course-c/20-architecture-and-systems/files/#ftell", "title": "ftell", "text": "<p>Il est parfois utile de savoir o\u00f9 se trouve le curseur. <code>ftell()</code> retourne la position actuelle du curseur dans un fichier ouvert.</p> <pre><code>char filename[] = \"foo\";\n\nFILE *fp = fopen(filename, 'r');\nfseek(fp, 0, SEEK_END);\nlong int size = ftell();\n\nprintf(\"The file %s has a size of %ld Bytes\\n\", filename, size);\n</code></pre>"}, {"location": "course-c/20-architecture-and-systems/files/#rewind", "title": "rewind", "text": "<p>L'appel <code>rewind()</code> est \u00e9quivalent \u00e0 <code>(void) fseek(stream, 0L, SEEK_SET)</code> et permet de se positionner au d\u00e9but du fichier.</p>"}, {"location": "course-c/20-architecture-and-systems/files/#lecture-ecriture", "title": "Lecture / \u00c9criture", "text": "<p>La lecture, \u00e9criture dans un fichier s'effectue de mani\u00e8re analogue aux fonctions que nous avons d\u00e9j\u00e0 vues <code>printf</code> et <code>scanf</code> pour les flux standards (stdout, stderr), mais en utilisant les variantes pr\u00e9fix\u00e9es de <code>f</code> :</p> Fonction Description <code>int fscanf(FILE *stream, const char *format, ...)</code> Lecture formatt\u00e9e <code>int fprintf(FILE *stream, const char *format, ...)</code> \u00c9criture formatt\u00e9e <code>int fgetc(FILE *stream)</code> Lecture d'un caract\u00e8re <code>int fputc(FILE *stream, char char)</code> \u00c9criture d'un caract\u00e8re <code>char *fgets(char * restrict s, int n, FILE * restrict stream)</code> Lecture d'une ligne <code>int fputs(const char * restrict s, FILE * restrict stream)</code> \u00c9criture d'une ligne <p>L'utilisation avec <code>stdin</code> et <code>stdout</code> comme descripteur de fichier est possible, mais il est pr\u00e9f\u00e9rable dans ce cas d'utiliser les fonctions <code>scanf</code> et <code>printf</code> qui ont les m\u00eames fonctionnalit\u00e9s.</p> <p>Les nouvelles fonctions \u00e0 conna\u00eetre sont les suivantes\u2009:</p> <pre><code>size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream)\n</code></pre> <p>Elle permet une lecture arbitraire de <code>nmemb * size</code> bytes depuis le flux <code>stream</code> dans le buffer <code>ptr</code>:</p> <pre><code>int32_t buffer[12] = {0};\nfread(buffer, 2, sizeof(int32_t), stdin);\nprintf(\"%x\\n%x\\n\", buffer[0], buffer[1]);\n</code></pre> <p>Exemple d'utilisation\u2009:</p> <pre><code>$ echo -e \"0123abcdefgh\" | ./a.out\n33323130\n64636261\n</code></pre> <p>On notera au passage la nature little-endian du syst\u00e8me.</p> <p>La seconde fonction est\u2009:</p> <pre><code>size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream)\n</code></pre> <p>La fonction est similaire \u00e0 <code>fread</code> mais pour \u00e9crire sur un flux des donn\u00e9es brutes.</p>"}, {"location": "course-c/20-architecture-and-systems/files/#buffer-de-fichier", "title": "Buffer de fichier", "text": "<p>Pour am\u00e9liorer les performances, C99 pr\u00e9voit (\u00a77.19.3-3), un espace tampon pour les descripteurs de fichiers qui peuvent \u00eatre\u2009:</p> <ol> <li><code>unbuffered</code> (<code>_IONBF</code>) : Pas de buffer, les caract\u00e8res lus ou \u00e9crits sont achemin\u00e9s le plus vite possible de la source \u00e0 la destination.</li> <li><code>fully buffered</code> (<code>_IOFBF</code>) : Le buffer est rempli \u00e0 chaque lecture ou \u00e9criture, puis vid\u00e9.</li> <li><code>line buffered</code> (<code>_IO_LBF</code>) : Le buffer est rempli \u00e0 chaque retour \u00e0 la ligne.</li> </ol> <p>Il faut comprendre qu'\u00e0 chaque instant un programme souhaite \u00e9crire dans un fichier, il doit g\u00e9n\u00e9rer un appel syst\u00e8me et donc interrompre le noyau. Un programme qui \u00e9crirait caract\u00e8re par caract\u00e8re sur la sortie standard agirait de la m\u00eame mani\u00e8re qu'un employ\u00e9 des postes qui irait distribuer son courrier en ne prenant qu'une enveloppe \u00e0 la fois, de la centrale de distribution au destinataire.</p> <p>Par d\u00e9faut, un pointeur de fichier est fully buffered. C'est-\u00e0-dire que dans le cas du programme suivant devrait ex\u00e9cuter 10x l'appel syst\u00e8me <code>write</code>, une fois par caract\u00e8re.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(int argc, char* argv[])\n{\n    if (argc &gt; 1 &amp;&amp; strcmp(\"--no-buffering\", argv[1]) == 0)\n        setvbuf(stdout, NULL, _IONBF, 0);\n\n    for (int i = 0; i &lt; 10; i++)\n        putchar('c');\n}\n</code></pre> <p>Cependant le comportement r\u00e9el est diff\u00e9rent. Seulement si le buffer est d\u00e9sactiv\u00e9, que le programme interrompt le noyau pour chaque caract\u00e8re\u2009:</p> <pre><code>$ gcc buftest.c -o buftest\n\n$ strace ./buftest 2&gt;&amp;1 | grep write\nwrite(1, \"cccccccccc\", 10cccccccccc)              = 10\n\n$ strace ./buftest --no-buffering 2&gt;&amp;1 | grep write\nwrite(1, \"c\", 1c)                        = 1\nwrite(1, \"c\", 1c)                        = 1\nwrite(1, \"c\", 1c)                        = 1\nwrite(1, \"c\", 1c)                        = 1\nwrite(1, \"c\", 1c)                        = 1\nwrite(1, \"c\", 1c)                        = 1\nwrite(1, \"c\", 1c)                        = 1\nwrite(1, \"c\", 1c)                        = 1\nwrite(1, \"c\", 1c)                        = 1\nwrite(1, \"c\", 1c)                        = 1\n</code></pre> <p>Le changement de mode peut \u00eatre effectu\u00e9 avec la fonction <code>setbuf</code> ou <code>setvbuf</code>:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char buf[1024];\n\n    setbuf(stdout, buf);\n\n    fputs(\"Allo ?\");\n\n    fflush(stdout);\n}\n</code></pre> <p>La fonction <code>fflush</code> force l'\u00e9criture malgr\u00e9 l'utilisation d'un buffer.</p>"}, {"location": "course-c/20-architecture-and-systems/files/#fichiers-et-flux", "title": "Fichiers et Flux", "text": "<p>Historiquement les descripteurs de fichiers sont appel\u00e9s <code>FILE</code> alors qu'ils sont pr\u00e9f\u00e9rablement appel\u00e9s <code>streams</code> en C++. Un fichier au m\u00eame titre que <code>stdin</code>, <code>stdout</code> et <code>stderr</code> sont des flux de donn\u00e9es. La norme POSIX, d\u00e9crit que par d\u00e9faut les flux\u2009:</p>  Flux de donn\u00e9es standards Flux Num\u00e9ro Description <code>stdin</code> 0 Flux d'entr\u00e9e standard <code>stdout</code> 1 Flux de sortie standard <code>stderr</code> 2 Flux d'erreur standard <p>Ces trois descripteurs de fichiers sont ouverts au d\u00e9but du programme. Le premier fichier ouvert par exemple avec <code>fopen</code> sera tr\u00e8s probablement assign\u00e9 \u00e0 l'identifiant <code>3</code>, le suivant \u00e0 <code>4</code>, etc.</p> <p>Pour se convaincre de cela, on peut ex\u00e9cuter l'exemple suivant avec le programme <code>strace</code>:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char c = fgetc(stdin);\n\n    FILE *fd = fopen(\"file\", \"w\");\n    fputc(c, fd);\n    fputc(c + 1, stdout);\n    fputc(c + 2, stderr);\n}\n</code></pre> <p>Pour m\u00e9moire, <code>strace</code> permet de capturer les appels syst\u00e8me du programme pass\u00e9 en argument et de les afficher. Deux particularit\u00e9s de la commande ex\u00e9cut\u00e9e sont <code>2&gt;&amp;1</code> qui redirige <code>stderr</code> vers <code>stdout</code> afin de pouvoir rediriger le flux vers <code>grep</code>. Ensuite <code>grep</code> permet de filtrer la sortie pour n'afficher que les lignes contenant <code>open</code>, <code>read</code>, <code>write</code> ou <code>close</code>:</p> <pre><code>$ echo k | strace ./a.out 2&gt;&amp;1 | grep -P 'open|read|write|close'\nread(0, \"k\\n\", 4096)                    = 2\nopenat(AT_FDCWD, \"file\", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3\nwrite(2, \"m\", 1m)                        = 1\nwrite(3, \"k\", 1)                        = 1\nwrite(1, \"l\", 1l)                        = 1\n</code></pre> <p>On peut voir qu\u2019on lit <code>k\\n</code> sur le flux <code>0</code>, soit <code>stdin</code>, puis que le fichier <code>file</code> est ouvert, il porte l'identifiant <code>3</code>, enfin on \u00e9crit sur <code>1</code>, <code>2</code> et <code>3</code>.</p>"}, {"location": "course-c/20-architecture-and-systems/files/#formats-de-serialisation", "title": "Formats de s\u00e9rialisation", "text": "<p>Souvent les fichiers sont utilis\u00e9s pour stocker de l'information organis\u00e9e en grille, par exemple, la liste des temp\u00e9ratures maximales par ville et par mois\u2009:</p> Pays Ville 01 02 03 04 05 06 07 08 09 10 11 12 Suisse Z\u00fcrich 0.3 1.3 5.3 8.8 13.3 16.4 18.6 18.0 14.1 9.9 4.4 1.4 Italie Rome 7.5 8.2 10.2 12.6 17.2 21.1 24.1 24.5 20.8 16.4 11.4 8.4 Allemagne Berlin 0.6 2.3 5.1 10.2 14.8 17.9 20.3 19.7 15.3 10.5 6.0 1.33 Y\u00e9men Aden 25.7 26.0 27.2 28.9 31.0 32.7 32.7 31.5 31.6 28.9 27.1 26.01 Russie Yakutsk -38.6 -33.8 -20.1 -4.8 7.5 16.4 19.5 15.2 6.1 -7.8 -27.0 -37.6 <p>Il existe plusieurs mani\u00e8res d'\u00e9crire ces informations dans un fichier\u2009:</p> <ul> <li>\u00c9criture tabul\u00e9e</li> <li>\u00c9criture avec remplissage</li> <li>Utiliser un langage de s\u00e9rialisation de haut niveau comme JSON, YAML ou XML</li> </ul>"}, {"location": "course-c/20-architecture-and-systems/files/#format-tabule", "title": "Format tabul\u00e9", "text": "<p>Un fichier dit tabul\u00e9, utilise une sentinelle, souvent le caract\u00e8re de tabulation <code>\\t</code> pour s\u00e9parer les donn\u00e9es. Chaque ligne du tableau est physiquement s\u00e9par\u00e9e de la suivante avec un <code>\\n</code>:</p> <pre><code>Pays\\tVille\\t01\\t02\\t03\\t04\\t05\\t06\\t07\\t08\\t09\\t10\\t11\\t12\\n\nSuisse\\tZ\u00fcrich\\t0.3\\t1.3\\t5.3\\t8.8\\t13.3\\t16.4\\t18.6\\t18.0\\t14.1\\t9.9\\t4.4\\t1.4\\n\nItalie\\tRome\\t7.5\\t8.2\\t10.2\\t12.6\\t17.2\\t21.1\\t24.1\\t24.5\\t20.8\\t16.4\\t11.4\\t8.4\\n\nAllemagne\\tBerlin\\t0.6\\t2.3\\t5.1\\t10.2\\t14.8\\t17.9\\t20.3\\t19.7\\t15.3\\t10.5\\t6.0\\t1.33\\n\nY\u00e9men\\tAden\\t25.7\\t26.0\\t27.2\\t28.9\\t31.0\\t32.7\\t32.7\\t31.5\\t31.6\\t28.9\\t27.1\\t26.01\\n\nRussie\\tYakutsk\\t-38.6\\t-33.8\\t-20.1\\t-4.8\\t7.5\\t16.4\\t19.5\\t15.2\\t6.1\\t-7.8\\t-27.0\\t-37.6\\n\n</code></pre> <p>Ce fichier peut \u00eatre observ\u00e9 avec un lecteur hexad\u00e9cimal\u2009:</p> <pre><code>$ hexdump -C data.dat\n00000000  50 61 79 73 09 56 69 6c  6c 65 09 30 31 09 30 32  |Pays.Ville.01.02|\n00000010  09 30 33 09 30 34 09 30  35 09 30 36 09 30 37 09  |.03.04.05.06.07.|\n00000020  30 38 09 30 39 09 31 30  09 31 31 09 31 32 0a 53  |08.09.10.11.12.S|\n00000030  75 69 73 73 65 09 5a c3  bc 72 69 63 68 09 30 2e  |uisse.Z..rich.0.|\n00000040  33 09 31 2e 33 09 35 2e  33 09 38 2e 38 09 31 33  |3.1.3.5.3.8.8.13|\n00000050  2e 33 09 31 36 2e 34 09  31 38 2e 36 09 31 38 2e  |.3.16.4.18.6.18.|\n00000060  30 09 31 34 2e 31 09 39  2e 39 09 34 2e 34 09 31  |0.14.1.9.9.4.4.1|\n00000070  2e 34 0a 49 74 61 6c 69  65 09 52 6f 6d 65 09 37  |.4.Italie.Rome.7|\n00000080  2e 35 09 38 2e 32 09 31  30 2e 32 09 31 32 2e 36  |.5.8.2.10.2.12.6|\n00000090  09 31 37 2e 32 09 32 31  2e 31 09 32 34 2e 31 09  |.17.2.21.1.24.1.|\n000000a0  32 34 2e 35 09 32 30 2e  38 09 31 36 2e 34 09 31  |24.5.20.8.16.4.1|\n000000b0  31 2e 34 09 38 2e 34 0a  41 6c 6c 65 6d 61 67 6e  |1.4.8.4.Allemagn|\n000000c0  65 09 42 65 72 6c 69 6e  09 30 2e 36 09 32 2e 33  |e.Berlin.0.6.2.3|\n000000d0  09 35 2e 31 09 31 30 2e  32 09 31 34 2e 38 09 31  |.5.1.10.2.14.8.1|\n000000e0  37 2e 39 09 32 30 2e 33  09 31 39 2e 37 09 31 35  |7.9.20.3.19.7.15|\n000000f0  2e 33 09 31 30 2e 35 09  36 2e 30 09 31 2e 33 33  |.3.10.5.6.0.1.33|\n00000100  0a 59 c3 a9 6d 65 6e 09  41 64 65 6e 09 32 35 2e  |.Y..men.Aden.25.|\n00000110  37 09 32 36 2e 30 09 32  37 2e 32 09 32 38 2e 39  |7.26.0.27.2.28.9|\n00000120  09 33 31 2e 30 09 33 32  2e 37 09 33 32 2e 37 09  |.31.0.32.7.32.7.|\n00000130  33 31 2e 35 09 33 31 2e  36 09 32 38 2e 39 09 32  |31.5.31.6.28.9.2|\n00000140  37 2e 31 09 32 36 2e 30  31 0a 52 75 73 73 69 65  |7.1.26.01.Russie|\n00000150  09 59 61 6b 75 74 73 6b  09 2d 33 38 2e 36 09 2d  |.Yakutsk.-38.6.-|\n00000160  33 33 2e 38 09 2d 32 30  2e 31 09 2d 34 2e 38 09  |33.8.-20.1.-4.8.|\n00000170  37 2e 35 09 31 36 2e 34  09 31 39 2e 35 09 31 35  |7.5.16.4.19.5.15|\n00000180  2e 32 09 36 2e 31 09 2d  37 2e 38 09 2d 32 37 2e  |.2.6.1.-7.8.-27.|\n00000190  30 09 2d 33 37 2e 36 0a                           |0.-37.6.|\n00000198\n</code></pre> <p>L'inconv\u00e9nient de ce format est que pour obtenir directement la temp\u00e9rature du mois de mars \u00e0 Berlin, sachant que Berlin est la quatri\u00e8me ligne du fichier, il est n\u00e9cessaire de parcourir le fichier depuis le d\u00e9but, car la longueur des lignes n'est \u00e0 priori pas connue. On dit que la lecture s\u00e9quentielle est facilit\u00e9e, mais la lecture al\u00e9atoire est plus lente.</p>"}, {"location": "course-c/20-architecture-and-systems/files/#format-avec-remplissage", "title": "Format avec remplissage", "text": "<p>Pour pallier au d\u00e9faut du format tabul\u00e9, il est possible d'\u00e9crire le fichier en utilisant un caract\u00e8re de remplissage. Dans le fichier suivant, les mois de mai sont toujours align\u00e9s avec la 48e colonne\u2009:</p> <pre><code> 0000000000111111111122222222223333333333444444444455555555556666666666777777777788\n 0123456789012345678901234567890123456789012345678901234567890123456789012345678901\n+---------+-------+-----+-----+-----+----+----+----+----+----+----+----+-----+----&gt;\n\nPays      Ville   01    02    03    04   05   06   07   08   09   10   11    12\nSuisse    Z\u00fcrich  0.3   1.3   5.3   8.8  13.3 16.4 18.6 18.0 14.1 9.9  4.4   1.4\nItalie    Rome    7.5   8.2   10.2  12.6 17.2 21.1 24.1 24.5 20.8 16.4 11.4  8.4\nAllemagne Berlin  0.6   2.3   5.1   10.2 14.8 17.9 20.3 19.7 15.3 10.5 6.0   1.33\nY\u00e9men     Aden    25.7  26.0  27.2  28.9 31.0 32.7 32.7 31.5 31.6 28.9 27.1  26.01\nRussie    Yakutsk -38.6 -33.8 -20.1 -4.8 7.5  16.4 19.5 15.2 6.1  -7.8 -27.0 -37.6\n</code></pre> <p>Id\u00e9alement on utilise comme caract\u00e8re de remplissage le caract\u00e8re nul <code>\\0</code>, mais le caract\u00e8re espace peut aussi convenir \u00e0 condition que les donn\u00e9es ne contiennent pas d'espace.</p> <p>La lecture al\u00e9atoire de ce type de fichier est facilit\u00e9e, car la position de chaque entr\u00e9e est connue \u00e0 l'avance, on sait par exemple que le pays est stock\u00e9 sur 11 caract\u00e8res, la ville sur 9 caract\u00e8res et chaque temp\u00e9rature sur 7 caract\u00e8res.</p> <p>L'utilisation de <code>fseek</code> est par cons\u00e9quent utile\u2009:</p> <pre><code>int line = 2;\nint month = 3;\ndouble temperature;\n\nfseek(fd, line * (11 + 9 + 12 * 7 + 1), SEEK_SET);\nfseek(fd, 11 + 9 + month * 7 SEEK_CUR);\nfscanf(fd, \"%lf\", &amp;temperature);\n</code></pre> <p>L'inconv\u00e9nient de ce format de fichier est la place qu'il prend en m\u00e9moire. L'autre probl\u00e8me est que si le nom d'une ville d\u00e9passe les 9 caract\u00e8res allou\u00e9s, il faut r\u00e9\u00e9crire tout le fichier. G\u00e9n\u00e9ralement ce probl\u00e8me est contourn\u00e9 en allouant des champs d'une taille suffisante, par exemple 256 caract\u00e8res pour le nom des villes.</p>"}, {"location": "course-c/20-architecture-and-systems/files/#format-serialise", "title": "Format s\u00e9rialis\u00e9", "text": "<p>Des langages de s\u00e9rialisation permettent de structurer de l'information en utilisant un format sp\u00e9cifique. Ici JSON :</p> <pre><code>[\n    {\n        \"pays\": \"Suisse\",\n        \"ville\": \"Z\u00fcrich\",\n        \"mois\": {\n            \"janvier\": 0.3,\n            \"f\u00e9vrier\": 1.3,\n            \"mars\": 5.3,\n            \"avril\": 8.8,\n            \"mai\": 13.3,\n            \"juin\": 16.4,\n            \"juillet\": 18.6,\n            \"ao\u00fbt\": 18.0,\n            \"septembre\": 14.1,\n            \"octobre\": 9.9,\n            \"novembre\": 4.4,\n            \"d\u00e9cembre\": 1.4\n        }\n    },\n    {\n        \"pays\": \"Italie\",\n        \"ville\": \"Rome\",\n        \"mois\": {\n            \"janvier\": 7.5,\n            \"f\u00e9vrier\": 8.2,\n            \"mars\": 10.2,\n            \"avril\": 12.6,\n            \"mai\": 17.2,\n            \"juin\": 21.1,\n            \"juillet\": 24.1,\n            \"ao\u00fbt\": 24.5,\n            \"septembre\": 20.8,\n            \"octobre\": 16.4,\n            \"novembre\": 11.4,\n            \"d\u00e9cembre\": 8.4\n        }\n    }\n]\n</code></pre> <p>L'avantage de ce type de format est qu'il est facilement modifiable avec un \u00e9diteur de texte et qu'il est tr\u00e8s interop\u00e9rable. C'est-\u00e0-dire qu'il est facilement lisible depuis diff\u00e9rents langages de programmation.</p> <p>En C, on pourra utiliser la biblioth\u00e8que logicielle json-c.</p>"}, {"location": "course-c/20-architecture-and-systems/files/#exercices-de-revision", "title": "Exercices de r\u00e9vision", "text": "<p>Exercise\u2009: Variantes</p> <p>Consid\u00e9rez les deux programmes ci-dessous tr\u00e8s similaires.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    char texte[80];\n\n    printf(\"Saisir un texte:\");\n    gets(texte);\n    printf(\"Texte: %s\\n\", texte);\n}\n</code></pre> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    char texte[80];\n\n    printf(\"Saisir un texte:\");\n    fgets(texte, 80, stdin);\n    printf(\"Texte: %s\\n\", texte);\n}\n</code></pre> <ol> <li>Quelle est la diff\u00e9rence  entre ces 2 programmes\u2009?</li> <li>Dans quel cas est-ce que ces programmes auront un comportement diff\u00e9rent\u2009?</li> <li>Quelle serait la meilleure solution\u2009?</li> </ol>"}, {"location": "course-c/20-architecture-and-systems/mcu/", "title": "Syst\u00e8mes \u00e0 microcontr\u00f4leurs", "text": ""}, {"location": "course-c/20-architecture-and-systems/mcu/#introduction", "title": "Introduction", "text": ""}, {"location": "course-c/20-architecture-and-systems/mcu/#les-microcontroleurs", "title": "Les microcontr\u00f4leurs", "text": "<p>Un microcontr\u00f4leur est un ordinateur sur une puce. Il est compos\u00e9 d'un processeur, de m\u00e9moire et de p\u00e9riph\u00e9riques d'entr\u00e9e/sortie. Les microcontr\u00f4leurs sont utilis\u00e9s dans de nombreux syst\u00e8mes embarqu\u00e9s, tels que les t\u00e9l\u00e9commandes, les jouets, les appareils \u00e9lectrom\u00e9nagers, les instruments de mesure, les syst\u00e8mes de contr\u00f4le de moteurs etc. Nous avons d\u00e9j\u00e0 \u00e9voqu\u00e9 la machine \u00e0 caf\u00e9 en d\u00e9but de cours qui est un bon exemple de syst\u00e8me embarqu\u00e9.</p>"}, {"location": "course-c/20-architecture-and-systems/mcu/#style-de-programmation", "title": "Style de programmation", "text": "<p>D'ordinaire les petits microcontr\u00f4leurs sont programm\u00e9s en langage C, n\u00e9anmoins certaines possibilit\u00e9s du langage sont g\u00e9n\u00e9ralement prohib\u00e9es. Par exemple, les pointeurs de fonction sont rarement utilis\u00e9s, les fonctions r\u00e9cursives sont \u00e0 proscrire, les allocations dynamiques de m\u00e9moire sont interdites, etc. Les microcontr\u00f4leurs ont des ressources limit\u00e9es et le programmeur doit en tenir compte.</p> <p>L'allocation dynamique est interdite car elle peut entra\u00eener des fuites de m\u00e9moire ou de la fragmentation.</p> <p>L'ex\u00e9cution du programme est tr\u00e8s souvent dite bare-metal, c'est-\u00e0-dire sans syst\u00e8me d'exploitation. Le programme est ex\u00e9cut\u00e9 directement sur le microcontr\u00f4leur sans aucune couche interm\u00e9diaire. Cela permet d'avoir un contr\u00f4le total sur le mat\u00e9riel. Mais cela rend le programme non pr\u00e9emptif, c'est-\u00e0-dire qu'il n'y a pas de gestionnaire de t\u00e2ches qui peut interrompre le programme en cours d'ex\u00e9cution.</p> <p>Prenons l'exemple d'une montre \u00e0 aiguille \u00e9quip\u00e9e d'un microcontr\u00f4leur \u00e0 ultra basse consommation comme le Epson S1C17. Il ne serait pas raisonnable d'utiliser des boucles d'attentes actives (c'est-\u00e0-dire de compter un cerain nombre d'instructions correspondant \u00e0 une seconde), au lieu de cela, il est pr\u00e9f\u00e9rable d'utiliser un timer pour r\u00e9veiller le microcontr\u00f4leur toutes les secondes. Ce timer est un p\u00e9riph\u00e9rique mat\u00e9riel qui g\u00e9n\u00e8re une interruption toutes les secondes. L'interruption, via une table des vecteurs d'interruption, appelle une fonction qui met \u00e0 jour l'affichage de la montre. Aussi, c'est principalement dans cette fonction qu'aura lieu la majorit\u00e9 du programme, et il n'est pas rare d'avoir un programme de cette forme\u2009:</p> <pre><code>void timer_isr() {\n    update_display();\n    sleep(); // Suspend l'ex\u00e9cution du programme jusqu'\u00e0 une interruption\n}\n\nint main() {\n    init_device();\n    init_timer(timer_isr);\n    enable_low_power_mode();\n    for(;;) {} // Boucle infinie\n}\n</code></pre>"}, {"location": "course-c/20-architecture-and-systems/mcu/#interruptions", "title": "Interruptions", "text": ""}, {"location": "course-c/20-architecture-and-systems/mcu/#ports", "title": "Ports", "text": ""}, {"location": "course-c/20-architecture-and-systems/mcu/#timers", "title": "Timers", "text": ""}, {"location": "course-c/20-architecture-and-systems/memory-management/", "title": "Gestion de la m\u00e9moire", "text": "<p>Vous l'aurez appris \u00e0 vos d\u00e9pens, l'erreur Segmentation fault (erreur de segmentation) arrive souvent lors du d\u00e9veloppement. Ce chapitre s'int\u00e9resse \u00e0 la m\u00e9moire et vulgarise les concepts de segmentation et traite de l'allocation dynamique.</p> <p>La m\u00e9moire d'un programme est d\u00e9coup\u00e9e en segments de donn\u00e9es. Les principaux segments sont\u2009:</p> <code>.text</code> <p>Segment de code\u2009: les instructions du programme ex\u00e9cutable sont charg\u00e9es dans ce segment.</p> <code>.rodata</code> <p>Segment de constantes et cha\u00eenes de caract\u00e8res\u2009: les constantes globales <code>const int = 13</code> et les cha\u00eenes de caract\u00e8res sont enregistr\u00e9es dans ce segment.</p> <code>.bss</code> <p>Segment de variables initialis\u00e9es\u2009: ce segment est garanti d'\u00eatre initialis\u00e9 \u00e0 z\u00e9ro lorsque le programme est charg\u00e9 en m\u00e9moire. Les variables globales statiques tels que <code>static int foo = 0</code> seront stock\u00e9es dans ce segment.</p> <code>.data</code> <p>Segment de variables non initialis\u00e9es\u2009: les variables globales non initialis\u00e9es comme <code>static int bar;</code> seront plac\u00e9es dans ce segment.</p> <code>.heap</code> <p>Segment de tas\u2009: les allocations dynamiques d\u00e9crites plus bas dans ce chapitre sont d\u00e9clar\u00e9es ici.</p> <code>.stack</code> <p>Segment de pile\u2009: la cha\u00eene d'appel de fonction ainsi que toutes les variables locales sont m\u00e9moris\u00e9es dans ce segment.</p>"}, {"location": "course-c/20-architecture-and-systems/memory-management/#allocation-statique", "title": "Allocation statique", "text": "<p>Jusqu'ici toutes les variables que nous avons d\u00e9clar\u00e9es ont \u00e9t\u00e9 d\u00e9clar\u00e9es statiquement. C'est-\u00e0-dire que le compilateur est capable a priori de savoir combien de place prend telle ou telle variable et les agencer en m\u00e9moire dans les bons segments. On appelle cette m\u00e9thode d'allocation de m\u00e9moire l'allocation statique.</p> <p>La d\u00e9claration statique suivante d\u00e9clare un tableau de 1024 entiers 64-bits initialis\u00e9s \u00e0 z\u00e9ro et stock\u00e9s dans le segment <code>.bss</code>, soit 64 kio\u2009:</p> <pre><code>static int64_t vector[1024] = {0};\n</code></pre>"}, {"location": "course-c/20-architecture-and-systems/memory-management/#allocation-dynamique", "title": "Allocation dynamique", "text": "<p>Il est des circonstances ou un programme ne sait pas combien de m\u00e9moire il a besoin. Par exemple un programme qui compterait le nombre d'occurrences de chaque mot dans un texte devra se construire un index de tous les mots qu'il d\u00e9couvre lors de la lecture du fichier d'entr\u00e9e. A priori, ce fichier d'entr\u00e9e \u00e9tant inconnu au moment de l'ex\u00e9cution du programme, l'espace m\u00e9moire n\u00e9cessaire \u00e0 construire ce dictionnaire de mots est \u00e9galement inconnu.</p> <p>L'approche la plus na\u00efve serait d'anticiper le cas le plus d\u00e9favorable. Le dictionnaire Littr\u00e9 comporte environ 132'000 mots tandis que le Petit Larousse Illustr\u00e9 80'000 mots environ. Pour se donner une bonne marge de man\u0153uvre et anticiper les anglicismes et les noms propres. Il suffirait de r\u00e9server un tableau de 1 million de mots de 10 caract\u00e8res soit un peu plus de 100 MiB de m\u00e9moire quand bien m\u00eame le fichier qui serait lu ne comporterait que 2 mots\u2009: <code>Hello World!</code>.</p> <p>L'approche correcte est d'allouer la m\u00e9moire au moment o\u00f9 on en a besoin, c'est ce que l'on appelle l'allocation dynamique.</p> <p>Lorsqu'un programme a besoin de m\u00e9moire, il peut g\u00e9n\u00e9rer un appel syst\u00e8me pour demander au syst\u00e8me d'exploitation le besoin de disposer de plus de m\u00e9moire. En pratique on utilise deux fonctions de la biblioth\u00e8que standard <code>&lt;stdlib.h&gt;</code>:</p> <code>void *malloc(size_t size)</code> <p>Alloue dynamiquement un espace m\u00e9moire de <code>size</code> bytes. Le terme malloc d\u00e9coule de Memory ALLOCation.</p> <code>void *calloc(size_t nitems, size_t size)</code> <p>Fonctionne de fa\u00e7on similaire \u00e0 <code>malloc</code> mais initialise l'espace allou\u00e9 \u00e0 z\u00e9ro.</p> <code>void free(void *ptr)</code> <p>Lib\u00e8re un espace pr\u00e9alablement allou\u00e9 par <code>malloc</code> ou <code>calloc</code></p> <p>L'allocation se fait sur le <code>tas</code> (heap) qui est de taille variable. \u00c0 chaque fois qu'un espace m\u00e9moire est demand\u00e9, <code>malloc</code> recherche dans le segment un espace vide de taille suffisante, s'il ne parvient pas, il ex\u00e9cute l'appel syst\u00e8me sbrk qui permet de d\u00e9placer la fronti\u00e8re du segment m\u00e9moire et donc d'agrandir le segment.</p> <p> Allocation et lib\u00e9ration m\u00e9moire</p>"}, {"location": "course-c/20-architecture-and-systems/memory-management/#memoire-de-programme", "title": "M\u00e9moire de programme", "text": "<p>Les segments m\u00e9moires sont une construction de la biblioth\u00e8que standard, selon la biblioth\u00e8que utilis\u00e9e et \u00e0 fortiori le syst\u00e8me d'exploitation utilis\u00e9, l'agencement m\u00e9moire peut varier.</p> <p>N\u00e9anmoins une bonne repr\u00e9sentation est la suivante\u2009:</p> <p> Organisation de m\u00e9moire d'un programme</p> <p>On observe que le tas et la pile vont \u00e0 leur rencontre, et que lorsqu'ils se percutent c'est le crash avec l'erreur bien connue stack overflow.</p>"}, {"location": "course-c/20-architecture-and-systems/memory-management/#la-pile", "title": "La pile", "text": "<p>Lorsqu'un programme s'ex\u00e9cute, l'ordre dont les fonctions s'ex\u00e9cutent n'est pas connu \u00e0 priori. L'ordre d'ex\u00e9cution des fonctions dans l'exemple suivant est inconnu par le programme et donc les \u00e9ventuelles variables locales utilis\u00e9es par ces fonctions doivent dynamiquement \u00eatre allou\u00e9es.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ndouble square(double num) {\n    return num * num\n}\n\ndouble cube(double num) {\n    return num * num * num;\n}\n\nint main(void) {\n    double num = 10;\n\n    for (size_t i = 0; i &lt; 10; i++) {\n        if (rand() % 2) {\n            num = square(num);\n        } else {\n            num = cube(num);\n        }\n    }\n\n    printf(\"%f\\n\", num);\n}\n</code></pre> <p>Lors d'un appel de fonction, le compilateur ajoute avant la premi\u00e8re instruction du code cach\u00e9 permettant d'empiler sur un espace m\u00e9moire d\u00e9di\u00e9 (stack) les variables locales dont il a besoin ainsi que certaines informations telles que l'adresse m\u00e9moire de retour.</p>"}, {"location": "course-c/20-architecture-and-systems/memory-management/#allocation-dynamique-sur-le-tas", "title": "Allocation dynamique sur le tas", "text": "<p>L'allocation dynamique permet de r\u00e9server - lors de l'ex\u00e9cution - une zone m\u00e9moire dont on vient de calculer la taille. On utilisera la fonction malloc (memory allocation) pour r\u00e9server de la m\u00e9moire. Cette fonction n'initialise pas la zone r\u00e9serv\u00e9e.</p> <pre><code>typedef unsigned int size_t;\nvoid* malloc(size_t size);\n</code></pre> <p>Il est n\u00e9cessaire d'inclure le fichier stdlib.h pour utiliser les fonctions d'allocation m\u00e9moire. Par exemple, pour r\u00e9server un tableau de n valeurs de type double :</p> <pre><code>int n;\ndouble * zone_acquisition; // pointeur sur la zone \u00e0 r\u00e9server\n\nn = 100;\n\nzone_acquisition = (double*)malloc(n * sizeof(double));\n</code></pre>"}, {"location": "course-c/20-architecture-and-systems/memory-management/#allocation-dynamique-sur-le-tas-avec-mise-a-zero", "title": "Allocation dynamique sur le tas avec mise \u00e0 z\u00e9ro", "text": "<p>On utilisera la fonction calloc (memory allocation) pour r\u00e9server de la m\u00e9moire avec initialisation automatique de la zone r\u00e9serv\u00e9e.</p> <pre><code>void * calloc (size_t count, size_t size);\n</code></pre> <p>Cette fonction r\u00e9serve count x size octets en m\u00e9moire et l'initialise \u00e0 z\u00e9ro.</p>"}, {"location": "course-c/20-architecture-and-systems/memory-management/#modification-de-la-taille-dune-zone-deja-allouee-sur-le-tas", "title": "Modification de la taille d'une zone d\u00e9j\u00e0 allou\u00e9e sur le tas", "text": "<p>Si l'on veut agrandir une zone d\u00e9j\u00e0 allou\u00e9e avec malloc ou calloc, on utilisera la fonction suivante\u2009:</p> <pre><code>void * realloc (void * ptr, size_t size);\n</code></pre> <p>Elle permet de\u2009:</p> <ul> <li>r\u00e9allouer un bloc de m\u00e9moire avec une nouvelle taille</li> <li>si ptr est NULL, cr\u00e9er un nouveau bloc</li> <li>si la r\u00e9allocation \u00e9choue, retourner NULL\u2009; le bloc pass\u00e9 en   param\u00e8tre reste alors inchang\u00e9</li> <li>en cas de succ\u00e8s, l'adresse retourn\u00e9e peut \u00eatre diff\u00e9rente de ptr\u2009; le   bloc initialement point\u00e9 par ptr a alors \u00e9t\u00e9 lib\u00e9r\u00e9</li> <li>le bloc r\u00e9allou\u00e9 est initialis\u00e9 avec le contenu du bloc ptr\u2009;   l'espace suppl\u00e9mentaire est non initialis\u00e9</li> </ul>"}, {"location": "course-c/20-architecture-and-systems/memory-management/#liberation", "title": "Lib\u00e9ration", "text": "<p>Le tas n'\u00e9tant pas extensible \u00e0 l'infini, il faut lib\u00e9rer la m\u00e9moire d\u00e8s que l'on n'en a plus l'utilit\u00e9.</p> <pre><code>void free(void *memblock);\n</code></pre> <p>Une fois lib\u00e9r\u00e9e, la m\u00e9moire (donc son pointeur) ne doit plus \u00eatre utilis\u00e9e sous peine de corrompre des donn\u00e9es du syst\u00e8me.</p> <pre><code>int n;\ndouble * zone_acquisition; // pointeur sur la zone \u00e0 r\u00e9server\n\nn=100;\n\nzone_acquisition = (double*) malloc ( n * sizeof(double) );\n\n// utilisation...\n\nfree(zone_acquisition); // lib\u00e8re la m\u00e9moire\n</code></pre> <p>De la m\u00eame mani\u00e8re, il ne faut pas lib\u00e9rer un bloc qui n'a pas \u00e9t\u00e9 allou\u00e9. Si on ne lib\u00e8re pas la m\u00e9moire, elle reste allou\u00e9e pour l'application et la zone disponible diminue. Il peut arriver qu'il ne reste plus d'espace disponible pour l'allocation dynamique\u2009; cela peut entraver la bonne marche de l'ordinateur. Ce probl\u00e8me est souvent d\u00fb \u00e0 des erreurs de conception des applications qui ne lib\u00e8rent pas tous les blocs allou\u00e9s\u2009; on observe alors un ph\u00e9nom\u00e8ne de fuite m\u00e9moire qui cause le plantage de la machine. Selon les fr\u00e9quences d'allocation et de non lib\u00e9ration, ces probl\u00e8mes peuvent survenir imm\u00e9diatement, ou apr\u00e8s plusieurs jours de fonctionnement, ce qui complique grandement les op\u00e9rations de debug...</p>"}, {"location": "course-c/20-architecture-and-systems/memory-management/#allocation-dynamique-sur-la-pile", "title": "Allocation dynamique sur la pile", "text": "<p>L'allocation dynamique sur la pile est \u00e9quivalente \u00e0 l'allocation sur le tas sauf qu'elle est plus rapide (pas de recherche par le syst\u00e8me d'un espace suffisant et continu) et qu'elle ne n\u00e9cessite pas de lib\u00e9ration.</p> <p>On utilisera la fonction alloca (memory allocation) pour r\u00e9server de la m\u00e9moire. Cette fonction n'initialise pas la zone r\u00e9serv\u00e9e.</p> <pre><code>void* alloca(size_t size);\n</code></pre> <p>Il est n\u00e9cessaire d'inclure le fichier malloc.h pour utiliser cette fonction d'allocation m\u00e9moire sur la pile. L'espace est lib\u00e9r\u00e9 \u00e0 la sortie de la fonction appelante. On veillera tout particuli\u00e8rement \u00e0 ce que le pointeur ayant re\u00e7u l'adresse de la zone m\u00e9moire r\u00e9serv\u00e9e ne soit pas exploit\u00e9 en dehors de la fonction (puisque la zone est lib\u00e9r\u00e9e quand on en sort).</p>"}, {"location": "course-c/20-architecture-and-systems/memory-management/#limite-dutilisation-de-la-pile", "title": "Limite d'utilisation de la pile", "text": "<p>L'espace m\u00e9moire utilis\u00e9 par la pile est une zone dont l'usage est uniquement d\u00e9di\u00e9 au programme. Si plusieurs programmes cohabitent en m\u00e9moire, ils auront chacun leur propre pile.</p> <p>Cet espace m\u00e9moire d\u00e9di\u00e9 \u00e0 la pile est de taille fixe et d\u00e9finie lors de la compilation du programme.</p> <p>La pile re\u00e7oit les \u00e9l\u00e9ments suivants\u2009:</p> <ul> <li>les variables locales aux fonctions,</li> <li>les variables d\u00e9clar\u00e9es comme param\u00e8tres dans les fonctions,</li> <li>les informations li\u00e9es aux m\u00e9canismes d'appel et de retour des   fonctions,</li> <li>les donn\u00e9es retourn\u00e9es par les fonctions,</li> <li>les zones allou\u00e9es par la fonction <code>alloca</code>.</li> </ul> <p>\u00c9tant donn\u00e9 que la taille de la pile est fixe, il y a un risque qu'elle soit trop petite pour supporter toutes les informations que votre programme doit y placer. Si cela se produit, il y a corruption de la m\u00e9moire puisque la pile 'd\u00e9borde' et que vous d\u00e9passez la zone qui lui est d\u00e9di\u00e9e.</p> <p>Les \u00e9v\u00e9nements suivants peuvent g\u00e9n\u00e9rer des d\u00e9bordements de piles\u2009:</p> <ul> <li>trop de variables locales (par exemple un grand tableau),</li> <li>trop d'appels de fonctions en cascade,</li> <li>utilisation de fonctions r\u00e9cursives (qui s'autoappellent).</li> </ul> <p>Dans le jargon informatique, on appelle \u00e7a du jardinage puisque vous allez pi\u00e9tiner les zones m\u00e9moires voisines sans en avoir la permission.</p> <p>Le compilateur (en r\u00e9alit\u00e9 l'\u00e9diteur de liens - le linker) vous permet de sp\u00e9cifier la taille de la pile\u2009; c'est une de ses nombreuses options.</p>"}, {"location": "course-c/20-architecture-and-systems/memory-management/#variables-automatiques", "title": "Variables automatiques", "text": "<p>Une variable est dite automatique lorsque sa d\u00e9claration est faite au sein d'une fonction. La variable d'it\u00e9ration <code>int i</code> dans une boucle <code>for</code> est dite automatique. C'est-\u00e0-dire que le compilateur a le choix de placer cette variable\u2009:</p> <ul> <li>sur la pile\u2009;</li> <li>dans un registre m\u00e9moire processeur.</li> </ul> <p>Jadis, le mot cl\u00e9 <code>register</code> \u00e9tait utilis\u00e9 pour forcer le compilateur \u00e0 placer une variable locale dans un registre processeur pour obtenir de meilleures performances. Aujourd'hui, les compilateurs sont assez malins pour d\u00e9terminer automatiquement les variables souvent utilis\u00e9es.</p>"}, {"location": "course-c/20-architecture-and-systems/memory-management/#fragmentation-memoire", "title": "Fragmentation m\u00e9moire", "text": "<p>On peut observer \u00e0 la figure suivante montre qu'apr\u00e8s un appel successif de <code>malloc</code> et de <code>free</code> des espaces m\u00e9moire non utilis\u00e9s peuvent appara\u00eetre entre des r\u00e9gions utilis\u00e9es. Ces trous sont appel\u00e9s fragmentation m\u00e9moire.</p> <p>Dans la figure suivante, on suit l'\u00e9volution de l'utilisation du heap au cours de la vie d'un programme. Au d\u00e9but \u2780, la m\u00e9moire est libre. Tant que de la m\u00e9moire est allou\u00e9e sans lib\u00e9ration (<code>free</code>), aucun probl\u00e8me de fragmentation \u2781. N\u00e9anmoins, apr\u00e8s un certain temps la m\u00e9moire devient fragment\u00e9e \u2782\u2009; il reste dans cet exemple 2 emplacements de taille 2, un emplacement de taille 5 et un emplacement de taille 8. Il est donc impossible de r\u00e9server un espace de taille 9 malgr\u00e9 que l'espace cumul\u00e9 libre est suffisant.</p> <p> Fragmentation m\u00e9moire</p> <p>Dans une petite architecture, l'allocation et la lib\u00e9ration fr\u00e9quente d'espaces m\u00e9moire de taille arbitraire sont malvenues. Une fois que la fragmentation m\u00e9moire est install\u00e9e, il n'existe aucun moyen de soigner le mal si ce n'est au travers de l'ultime solution de l'informatique\u2009: \u00e9teindre puis red\u00e9marrer.</p>"}, {"location": "course-c/20-architecture-and-systems/memory-management/#mmu", "title": "MMU", "text": "<p>Les syst\u00e8mes d'exploitation modernes (Windows, Linux, macOS...) utilisent tous un dispositif mat\u00e9riel nomm\u00e9 MMU pour Memory Management Unit. La MMU est responsable de cr\u00e9er un espace m\u00e9moire virtuel entre l'espace physique. Cela cr\u00e9e une indirection suppl\u00e9mentaire, mais permet de r\u00e9organiser la m\u00e9moire physique sans compromettre le syst\u00e8me.</p> <p>En pratique l'espace de m\u00e9moire virtuelle est toujours beaucoup plus grand que l'espace physique. Cela permet de s'affranchir dans une large mesure de probl\u00e8mes de fragmentation, car si l'espace virtuel est suffisamment grand, il y aura statistiquement plus de chance d'y trouver un emplacement non utilis\u00e9.</p> <p>La programmation sur de petites architectures mat\u00e9rielles (microcontr\u00f4leurs, DSP) ne poss\u00e8de pas de MMU et d\u00e8s lors l'allocation dynamique est g\u00e9n\u00e9ralement \u00e0 proscrire \u00e0 moins qu'elle soit faite en connaissance de cause et en utilisant des m\u00e9canismes comme les memory pool.</p> <p>Dans la figure ci-dessous. La m\u00e9moire physique est repr\u00e9sent\u00e9e \u00e0 droite en termes de pages m\u00e9moires physiques (Physical Pages ou PP). Il s'agit de blocs m\u00e9moires contigus d'une taille fixe, par exemple 64 kb. Chaque page physique est mapp\u00e9e dans une table propre \u00e0 chaque processus (programme ex\u00e9cutable). On y retrouve quelques propri\u00e9t\u00e9s utiles \u00e0 savoir, est-ce que la page m\u00e9moire est accessible en \u00e9criture, est-ce qu'elle peut contenir du code ex\u00e9cutable\u2009? Une propri\u00e9t\u00e9 peut indiquer par exemple si la page m\u00e9moire est valide. Chacune de ces entr\u00e9es est consid\u00e9r\u00e9e comme une page m\u00e9moire virtuelle (virtual page VP).</p> <p> M\u00e9moire virtuelle</p>"}, {"location": "course-c/20-architecture-and-systems/memory-management/#erreurs-de-segmentation-segmentation-fault", "title": "Erreurs de segmentation (segmentation fault)", "text": "<p>Lorsqu'un programme tente d'acc\u00e9der \u00e0 un espace m\u00e9moire qui n'est pas mapp\u00e9 dans la MMU, ou que cet espace m\u00e9moire ne permet pas le type d'acc\u00e8s souhait\u00e9\u2009: par exemple une \u00e9criture dans une page en lecture seule. Le syst\u00e8me d'exploitation tue le processus avec une erreur Segmentation Fault. C'est la raison pour laquelle, il n'est pas syst\u00e9matique d'avoir une erreur de segmentation en cas de jardinage m\u00e9moire. Tant que les valeurs modifi\u00e9es sont localis\u00e9es au sein d'un bloc m\u00e9moire autoris\u00e9, il n'y aura pas d'erreur.</p> <p>L'erreur de segmentation est donc g\u00e9n\u00e9r\u00e9e par le syst\u00e8me d'exploitation en levant le signal SIGSEGV (Violation d'acc\u00e8s \u00e0 un segment m\u00e9moire, ou erreur de segmentation).</p>"}, {"location": "course-c/20-architecture-and-systems/memory-management/#memory-pool", "title": "Memory Pool", "text": "<p>Un memory pool est une m\u00e9thode faisant appel \u00e0 de l'allocation dynamique de blocs de taille fixe. Lorsqu'un programme doit tr\u00e8s r\u00e9guli\u00e8rement allouer et d\u00e9sallouer de la m\u00e9moire, il est pr\u00e9f\u00e9rable que les blocs m\u00e9moires aient une taille fixe. De cette fa\u00e7on, apr\u00e8s un <code>free</code>, la m\u00e9moire lib\u00e9r\u00e9e est assez grande pour une allocation ult\u00e9rieure.</p> <p>Lorsqu'un programme est ex\u00e9cut\u00e9 sous Windows, macOS ou Linux, l'allocation dynamique standard <code>malloc</code>, <code>calloc</code>, <code>realloc</code> et <code>free</code> sont performant et le risque de crash d\u00fb \u00e0 une fragmentation m\u00e9moire est rare.</p> <p>En revanche, lors de l'utilisation sur de petites architectures (microcontr\u00f4leurs) qui n'ont pas de syst\u00e8me sophistiqu\u00e9 pour g\u00e9rer la m\u00e9moire, il est parfois n\u00e9cessaire d'\u00e9crire son propre syst\u00e8me de gestion de m\u00e9moire.</p>"}, {"location": "course-c/20-architecture-and-systems/programs-and-processes/", "title": "Programmes et Processus", "text": ""}, {"location": "course-c/20-architecture-and-systems/programs-and-processes/#quest-ce-quun-programme", "title": "Qu'est-ce qu'un programme\u2009?", "text": "<p>Un programme informatique est un ensemble d'op\u00e9rations destin\u00e9es \u00e0 \u00eatre ex\u00e9cut\u00e9es par un ordinateur. Un programme peut se d\u00e9cliner sous plusieurs formes\u2009:</p> <ul> <li>Le code source (C, C++, Python, Java, etc.)</li> <li>Le listing assembleur (<code>.s</code>, <code>.asm</code>)</li> <li>L'ex\u00e9cutable binaire (ELF, <code>.exe</code>, <code>.out</code>, <code>.dll</code>, <code>.so</code>, etc.)</li> </ul> <p>Un processus est l'\u00e9tat d'un programme en cours d'ex\u00e9cution. Lorsqu'un programme est ex\u00e9cut\u00e9, il devient processus pendant un temps donn\u00e9. Les syst\u00e8mes d'exploitation tels que Windows sont dits multit\u00e2ches, il peuvent par cons\u00e9quent faire tourner plusieurs processus en parall\u00e8le. Le temps processeur est ainsi partag\u00e9 entre chaque processus.</p> <p> Programmeuse en tenue d\u00e9contract\u00e9e \u00e0 c\u00f4t\u00e9 de 62'500 cartes perfor\u00e9es</p>"}, {"location": "course-c/20-architecture-and-systems/programs-and-processes/#code-source", "title": "Code source", "text": "<p>Le code source est g\u00e9n\u00e9ralement \u00e9crit par un ing\u00e9nieur/d\u00e9veloppeur/informaticien. Il s'agit le plus souvent d'un fichier texte lisible par un \u00eatre humain et souvent pourvu de commentaires facilitant sa compr\u00e9hension. Selon le langage de programmation utilis\u00e9, la programmation peut \u00eatre graphique comme avec les diagrammes Ladder utilis\u00e9s dans les automates programmables et respectant la norme IEC 61131-3, ou LabView un outil de d\u00e9veloppement graphique.</p> <p>Le plus souvent le code source est organis\u00e9 en une arborescence de fichiers. Des programmes complexes comme le noyau Linux contiennent plus de 100'000 fichiers et 10 millions de lignes de code, pour la plupart \u00e9crites en C.</p>"}, {"location": "course-c/20-architecture-and-systems/programs-and-processes/#executable-binaire", "title": "Ex\u00e9cutable binaire", "text": "<p>Une fois compil\u00e9 en langage machine, il en r\u00e9sulte un fichier qui peut \u00eatre ex\u00e9cut\u00e9 soit par un syst\u00e8me d'exploitation, soit sur une plateforme embarqu\u00e9e \u00e0 microcontr\u00f4leur sans l'interm\u00e9diaire d'un syst\u00e8me d'exploitation. On dit que ce type de programme est bare metal, qu'il s'ex\u00e9cute \u00e0 m\u00eame le m\u00e9tal.</p> <p>Un ex\u00e9cutable binaire doit \u00eatre compil\u00e9 pour la bonne architecture mat\u00e9rielle. Un programme compil\u00e9 pour un processeur INTEL ne pourra pas s'ex\u00e9cuter sur un processeur ARM, c'est pourquoi on utilise diff\u00e9rents compilateurs en fonctions des architectures cibles. L'op\u00e9ration de compiler un programme pour une autre architecture, ou un autre syst\u00e8me d'exploitation que celui sur lequel est install\u00e9 le compilateur s'appelle la compilation crois\u00e9e (cross-compilation).</p> <p>Prenons l'exemple du programme suivant qui calcule la suite des nombres de Fibonacci\u2009:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    int t1 = 0, t2 = 1;\n    int n, next_term;\n    printf(\"Enter the number of terms: \");\n    scanf(\"%d\", &amp;n);\n    printf(\"Fibonacci Series: \");\n    for (size_t i = 1; i &lt;= n; ++i)\n    {\n        printf(\"%d, \", t1);\n        next_term = t1 + t2;\n        t1 = t2;\n        t2 = next_term;\n    }\n    printf(\"\\n\");\n}\n</code></pre> <p>Une fois assembl\u00e9 le code  source est converti en langage assembleur, une version interm\u00e9diaire entre le C et le langage machine. L'exemple est compil\u00e9 en utilisant gcc\u2009:</p> <pre><code>gcc Fibonacci.c -o fibonacci.exe\nobjdump -d fibonacci.exe\n</code></pre> <p>On obtient un fichier similaire \u00e0 ceci qui contient le code machine (<code>48 83 ec 20</code>), et l'\u00e9quivalent en langage assembleur (<code>mov    %fs:0x28,%rax</code>):</p> <pre><code>0000000000000680 &lt;main&gt;:\n680:   41 55                   push   %r13\n682:   41 54                   push   %r12\n684:   48 8d 35 59 02 00 00    lea    0x259(%rip),%rsi\n68b:   55                      push   %rbp\n68c:   53                      push   %rbx\n68d:   bf 01 00 00 00          mov    $0x1,%edi\n692:   48 83 ec 18             sub    $0x18,%rsp\n696:   64 48 8b 04 25 28 00    mov    %fs:0x28,%rax\n69d:   00 00\n69f:   48 89 44 24 08          mov    %rax,0x8(%rsp)\n6a4:   31 c0                   xor    %eax,%eax\n6a6:   e8 a5 ff ff ff          callq  650 &lt;__printf_chk@plt&gt;\n6ab:   48 8d 74 24 04          lea    0x4(%rsp),%rsi\n6b0:   48 8d 3d 49 02 00 00    lea    0x249(%rip),%rdi\n6b7:   31 c0                   xor    %eax,%eax\n6b9:   e8 a2 ff ff ff          callq  660 &lt;__isoc99_scanf@plt&gt;\n6be:   48 8d 35 3e 02 00 00    lea    0x23e(%rip),%rsi\n...\n72e:   00 00\n730:   75 0b                   jne    73d &lt;main+0xbd&gt;\n732:   48 83 c4 18             add    $0x18,%rsp\n736:   5b                      pop    %rbx\n737:   5d                      pop    %rbp\n738:   41 5c                   pop    %r12\n73a:   41 5d                   pop    %r13\n73c:   c3                      retq\n73d:   e8 fe fe ff ff          callq  640 &lt;__stack_chk_fail@plt&gt;\n742:   66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)\n749:   00 00 00\n74c:   0f 1f 40 00             nopl   0x0(%rax)\n</code></pre> <p>Avec un visualiseur hexad\u00e9cimal, on peut extraire le langage machine du binaire ex\u00e9cutable. L'utilitaire <code>hexdump</code> est appel\u00e9 avec deux options <code>-s</code> pour sp\u00e9cifier l'adresse de d\u00e9but, on choisit ici celle du d\u00e9but de la fonction <code>main</code> <code>0x680</code>, et <code>-n</code> pour n'extraire que les premiers 256 octets\u2009:</p> <pre><code>$ hexdump -s0x680 -n256 a.out\n0000680 5541 5441 8d48 5935 0002 5500 bf53 0001\n0000690 0000 8348 18ec 4864 048b 2825 0000 4800\n00006a0 4489 0824 c031 a5e8 ffff 48ff 748d 0424\n00006b0 8d48 493d 0002 3100 e8c0 ffa2 ffff 8d48\n00006c0 3e35 0002 3100 bfc0 0001 0000 7fe8 ffff\n00006d0 8bff 2444 8504 74c0 4c3d 2d8d 0236 0000\n00006e0 bc41 0001 0000 01bd 0000 3100 0fdb 001f\n00006f0 da89 c031 894c bfee 0001 0000 8349 01c4\n0000700 4be8 ffff 8dff 2b04 eb89 c589 6348 2444\n0000710 4c04 e039 da73 0abf 0000 e800 ff10 ffff\n0000720 c031 8b48 244c 6408 3348 250c 0028 0000\n0000730 0b75 8348 18c4 5d5b 5c41 5d41 e8c3 fefe\n0000740 ffff 2e66 1f0f 0084 0000 0000 1f0f 0040\n0000750 ed31 8949 5ed1 8948 48e2 e483 50f0 4c54\n0000760 058d 016a 0000 8d48 f30d 0000 4800 3d8d\n0000770 ff0c ffff 15ff 0866 0020 0ff4 441f 0000\n</code></pre> <p>Il est facile de voir la correspondance entre l'assembleur et l'ex\u00e9cutable binaire. Les valeurs <code>41 55</code> puis <code>41 54</code> puis <code>48 8d 35 59</code> se retrouvent directement dans le dump: <code>5541 5441 8d48</code>. Si les valeurs sont interverties, c'est parce qu'un PC est little-endian (c.f. endianess), les octets de poids faible apparaissent par cons\u00e9quent en premier dans la m\u00e9moire.</p> <p>Sous Windows, l'extension des fichiers d\u00e9termine leur type. Un fichier avec l'extension <code>.jpg</code> sera un fichier image du Join Photographic Experts Group et ex\u00e9cuter ce fichier correspond \u00e0 l'ouvrir en utilisant l'application par d\u00e9faut pour visualiser les images de ce type. Un fichier avec l'extension <code>.exe</code> est un ex\u00e9cutable binaire, et il sera ex\u00e9cut\u00e9 en tant que programme par le syst\u00e8me d'exploitation.</p> <p>Sous POSIX (Linux, macOS, UNIX), les flags d'un fichier qualifient son type. Le programme <code>ls</code> permet de visualiser les flags du programme <code>Fibonacci</code> que nous avons compil\u00e9\u2009:</p> <pre><code>$ ls -al a.out\n-rwxr-xr-x 1 root ftp 8.3K Jul 17 09:53 Fibonacci\n</code></pre> <p>Les lettres <code>r-x</code> indiquent\u2009:</p> <code>r</code> <p>Lecture autoris\u00e9e</p> <code>w</code> <p>\u00c9criture autoris\u00e9e</p> <code>x</code> <p>Ex\u00e9cution autoris\u00e9e</p> <p>Ce programme peut-\u00eatre ex\u00e9cut\u00e9 par tout le monde, mais modifi\u00e9 que par l'utilisateur <code>root</code>.</p>"}, {"location": "course-c/20-architecture-and-systems/programs-and-processes/#entrees-sorties", "title": "Entr\u00e9es sorties", "text": "<p>Tout programme doit pouvoir interagir avec son environnement. \u00c0 l'\u00e9poque des t\u00e9l\u00e9scripteurs, un programme interagissait avec un clavier et une imprimante matricielle. Avec l'arriv\u00e9e des syst\u00e8mes d'exploitation, le champ d'action fut r\u00e9duit \u00e0 des entr\u00e9es\u2009:</p> <ul> <li>L'entr\u00e9e standard <code>STDIN</code> fournit au programme du contenu qui est g\u00e9n\u00e9ralement fourni par la sortie d'un autre programme.</li> <li>Les arguments du programme <code>ARGV</code></li> <li>Les variables d'environnement <code>ENVP</code></li> </ul> <p>Ainsi qu'\u00e0 des sorties\u2009:</p> <ul> <li>La sortie standard <code>STDOUT</code> est g\u00e9n\u00e9ralement affich\u00e9e \u00e0 l'\u00e9cran</li> <li>La sortie d'erreur standard <code>STDERR</code> contient des d\u00e9tails sur les \u00e9ventuelles erreurs d'ex\u00e9cution du programme.</li> </ul> <p>La figure suivante r\u00e9sume les interactions qu'un programme peut avoir sur son environnement. Les appels syst\u00e8me (syscall) sont des ordres transmis directement au syst\u00e8me d'exploitation. Ils permettent par exemple de lire des fichiers, d'\u00e9crire \u00e0 l'\u00e9cran, de mettre le programme en pause ou de terminer le programme.</p> <p> R\u00e9sum\u00e9 des interactions avec un programme</p> <p></p>"}, {"location": "course-c/20-architecture-and-systems/programs-and-processes/#signaux", "title": "Signaux", "text": "<p>Lorsqu'un programme est en cours d'ex\u00e9cution, il peut recevoir de la part du syst\u00e8me d'exploitation des signaux. Il s'agit d'une notification asynchrone envoy\u00e9e \u00e0 un processus pour lui signaler l'apparition d'un \u00e9v\u00e8nement.</p> <p>Si, en utilisant Windows, vous vous rendez dans le gestionnaire de t\u00e2ches et que vous d\u00e9cidez de Terminer une t\u00e2che, le syst\u00e8me d'exploitation envoie un signal au programme lui demandant de se terminer.</p> <p>Sous Linux, habituellement, le shell relie certains raccourcis clavier \u00e0 des signaux particuliers\u2009:</p> <ul> <li>Ctrl+C envoie le signal <code>SIGINT</code> pour interrompre l'ex\u00e9cution d'un programme</li> <li>Ctrl+Z envoie le signal <code>SIGTSTP</code> pour suspendre l'ex\u00e9cution d'un programme</li> <li>Ctrl+T envoie le signal <code>SIGINFO</code> permettant de visualiser certaines informations li\u00e9es \u00e0 l'ex\u00e9cution du processus.</li> </ul> <p>Si le programme suivant est ex\u00e9cut\u00e9, il sera bloquant, c'est-\u00e0-dire qu'\u00e0 moins d'envoyer un signal d'interruption, il ne sera pas possible d'interrompre le processus\u2009:</p> <pre><code>int main(void)\n{\n    for(;;);\n}\n</code></pre>"}, {"location": "course-c/20-architecture-and-systems/programs-and-processes/#arguments-et-options", "title": "Arguments et options", "text": "<p>L'interpr\u00e9teur de commande <code>cmd.exe</code> sous Windows ou <code>bash</code> sous Linux, fonctionne de fa\u00e7on assez similaire. L'invite de commande nomm\u00e9e prompt en anglais invite l'utilisateur \u00e0 entrer une commande. Sous DOS puis sous Windows cet invite de commande ressemble \u00e0 ceci\u2009:</p> <pre><code>C:\\&gt;\n</code></pre> <p>Sous Linux, le prompt est largement configurable et d\u00e9pend de la distribution install\u00e9e, mais le plus souvent il se termine par le caract\u00e8re <code>$</code> ou <code>#</code>.</p> <p>Une commande d\u00e9bute par le nom de cette derni\u00e8re, qui peut \u00eatre le nom du programme que l'on souhaite ex\u00e9cuter puis vient les arguments et les options.</p> <ul> <li>Une option est par convention un argument dont le pr\u00e9fixe est <code>-</code> sous Linux ou <code>/</code> sous Windows m\u00eame si le standard GNU gagne du terrain. Aussi, le consensus le plus large semble \u00eatre le suivant\u2009:</li> <li>Une option peut \u00eatre exprim\u00e9e soit sous format court <code>-o</code>, <code>-v</code>, soit sous format long <code>--output=</code>, <code>--verbose</code> selon qu'elle commence par un ou deux tirets. Une option peut \u00eatre un bool\u00e9enne (pr\u00e9sence ou non de l'option), ou scalaire, c'est-\u00e0-dire \u00eatre associ\u00e9e \u00e0 une valeur <code>--output=foo.o</code>. Les options modifient le comportement interne d'un programme.</li> </ul> <p>Un argument est une cha\u00eene de caract\u00e8res utilis\u00e9e comme entr\u00e9e au programme. Un programme peut avoir plusieurs arguments.</p> <p>En C, c'est au d\u00e9veloppeur de distinguer les options des arguments, car ils sont tous pass\u00e9s par le param\u00e8tre <code>argv</code>:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[]) {\n    printf(\"Liste des arguments et options pass\u00e9s au programme:\\n\");\n\n    for (size_t i = 0; i &lt; argc; i++) {\n        printf(\"  %u. %s\\n\", i, argv[i]);\n    }\n}\n</code></pre> <pre><code>$ argverbose --help -h=12 3.14 'Baguette au beurre' $'\\t-Lait\\n\\t-Viande\\n\\t-Oeufs\\f'\nListe des arguments et options pass\u00e9s au programme :\n0. ./a.out\n1. --help\n2. -h=12\n3. 3.14\n4. Baguette au beurre\n5.  -Lait\n    -Viande\n    -Oeufs\n</code></pre>"}, {"location": "course-c/20-architecture-and-systems/programs-and-processes/#norme-posix", "title": "Norme POSIX", "text": "<p>Le standard POSIX d\u00e9crit une fa\u00e7on de distinguer des options pass\u00e9es \u00e0 un programme. Par exemple, le programme cowsay peut \u00eatre param\u00e9tr\u00e9 pour changer son comportement en utilisant des <code>options</code> standards comme <code>-d</code>. La fonction <code>getopt</code> disponible dans la biblioth\u00e8que <code>&lt;unistd.h&gt;</code> permet de facilement interpr\u00e9ter ces options.</p> <pre><code>int getopt(int, char * const [], const char *);\n</code></pre>"}, {"location": "course-c/20-architecture-and-systems/programs-and-processes/#extension-gnu", "title": "Extension GNU", "text": "<p>Malheureusement, la norme POSIX ne sp\u00e9cifie que les options dites courtes (un tiret suivi d'un seul caract\u00e8re). Une extension GNU et son en-t\u00eate <code>&lt;getopt.h&gt;</code> permet l'acc\u00e8s \u00e0 la fonction <code>getopt_long</code> laquelle permet d'interpr\u00e9ter aussi les options longues <code>--version</code> qui sont devenues tr\u00e8s r\u00e9pandues.</p> <pre><code>int getopt_long (int argc, char *const *argv, const char *shortopts,\n                 const struct option *longopts, int *longind);\n</code></pre> <p>Ci-dessous une possible utilisation de cette fonction\u2009:</p> <pre><code>#include &lt;getopt.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct Options {\n    bool is_verbose;\n\n    bool has_add;\n    bool has_append;\n    bool has_delete;\n    bool has_create;\n\n    char *create_name;\n    char *delete_name;\n    char *file_name;\n} Options;\n\nOptions parse_options(int argc, char *argv[])\n{\n    Options options = {0};\n\n    int c;\n    static int verbose_flag;  // Set by --verbose/--brief\n\n    for (;;) {\n        static struct option long_options[] = {\n            // These options set a flag.\n            {\"verbose\", no_argument, &amp;verbose_flag, true},\n            {\"brief\", no_argument, &amp;verbose_flag, false},\n\n            // These options don\u2019t set a flag. We distinguish them by their\n            // indices.\n            {\"add\", no_argument, 0, 'a'},\n            {\"append\", no_argument, 0, 'b'},\n            {\"delete\", required_argument, 0, 'd'},\n            {\"create\", required_argument, 0, 'c'},\n            {\"file\", required_argument, 0, 'f'},\n\n            // Sentinel marking the end of the structure.\n            {0, 0, 0, 0}};\n\n        // getopt_long stores the option index here.\n        int option_index = 0;\n\n        c = getopt_long(argc, argv, \"abc:d:f:\", long_options, &amp;option_index);\n\n        // Detect the end of the options.\n        if (c == -1) break;\n\n        switch (c) {\n            case 'a':\n                options.has_add = true;\n                break;\n\n            case 'b':\n                options.has_append = true;\n                break;\n\n            case 'c':\n                options.create_name = optarg;\n                break;\n\n            case 'd':\n                options.delete_name = optarg;\n                break;\n\n            case 'f':\n                options.file_name = optarg;\n                break;\n\n            case '?':\n                // getopt_long already printed an error message.\n                break;\n\n            default:\n                abort();\n        }\n    }\n    options.is_verbose = verbose_flag;\n\n    // Parses the remaining command line arguments if got any\n    while (optind &lt; argc) printf(\"%s\\n\", argv[optind++]);\n\n    return options;\n}\n\nint main(int argc, char **argv)\n{\n    Options options = parse_options(argc, argv);\n\n    // ...\n}\n</code></pre>"}, {"location": "course-c/20-architecture-and-systems/programs-and-processes/#windows", "title": "Windows", "text": "<p>Windows utilise \u00e0 l'instar de <code>RDOS</code> ou OpenVMS, le caract\u00e8re slash pour identifier ses options. Alors que sous POSIX l'affichage de la liste des fichiers s'\u00e9crira peut-\u00eatre <code>ls -l -s D*</code>, sous Windows on utilisera <code>dir /q d* /o:s</code>.</p>"}, {"location": "course-c/20-architecture-and-systems/programs-and-processes/#fonction-main", "title": "Fonction main", "text": "<p>Le standard d\u00e9finit une fonction nomm\u00e9e <code>main</code> comme \u00e9tant la fonction principale appel\u00e9e \u00e0 l'ex\u00e9cution du programme. Or, sur un syst\u00e8me d'exploitation, la fonction <code>main</code> a d\u00e9j\u00e0 \u00e9t\u00e9 appel\u00e9e il y a belle lurette lorsque l'ordinateur a \u00e9t\u00e9 allum\u00e9 et que le BIOS a charg\u00e9 le syst\u00e8me d'exploitation en m\u00e9moire. D\u00e8s lors la fonction <code>main</code> de notre programme Hello World n'est pas la premi\u00e8re, mais est appel\u00e9.</p>"}, {"location": "course-c/20-architecture-and-systems/programs-and-processes/#qui-appelle-main", "title": "Qui appelle main\u2009?", "text": "<p>Un ex\u00e9cutable binaire \u00e0 un format particulier appel\u00e9 ELF (Executable and Linkable Format) qui contient un point d'entr\u00e9e qui sera l'adresse m\u00e9moire de d\u00e9but du programme. Sous un syst\u00e8me POSIX ce point d'entr\u00e9e est nomm\u00e9 <code>_init</code>. C'est lui qui est responsable de r\u00e9colter les informations transmises par le syst\u00e8me d'exploitation. Ce dernier transmet sur la pile du programme\u2009:</p> <ul> <li>Le nombre d'arguments <code>argc</code></li> <li>La liste des arguments <code>argv</code></li> <li>Les variables d'environnements <code>envp</code></li> <li>Les pointeurs de fichiers sur <code>stdout</code>, <code>stdin</code>, <code>stderr</code></li> </ul> <p>C'est la fonction <code>__libc_start_main</code> de la biblioth\u00e8que standard qui a la responsabilit\u00e9 d'appeler la fonction <code>main</code>. Voici son prototype\u2009:</p> <pre><code>int __libc_start_main(int (*main) (int, char**, char**),\n    int argc, char** ubp_av,\n    void (*init)(void),\n    void (*fini)(void),\n    void (*rtld_fini)(void),\n    void (*stack_end)\n);\n</code></pre>"}, {"location": "course-c/20-architecture-and-systems/programs-and-processes/#valeur-de-retour", "title": "Valeur de retour", "text": "<p>La fonction <code>main</code> renvoie toujours une valeur de retour qui agit comme le statut de sortie d'un programme (exit status). Sous POSIX et sous Windows, le programme parent s'attend \u00e0 recevoir une valeur 32-bits \u00e0 la fin de l'ex\u00e9cution d'un programme. L'interpr\u00e9tation est la suivante\u2009:</p> <code>0</code> <p>Succ\u00e8s, le programme s'est termin\u00e9 correctement.</p> <code>!0</code> <p>Erreur, le programme ne s'est pas termin\u00e9 correctement.</p> <p>Par exemple le programme <code>printf</code> retourne dans le cas pr\u00e9cis l'erreur 130\u2009:</p> <pre><code>$ printf '%d' 42\n42\n$ echo $?\n0\n\n$ printf '%d' 'I am not a number'\nprintf: I am not a number: invalid number\n$ echo $?\n130\n</code></pre>"}, {"location": "course-c/20-architecture-and-systems/programs-and-processes/#entrees-sorties-standards", "title": "Entr\u00e9es sorties standards", "text": "<p>Le fichier d'en-t\u00eate <code>stdio.h</code> (man stdio) permet de simplifier l'interaction avec les fichiers. Sous Linux et macOS principalement, mais d'une certaine mani\u00e8re \u00e9galement sous Windows, les canaux d'\u00e9changes entre un programme et son h\u00f4te (shell, gestionnaire de fen\u00eatre, autre programme), se font par l'interm\u00e9diaire de fichiers particuliers nomm\u00e9s <code>stdin</code>, <code>stdout</code> et <code>stderr</code>.</p> <p>La fonction de base est <code>putchar</code> qui \u00e9crit un caract\u00e8re sur <code>stdout</code>:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    putchar('H');\n    putchar('e');\n    putchar('l');\n    putchar('l');\n    putchar('o');\n    putchar('\\n');\n}\n</code></pre> <p>Bien vite, on pr\u00e9f\u00e8rera utiliser <code>printf</code> qui simplifie le formatage de cha\u00eenes de caract\u00e8res et qui permet \u00e0 l'aide de marqueurs (tokens) de formater des variables\u2009:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Hello\\v\");\n    printf(\"%d, %s, %f\", 0x12, \"World!\", 3.1415);\n}\n</code></pre> <p>Il peut \u00eatre n\u00e9cessaire, surtout lorsqu'il s'agit d'erreurs qui ne concernent pas la sortie standard du programme, d'utiliser le bon canal de communication, c'est-\u00e0-dire <code>stderr</code> au lieu de <code>stdout</code>. La fonction <code>fprintf</code> permet de sp\u00e9cifier le flux standard de sortie\u2009:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    fprintf(stdout, \"Sortie standard\\n\");\n    fprintf(stderr, \"Sortie d'erreur standard\\n\");\n}\n</code></pre> <p>Pourquoi, me direz-vous, faut-il s\u00e9parer la sortie standard du canal d'erreur\u2009? Le plus souvent un programme n'est pas utilis\u00e9 seul, mais en conjonction avec d'autres programmes\u2009:</p> <pre><code>$ echo \"Bonjour\" | tr 'A-Za-z' 'N-ZA-Mn-za-m' &gt; data.txt\n$ cat data.txt\nObawbhe\n</code></pre> <p>Dans cet exemple ci-dessus, le programme <code>echo</code> prend en argument la cha\u00eene de caract\u00e8re <code>Bonjour</code> qu'il envoie sur la sortie standard. Ce flux de sortie est reli\u00e9 au flux d'entr\u00e9e du programme <code>tr</code> qui effectue une op\u00e9ration de ROT13 et envoie le r\u00e9sultat sur la sortie standard. Ce flux est ensuite redirig\u00e9 sur le fichier <code>data.txt</code>. La commande suivante <code>cat</code> lis le contenu du fichier dont le nom est pass\u00e9 en argument et \u00e9crit le contenu sur la sortie standard.</p> <p>Dans le cas o\u00f9 un de ces programmes g\u00e9n\u00e8re une alerte (warning), le texte ne sera pas transmis le long de la cha\u00eene, mais simplement affich\u00e9 sur la console. Il est donc une bonne pratique que d'utiliser le bon flux de sortie\u2009: <code>stdout</code> pour la sortie standard et <code>stderr</code> pour les messages de diagnostic et les erreurs.</p>"}, {"location": "course-c/20-architecture-and-systems/programs-and-processes/#boucle-dattente", "title": "Boucle d'attente", "text": "<p>Comme \u00e9voqu\u00e9, un programme est souvent destin\u00e9 \u00e0 tourner sur un syst\u00e8me d'exploitation. Un programme simple comme celui-ci\u2009:</p> <pre><code>int main(void) {\n    for(;;) {}\n}\n</code></pre> <p>consommera 100% des ressources du processeur. En d'autres termes, le processeur d\u00e9pensera toute son \u00e9nergie \u00e0 faire 150 millions de calculs par seconde, pour rien. Et les autres processus n'auront que tr\u00e8s peu de ressources disponibles pour tourner.</p> <p>Il est grandement pr\u00e9f\u00e9rable d'utiliser des appels syst\u00e8me pour indiquer au noyau du syst\u00e8me d'exploitation que le processus souhaite \u00eatre mis en pause pour un temps donn\u00e9. Le programme suivant utilise la fonction standard <code>sleep</code> pour demander au noyau d'\u00eatre mis en attente pour une p\u00e9riode de temps sp\u00e9cifi\u00e9e en param\u00e8tre.</p> <pre><code>#include &lt;unistd.h&gt;\n\nint main(void) {\n    for(;;) {\n        sleep(1 /* seconds */);\n\n        ...\n    }\n}\n</code></pre> <p>Alternativement, lorsqu'un programme attend un retour de l'utilisateur par exemple en demandant la saisie au clavier d'informations, le syst\u00e8me d'exploitation est \u00e9galement mis en attente et le processus ne consomme pas de ressources CPU. Le programme ci-dessous attend que l'utilisateur presse la touche entr\u00e9e.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    for(;;) {\n        getchar();\n        printf(\"Vous avez press\u00e9 la touche enter (\\\\n)\\n\");\n    }\n}\n</code></pre> <p>Exercise\u2009: La fortune, la vache qui dit et le chat dr\u00f4le</p> <p>En rappelant l'historique des derni\u00e8res commandes ex\u00e9cut\u00e9es sur l'ordinateur du professeur pendant qu'il avait le dos tourn\u00e9, vous tombez sur cette commande\u2009:</p> <pre><code>$ fortune | cowsay | lolcat\n</code></pre> <p>Quelle est sa structure et que fait-elle\u2009?</p>"}, {"location": "course-c/25-data-structures/composed-types/", "title": "Types composites", "text": ""}, {"location": "course-c/25-data-structures/composed-types/#tableaux", "title": "Tableaux", "text": "<p>Les tableaux (arrays) repr\u00e9sentent une s\u00e9quence finie d'\u00e9l\u00e9ments d'un type donn\u00e9 que l'on peut acc\u00e9der par leur position (indice) dans la s\u00e9quence. Un tableau est par cons\u00e9quent une liste index\u00e9e de variable du m\u00eame type.</p> <p>L'op\u00e9rateur crochet <code>[]</code> est utilis\u00e9 \u00e0 la fois pour le d\u00e9r\u00e9f\u00e9rencement (acc\u00e8s \u00e0 un indice du tableau) et pour l'assignation d'une taille \u00e0 un tableau\u2009:</p> <p>La d\u00e9claration d'un tableau d'entiers de dix \u00e9l\u00e9ments s'\u00e9crit de la fa\u00e7on suivante\u2009:</p> <pre><code>int array[10];\n</code></pre> <p>Par la suite il est possible d'acc\u00e9der aux diff\u00e9rents \u00e9l\u00e9ments ici l'\u00e9l\u00e9ment 1 et 3 (deuxi\u00e8me et quatri\u00e8me position du tableau) :</p> <pre><code>array[1];\narray[5 - 2];\n</code></pre> <p>L'op\u00e9rateur <code>sizeof</code> permet d'obtenir la taille d'un tableau en m\u00e9moire, mais attention, c'est la taille du tableau et non le nombre d'\u00e9l\u00e9ments qui est retourn\u00e9. Dans l'exemple suivant <code>sizeof(array)</code> retourne \\(10\\cdot4 = 40\\) tandis que <code>sizeof(array[0])</code> retourne la taille d'un seul \u00e9l\u00e9ment \\(4\\); et donc, <code>sizeof(array) / sizeof(array[0])</code> est le nombre d'\u00e9l\u00e9ments de ce tableau, soit 10.</p> <pre><code>uint32_t array(5);\nsize_t length = sizeof(array) / sizeof(array[0]);\n</code></pre> <p>L'indice z\u00e9ro</p> <p>L'index d'un tableau commence toujours \u00e0 0 et par cons\u00e9quent l'index maximum d'un tableau de 5 \u00e9l\u00e9ments sera 4. Il est donc fr\u00e9quent dans une boucle d'utiliser <code>&lt;</code> et non <code>&lt;=</code>:</p> <pre><code>for(size_t i = 0; i &lt; sizeof(array) / sizeof(array[0]); i++) {\n/* ... */\n}\n</code></pre> <p>Une variable repr\u00e9sentant un tableau est en r\u00e9alit\u00e9 un pointeur sur ce tableau, c'est-\u00e0-dire la position m\u00e9moire \u00e0 laquelle se trouvent les \u00e9l\u00e9ments du tableau. Nous verrons ceci plus en d\u00e9tail \u00e0 la section sur les pointeurs. Ce qu'il est important de retenir c'est que lorsqu'un tableau est pass\u00e9 \u00e0 une fonction comme dans l'exemple suivant, l'entier du tableau n'est pas pass\u00e9 par copie, mais seule une r\u00e9f\u00e9rence sur ce tableau est pass\u00e9e.</p> <p>La preuve \u00e9tant que le contenu du tableau peut \u00eatre modifi\u00e9 \u00e0 distance\u2009:</p> <pre><code>void function(int i[5]) {\n   i[2] = 12\n}\n\nint main(void) {\n   int array[5] = {0};\n   function(array);\n   assert(array[2] == 12);\n}\n</code></pre> <p>Un fait remarquable est que l'op\u00e9rateur <code>[]</code> est commutatif. En effet, l'op\u00e9rateur crochet est un sucre syntaxique\u2009:</p> <pre><code>a[b] == *(a + b)\n</code></pre> <p>Et cela fonctionne m\u00eame avec les tableaux \u00e0 plusieurs dimensions\u2009:</p> <pre><code>a[1][2] == *(*(a + 1) + 2))\n</code></pre> <p>Exercise\u2009: Assignation</p> <p>\u00c9crire un programme qui lit la taille d'un tableau de cinquante entiers de 8 bytes et assigne \u00e0 chaque \u00e9l\u00e9ment la valeur de son indice.</p> Solution <pre><code>int8_t a[50];\nfor (size_t i = 0; i &lt; sizeof(a) / sizeof(a[0]; i++) {\n    a[i] = i;\n}\n</code></pre> <p>Exercise\u2009: Premi\u00e8re position</p> <p>Soit un tableau d'entiers, \u00e9crire une fonction retournant la position de la premi\u00e8re occurrence d'une valeur dans le tableau.</p> <p>Traitez les cas particuliers.</p> <pre><code>int index_of(int *array, size_t size, int search);\n</code></pre> Solution <pre><code>int index_of(int *array, size_t size, int search) {\n    int i = 0;\n    while (i &lt; size &amp;&amp; array[i++] != search);\n    return i == size ? -1 : i;\n}\n</code></pre> <p>Exercise\u2009: D\u00e9clarations de tableaux</p> <p>Consid\u00e9rant les d\u00e9clarations suivantes\u2009:</p> <pre><code>#define LIMIT 10\nconst int twelve = 12;\nint i = 3;\n</code></pre> <p>Indiquez si les d\u00e9clarations suivantes (qui n'ont aucun lien entre elles), sont correctes ou non.</p> <pre><code>int t(3);\nint k, t[3], l;\nint i[3], l = 2;\nint t[LIMITE];\nint t[i];\nint t[douze];\nint t[LIMITE + 3];\nfloat t[3, /* five */ 5];\nfloat t[3]        [5];\n</code></pre> <p>Exercise\u2009: Comparaisons</p> <p>Soit deux tableaux <code>char u[]</code> et <code>char v[]</code>, \u00e9crire une fonction comparant leur contenu et retournant\u2009:</p> <p><code>0</code>     La somme des deux tableaux est \u00e9gale.</p> <p><code>-1</code>     La somme du tableau de gauche est plus petite que le tableau de droite</p> <p><code>1</code>     La somme du tableau de droite est plus grande que le tableau de gauche</p> <p>Le prototype de la fonction \u00e0 \u00e9crire est\u2009:</p> <pre><code>int comp(char a[], char b[], size_t length);\n</code></pre> Solution <pre><code>int comp(char a[], char b[], size_t length) {\n    int sum_a = 0, sum_b = 0;\n\n    for (size_t i = 0; i &lt; length; i++) {\n        sum_a += a[i];\n        sum_b += b[i];\n    }\n\n    return sum_b - sum_a;\n}\n</code></pre> <p>Exercise\u2009: Le plus grand et le plus petit</p> <p>Dans le canton de Gen\u00e8ve, il existe une tradition ancestrale\u2009: l'Escalade. En comm\u00e9moration de la victoire de la r\u00e9publique protestante sur les troupes du duc de Savoie suite \u00e0 l'attaque lanc\u00e9e contre Gen\u00e8ve dans la nuit du 11 au 12 d\u00e9cembre 1602 (selon le calendrier julien), une traditionnelle marmite en chocolat est bris\u00e9e par l'ain\u00e9 et le cadet apr\u00e8s la r\u00e9citation de la phrase rituelle \u00ab\u2009Ainsi p\u00e9rirent les ennemis de la R\u00e9publique\u2009!\u2009\u00bb.</p> <p>Pour gagner du temps et puisque l'assembl\u00e9e est grande, il vous est demand\u00e9 d'\u00e9crire un programme pour identifier le doyen et le benjamin de l'assistance.</p> <p>Un fichier contenant les ann\u00e9es de naissance de chacun vous est donn\u00e9, il ressemble \u00e0 ceci\u2009:</p> <pre><code>1931\n1986\n1996\n1981\n1979\n1999\n2004\n1978\n1964\n</code></pre> <p>Votre programme sera ex\u00e9cut\u00e9 comme suit\u2009:</p> <pre><code>$ cat years.txt | marmite\n2004\n1931\n</code></pre> <p>Exercise\u2009: L'index magique</p> <p>Un indice magique d'un tableau <code>A[0..n-1]</code> est d\u00e9fini tel que la valeur <code>A[i] == i</code>. \u00c9tant donn\u00e9 que le tableau est tri\u00e9 avec des entiers distincts (sans r\u00e9p\u00e9tition), \u00e9crire une m\u00e9thode pour trouver un indice magique s'il existe.</p> <p>Exemple\u2009:</p> <pre><code>    0   1   2   3   4   5   6   7   8   9   10\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n\u2502-90\u2502-33\u2502 -5\u2502 1 \u2502 2 \u2502 4 \u2502 5 \u2502 7 \u2502 10\u2502 12\u2502 14\u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n                                ^\n</code></pre> Solution <p>Une solution triviale consiste \u00e0 it\u00e9rer tous les \u00e9l\u00e9ments jusqu'\u00e0 trouver l'indice magique\u2009:</p> <pre><code>int magic_index(int[] array) {\n    const size_t size = sizeof(array) / sizeof(array[0]);\n\n    size_t i = 0;\n\n    while (i &lt; size &amp;&amp; array[i] != i) i++;\n\n    return i == size ? -1 : i;\n}\n</code></pre> <p>La complexit\u00e9 de cet algorithme est :math\u2009:<code>O(n)</code> or, la donn\u00e9e du probl\u00e8me indique que le tableau est tri\u00e9. Cela veut dire que probablement, cette information n'est pas donn\u00e9e par hasard.</p> <p>Pour mieux se repr\u00e9senter le probl\u00e8me, prenons l'exemple d'un tableau\u2009:</p> <pre><code>    0   1   2   3   4   5   6   7   8   9   10\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n\u2502-90\u2502-33\u2502 -5\u2502 1 \u2502 2 \u2502 4 \u2502 5 \u2502 7 \u2502 10\u2502 12\u2502 14\u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n                                ^\n</code></pre> <p>La premi\u00e8re valeur magique est <code>7</code>. Est-ce qu'une approche dichotomique est possible\u2009?</p> <p>Prenons le milieu du tableau <code>A[5] = 4</code>. Est-ce qu'une valeur magique peut se trouver \u00e0 gauche du tableau\u2009? Dans le cas le plus favorable qui serait\u2009:</p> <pre><code>    0   1   2   3   4\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n\u2502 -1\u2502 0 \u2502 1 \u2502 2 \u2502 3 \u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n</code></pre> <p>On voit qu'il est impossible que la valeur se trouve \u00e0 gauche, car les valeurs dans le tableau sont distinctes et il n'y a pas de r\u00e9p\u00e9titions. La r\u00e8gle que l'on peut poser est <code>A[mid] &lt; mid</code> o\u00f9 <code>mid</code> est la valeur m\u00e9diane.</p> <p>Il est possible de r\u00e9p\u00e9ter cette approche de fa\u00e7on dichotomique\u2009:</p> <pre><code>int magic_index(int[] array) {\n    return _magic_index(array, 0, sizeof(array) / sizeof(array[0]) - 1);\n}\n\nint _magic_index(int[] array, size_t start, size_t end) {\n    if (end &lt; start) return -1;\n    int mid = (start + end) / 2;\n    if (array[mid] == mid) {\n        return mid;\n    } else if (array[mid] &gt; mid) {\n        return _magic_index(array, start, mid - 1);\n    } else {\n        return _magic_index(array, mid + 1, end);\n    }\n}\n</code></pre>"}, {"location": "course-c/25-data-structures/composed-types/#initialisation", "title": "Initialisation", "text": "<p>Lors de la d\u00e9claration d'un tableau, le compilateur r\u00e9serve un espace m\u00e9moire de la taille suffisante pour contenir tous les \u00e9l\u00e9ments du tableau. La d\u00e9claration suivante\u2009:</p> <pre><code>int32_t even[6];\n</code></pre> <p>contiens 6 entiers, chacun d'une taille de 32-bits (4 bytes). L'espace m\u00e9moire r\u00e9serv\u00e9 est donc de 24 bytes.</p> <p>Compte tenu de cette d\u00e9claration, il n'est pas possible de conna\u00eetre la valeur qu'il y a, par exemple, \u00e0 l'indice 4 (<code>even[4]</code>), car ce tableau n'a pas \u00e9t\u00e9 initialis\u00e9 et le contenu m\u00e9moire est non pr\u00e9dictible puisqu'il peut contenir les vestiges d'un ancien programme ayant r\u00e9sid\u00e9 dans cette r\u00e9gion m\u00e9moire auparavant. Pour s'assurer d'un contenu, il faut initialiser le tableau, soit affecter des valeurs pour chaque indice\u2009:</p> <pre><code>int32_t sequence[6];\nsequence[0] = 4;\nsequence[1] = 8;\nsequence[2] = 15;\nsequence[3] = 16;\nsequence[4] = 23;\nsequence[5] = 42;\n</code></pre> <p>Cette \u00e9criture n'est certainement pas la plus optimis\u00e9e, car l'initialisation du tableau n'est pas r\u00e9alis\u00e9e \u00e0 la compilation, mais \u00e0 l'ex\u00e9cution du programme\u2009; et ce seront pas moins de six instructions qui seront n\u00e9cessaires \u00e0 initialiser ce tableau. L'initialisation d'un tableau utilise les accolades\u2009:</p> <pre><code>int32_t sequence[6] = {4, 8, 15, 16, 23, 42};\n</code></pre> <p>Dans cette derni\u00e8re \u00e9criture, il existe une redondance d'information. La partie d'initialisation <code>{4, 8, 15, 16, 23, 42}</code> comporte six \u00e9l\u00e9ments et le tableau est d\u00e9clar\u00e9 avec six \u00e9l\u00e9ments <code>[6]</code>. Pour \u00e9viter une double source de v\u00e9rit\u00e9, il est ici possible d'omettre la taille du tableau\u2009:</p> <pre><code>int32_t sequence[] = {4, 8, 15, 16, 23, 42};\n</code></pre> <p>Notons que dans premier de ces deux cas, si un nombre inf\u00e9rieur \u00e0 6 \u00e9l\u00e9ments est initialis\u00e9, les autres \u00e9l\u00e9ments seront initialis\u00e9s \u00e0 z\u00e9ro</p> <pre><code>int32_t sequence[6] = {4, 8, 15, 16 /* le reste vaudra z\u00e9ro */ };\n</code></pre> <p>Il est \u00e9galement possible d'initialiser un tableau de fa\u00e7on explicite en utilisant une notation plus sp\u00e9cifique\u2009:</p> <pre><code>int32_t sequence[6] = {[0]=4, [1]=8, [2]=15, [3]=16, [4]=23, [5]=42};\n</code></pre> <p>Et naturellement il est possible d'omettre certaines valeurs, lesquelles seront initialis\u00e9es \u00e0 z\u00e9ro par d\u00e9faut. Dans l'exemple suivant, les valeurs aux indices 1 \u00e0 4 vaudront z\u00e9ro.</p> <pre><code>int32_t sequence[6] = {[0]=4, [5]=42};\n</code></pre> <p>Notons que lorsque la notation <code>[]=</code> est utilis\u00e9e, les valeurs qui suivent seront positionn\u00e9es aux indices suivants\u2009:</p> <pre><code>int32_t sequence[6] = {[0]=4, 8, [3]=16, 23, 42};\n</code></pre> <p>Dans l'exemple ci-dessus <code>sequence[2]</code> vaudra z\u00e9ro.</p> <p>Notons qu'un type compos\u00e9 tel qu'un tableau ne peut pas \u00eatre initialis\u00e9 apr\u00e8s sa d\u00e9claration. L'exemple suivant ne fonctionne pas\u2009:</p> <pre><code>int array[10];\n\n// Erreur: l'initialisation tardive n'est pas autoris\u00e9e.\narray = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n</code></pre>"}, {"location": "course-c/25-data-structures/composed-types/#initialisation-a-zero", "title": "Initialisation \u00e0 z\u00e9ro", "text": "<p>Enfin, un sucre syntaxique <code>{0}</code> permet d'initialiser tout un tableau \u00e0 z\u00e9ro. En effet, la valeur 0 est inscrite \u00e0 l'indice z\u00e9ro, les autres valeurs sont par d\u00e9faut initialis\u00e9 \u00e0 z\u00e9ro si non mentionn\u00e9es\u2009:</p> <pre><code>int32_t sequence[6] = {0};\n</code></pre> <p>Cette \u00e9criture est n\u00e9cessaire pour les variables locales, car, nous verrons plus loin les variables globales sont plac\u00e9es dans le segment m\u00e9moire <code>.bss</code> et sont initialis\u00e9es \u00e0 z\u00e9ro au d\u00e9marrage du programme. Toute variable globale est donc initialis\u00e9e \u00e0 z\u00e9ro par d\u00e9faut.</p>"}, {"location": "course-c/25-data-structures/composed-types/#initialisation-a-une-valeur-particuliere", "title": "Initialisation \u00e0 une valeur particuli\u00e8re", "text": "<p>Cette \u00e9criture n'est pas normalis\u00e9e C99, mais est g\u00e9n\u00e9ralement compatible avec la majorit\u00e9 des compilateurs.</p> <pre><code>int array[1024] = { [ 0 ... 1023 ] = -1 };\n</code></pre> <p>En C99, il n'est pas possible d'initialiser un type compos\u00e9 \u00e0 une valeur unique. La mani\u00e8re traditionnelle reste la boucle it\u00e9rative\u2009:</p> <pre><code>for (size_t i = 0; i &lt; sizeof(array)/sizeof(array[0]); ++i)\n    array[i] = -1;\n</code></pre>"}, {"location": "course-c/25-data-structures/composed-types/#tableaux-non-modifiables", "title": "Tableaux non modifiables", "text": "<p>\u00c0 pr\u00e9sent que l'on sait initialiser un tableau, il peut \u00eatre utile de d\u00e9finir un tableau avec un contenu qui n'est pas modifiable. Le mot cl\u00e9 <code>const</code> est utilis\u00e9 \u00e0 cette fin.</p> <pre><code>const int32_t sequence[6] = {4, 8, 15, 16, 23, 42};\nsequence[2] = 12; // Interdit !\n</code></pre> <p>Dans l'exemple ci-dessus, la seconde ligne g\u00e9n\u00e8rera l'erreur suivante\u2009:</p> <pre><code>error: assignment of read-only location \u2018sequence[2]\u2019\n</code></pre> <p>Notons que lors de l'utilisation de pointeurs, il serait possible, de fa\u00e7on d\u00e9tourn\u00e9e, de modifier ce tableau malgr\u00e9 tout\u2009:</p> <pre><code>int *p = sequence;\np[2] = 12;\n</code></pre> <p>Dans ce cas, ce n'est pas une erreur, mais une alerte du compilateur qui survient\u2009:</p> <pre><code>warning: initialization discards \u2018const\u2019 qualifier from pointer\ntarget type [-Wdiscarded-qualifiers]\n</code></pre>"}, {"location": "course-c/25-data-structures/composed-types/#tableaux-multidimensionnels", "title": "Tableaux multidimensionnels", "text": "<p>Il est possible de d\u00e9clarer un tableau \u00e0 plusieurs dimensions. Si par exemple on souhaite d\u00e9finir une grille de jeu du tic-tac-toe ou morpion, il faudra une grille de 3x3.</p> <p>Pour ce faire, il est possible de d\u00e9finir un tableau de 6 \u00e9l\u00e9ments comme vu auparavant, et utiliser un artifice pour adresser les lignes et les colonnes\u2009:</p> <pre><code>char game[6] = {0};\nint row = 1;\nint col = 2;\ngame[row * 3 + col] = 'x';\n</code></pre> <p>N\u00e9anmoins, cette \u00e9criture n'est pas pratique et le langage C dispose du n\u00e9cessaire pour all\u00e9ger l'\u00e9criture. La grille de jeu sera simplement initialis\u00e9e comme suit\u2009:</p> <pre><code>char game[3][3] = {0};\n</code></pre> <p>Jouer <code>x</code> au centre \u00e9quivaut \u00e0 \u00e9crire\u2009:</p> <pre><code>game[1][1] = 'x';\n</code></pre> <p>De la m\u00eame fa\u00e7on, il est possible de d\u00e9finir une structure tridimensionnelle\u2009:</p> <pre><code>int volume[10][4][8];\n</code></pre> <p>L'initialisation des tableaux multidimensionnelle est tr\u00e8s similaire aux tableaux standards, mais il est possible d'utiliser plusieurs niveaux d'accolades.</p> <p>Ainsi le jeu de morpion suivant\u2009:</p> <pre><code> o | x | x\n---+---+---\n x | o | o\n---+---+---\n x | o | x\n</code></pre> <p>Peut s'initialiser comme suit\u2009:</p> <pre><code>char game[][3] = {{'o', 'x', 'x'}, {'x', 'o', 'o'}, {'x', 'o', 'x'}};\n</code></pre> <p>Notons que l'\u00e9criture suivante est similaire, car un tableau multidimensionnel est toujours repr\u00e9sent\u00e9 en m\u00e9moire de fa\u00e7on lin\u00e9aire, comme un tableau \u00e0 une dimension\u2009:</p> <pre><code>char game[][3] = {'o', 'x', 'x', 'x', 'o', 'o', 'x', 'o', 'x'};\n</code></pre> <p>Exercise\u2009: D\u00e9tectives priv\u00e9s</p> <p>Voici les d\u00e9penses de service annuelles d'un c\u00e9l\u00e8bre bureau de d\u00e9tectives priv\u00e9s\u2009:</p> Mois Bosley Sabrina Jill Kelly Janvier 414.38 222.72 99.17 153.81 F\u00e9vrier 403.41 390.61 174.39 18.11 Mars 227.55 73.86 291.08 416.55 Avril 220.20 342.25 139.45 86.98 Mai 13.46 172.66 252.33 265.32 Juin 259.37 378.72 173.02 208.43 Juillet 327.06 16.53 391.05 266.84 Ao\u00fbt 50.82 3.37 201.71 170.84 Septembre 450.78 9.33 111.63 337.07 Octobre 434.45 77.80 459.46 479.17 Novembre 420.13 474.69 343.64 273.28 D\u00e9cembre 147.76 250.73 201.47 9.75 <p>Afin de laisser plus de temps aux d\u00e9tectives \u00e0 r\u00e9soudre des affaires, vous \u00eates mandat\u00e9 pour \u00e9crire une fonction qui re\u00e7oit en param\u00e8tre le tableau de r\u00e9els ci-dessus format\u00e9 comme suit\u2009:</p> <pre><code>double accounts[][] = {\n    {414.38, 222.72,  99.17, 153.81, 0},\n    {403.41, 390.61, 174.39, 18.11,  0},\n    {227.55,  73.86, 291.08, 416.55, 0},\n    {220.20, 342.25, 139.45, 86.98,  0},\n    {13.46 , 172.66, 252.33, 265.32, 0},\n    {259.37, 378.72, 173.02, 208.43, 0},\n    {327.06,  16.53, 391.05, 266.84, 0},\n    {50.82 ,   3.37, 201.71, 170.84, 0},\n    {450.78,   9.33, 111.63, 337.07, 0},\n    {434.45,  77.80, 459.46, 479.17, 0},\n    {420.13, 474.69, 343.64, 273.28, 0},\n    {147.76, 250.73, 201.47, 9.75,   0},\n    {  0,      0,      0,    0,      0}\n};\n</code></pre> <p>Et laquelle compl\u00e8te les valeurs manquantes.</p> <p>Exercise\u2009: Pot de peinture</p> <p>\u00c0 l'instar de l'outil pot de peinture des \u00e9diteurs d'image, il vous est demand\u00e9 d'impl\u00e9menter une fonctionnalit\u00e9 similaire.</p> <p>L'image est repr\u00e9sent\u00e9e par un tableau bidimensionnel contenant des couleurs index\u00e9es\u2009:</p> <pre><code>typedef enum { BLACK, RED, PURPLE, BLUE, GREEN YELLOW, WHITE } Color;\n\n#if 0 // Image declaration example\nColor image[100][100];\n#endif\n\nboolean paint(Color* image, size_t rows, size_t cols, Color fill_color);\n</code></pre> <p>Hint</p> <p>Deux approches int\u00e9ressantes sont possibles\u2009: DFS (Depth-First-Search) ou BFS (Breadth-First-Search), toutes deux r\u00e9cursives.</p>"}, {"location": "course-c/25-data-structures/composed-types/#chaines-de-caracteres", "title": "Cha\u00eenes de caract\u00e8res", "text": "<p>Une cha\u00eene de caract\u00e8res est repr\u00e9sent\u00e9e en m\u00e9moire comme une succession de bytes, chacun repr\u00e9sentant un caract\u00e8re ASCII sp\u00e9cifique. La cha\u00eene de caract\u00e8re <code>hello</code> contient donc 5 caract\u00e8res et sera stock\u00e9e en m\u00e9moire sur 5 bytes. Une cha\u00eene de caract\u00e8re est donc \u00e9quivalente \u00e0 un tableau de <code>char</code>.</p> <p>En C, un artifice est utilis\u00e9 pour faciliter les op\u00e9rations sur les cha\u00eenes de caract\u00e8res. Tous les caract\u00e8res de 1 \u00e0 255 sont utilisables sauf le 0 qui est utilis\u00e9 comme sentinelle. Lors de la d\u00e9claration d'une cha\u00eene comme ceci\u2009:</p> <pre><code>char str[] = \"hello, world!\";\n</code></pre> <p>Le compilateur ajoutera automatiquement un caract\u00e8re de terminaison <code>'\\0'</code> \u00e0 la fin de la cha\u00eene. Pour comprendre l'utilit\u00e9, imaginons une fonction qui permet de compter la longueur de la cha\u00eene. Elle aurait comme prototype ceci\u2009:</p> <pre><code>size_t strlen(const char str[]);\n</code></pre> <p>On peut donc lui passer un tableau dont la taille n'est pas d\u00e9finie et par cons\u00e9quent, il n'est pas possible de conna\u00eetre la taille de la cha\u00eene pass\u00e9e sans le b\u00e9n\u00e9fice d'une sentinelle.</p> <pre><code>size_t strlen(const char str[]) {\n    size_t len = 0,\n    while (str[len++] != '\\0') {}\n    return len;\n}\n</code></pre> <p>Une cha\u00eene de caract\u00e8re est donc strictement identique \u00e0 un tableau de <code>char</code>.</p> <p>Ainsi une cha\u00eene de caract\u00e8re est initialis\u00e9e comme suit\u2009:</p> <pre><code>char str[] = \"Pulp Fiction\";\n</code></pre> <p>La taille de ce tableau sera donc de 12 caract\u00e8res plus une sentinelle <code>'\\0'</code> ins\u00e9r\u00e9e automatiquement. Cette \u00e9criture est donc identique \u00e0\u2009:</p> <pre><code>char str[] = {\n    'P', 'u', 'l', 'p', ' ', 'F', 'i', 'c', 't', 'i', 'o', 'n', '\\0'\n};\n</code></pre>"}, {"location": "course-c/25-data-structures/composed-types/#tableaux-de-chaines-de-caracteres", "title": "Tableaux de cha\u00eenes de caract\u00e8res", "text": "<p>Un tableau de cha\u00eene de caract\u00e8res est identique \u00e0 un tableau multidimensionnel\u2009:</p> <pre><code>char conjunctions[][10] = {\n    \"mais\", \"ou\", \"est\", \"donc\", \"or\", \"ni\", \"car\"\n};\n</code></pre> <p>Il est ici n\u00e9cessaire de d\u00e9finir la taille de la seconde dimension, comme pour les tableaux. C'est \u00e0 dire que la variable <code>conjunctions</code> aura une taille de 7x10 caract\u00e8res et le contenu m\u00e9moire de <code>conjunctions[1]</code> sera \u00e9quivalent \u00e0\u2009:</p> <pre><code>{'o', 'u', 0, 0, 0, 0, 0, 0, 0, 0}\n</code></pre> <p>D'ailleurs, ce tableau aurait pu \u00eatre initialis\u00e9 d'une tout autre fa\u00e7on\u2009:</p> <pre><code>char conjunctions[][10] = {\n    'm', 'a', 'i', 's', 0, 0, 0, 0, 0, 0, 'o', 'u', 0, 0, 0,\n    0, 0, 0, 0, 0, 'e', 's', 't', 0, 0, 0, 0, 0, 0 , 0, 'd',\n    'o', 'n', 'c', 0, 0, 0, 0, 0 , 0, 'o', 'r', 0, 0, 0, 0,\n    0, 0, 0, 0, 'n', 'i', 0, 0, 0, 0, 0, 0, 0, 0, 'c', 'a',\n    'r', 0, 0, 0, 0, 0, 0, 0,\n};\n</code></pre> <p>Notons que la valeur <code>0</code> est strictement identique au caract\u00e8re 0 de la table ASCII <code>'\\0'</code>. La cha\u00eene de caract\u00e8re <code>\"mais\"</code> aura une taille de 5 caract\u00e8res, ponctu\u00e9e de la sentinelle <code>\\0</code>.</p>"}, {"location": "course-c/25-data-structures/composed-types/#structures", "title": "Structures", "text": "<p>Les structures sont des d\u00e9clarations sp\u00e9cifiques permettant de regrouper une liste de variables dans un m\u00eame bloc m\u00e9moire et permettant de s'y r\u00e9f\u00e9rer \u00e0 partir d'une r\u00e9f\u00e9rence commune. Historiquement le type <code>struct</code> a \u00e9t\u00e9 d\u00e9riv\u00e9 de <code>ALGOL 68</code>. Il est \u00e9galement utilis\u00e9 en C++ et est similaire \u00e0 une classe.</p> <p>Il faut voir une structure comme un conteneur \u00e0 variables qu'il est possible de v\u00e9hiculer comme un tout.</p> <p>La structure suivante d\u00e9crit un agr\u00e9gat de trois grandeurs scalaires formant un point tridimensionnel\u2009:</p> <pre><code>struct {\n    double x;\n    double y;\n    double z;\n};\n</code></pre> <p>Il ne faut pas confondre l'\u00e9criture ci-dessus avec ceci, dans lequel il y a un bloc de code avec trois variables locales d\u00e9clar\u00e9es\u2009:</p> <pre><code>{\n    double x;\n    double y;\n    double z;\n};\n</code></pre> <p>En utilisant le mot-cl\u00e9 <code>struct</code> devant un bloc, les variables d\u00e9clar\u00e9es au sein de ce bloc ne seront pas r\u00e9serv\u00e9es en m\u00e9moire. Autrement dit, il ne sera pas possible d'acc\u00e9der \u00e0 <code>x</code> puisqu'il n'existe pas de variable <code>x</code>. En revanche, un nouveau conteneur contenant trois variables est d\u00e9fini, mais pas encore d\u00e9clar\u00e9.</p> <p>La structure ainsi d\u00e9clar\u00e9e n'est pas tr\u00e8s utile telle quelle, en revanche elle peut-\u00eatre utilis\u00e9e pour d\u00e9clarer une variable de type <code>struct</code> :</p> <pre><code>struct {\n    double x;\n    double y;\n    double z;\n} point;\n</code></pre> <p>\u00c0 pr\u00e9sent on a d\u00e9clar\u00e9 une variable <code>point</code> de type <code>struct</code> contenant trois \u00e9l\u00e9ments de type <code>double</code>. L'affectation d'une valeur \u00e0 cette variable utilise l'op\u00e9rateur <code>.</code> :</p> <pre><code>point.x = 3060426.957;\npoint.y = 3192003.220;\npoint.z = 4581359.381;\n</code></pre> <p>Comme <code>point</code> n'est pas une primitive standard, mais un conteneur \u00e0 primitive, il n'est pas correct d'\u00e9crire <code>point = 12</code>. Il est essentiel d'indiquer quel \u00e9l\u00e9ment de ce conteneur on souhaite acc\u00e9der.</p> <p>Ces coordonn\u00e9es sont un clin d'\u0153il aux Pierres du Niton qui sont deux blocs de roche erratiques d\u00e9pos\u00e9s par le glacier du Rh\u00f4ne lors de son retrait apr\u00e8s la derni\u00e8re glaciation. Les coordonn\u00e9es sont exprim\u00e9es selon un rep\u00e8re g\u00e9ocentr\u00e9\u2009; l'origine \u00e9tant le centre de la Terre. Ces pierres sont donc situ\u00e9es \u00e0 4.5 km du centre de la Terre, et donc un sacr\u00e9 d\u00e9fi pour Axel Lidenbrock et son fulmicoton.</p>"}, {"location": "course-c/25-data-structures/composed-types/#structures-nommees", "title": "Structures nomm\u00e9es", "text": "<p>L'\u00e9criture que l'on a vue initialement <code>struct { ... };</code> est appel\u00e9e structure anonyme, c'est-\u00e0-dire qu'elle n'a pas de nom. Telle quelle elle ne peut pas \u00eatre utilis\u00e9e et elle ne sert donc pas \u00e0 grand chose. En revanche, il est possible de d\u00e9clarer une variable de ce type en ajoutant un identificateur \u00e0 la fin de la d\u00e9claration <code>struct { ... } nom;</code>. N\u00e9anmoins la structure est toujours anonyme.</p> <p>Le langage C pr\u00e9voit la possibilit\u00e9 de nommer une structure pour une utilisation ult\u00e9rieure en rajoutant un nom apr\u00e8s le mot cl\u00e9 <code>struct</code> :</p> <pre><code>struct Point {\n    double x;\n    double y;\n    double z;\n};\n</code></pre> <p>Pour ne pas confondre un nom de structure avec un nom de variable, on pr\u00e9f\u00e9rera un identificateur en capitales ou en \u00e9criture camel-case. Maintenant qu'elle est nomm\u00e9e, il est possible de d\u00e9clarer plusieurs variables de ce type ailleurs dans le code\u2009:</p> <pre><code>struct Point foo;\nstruct Point bar;\n</code></pre> <p>Dans cet exemple, on d\u00e9clare deux variables <code>foo</code> et <code>bar</code> de type <code>struct Point</code>. Il est donc possible d'acc\u00e9der \u00e0 <code>foo.x</code> ou <code>bar.z</code>.</p> <p>Rien n'emp\u00eache de d\u00e9clarer une structure nomm\u00e9e et d'\u00e9galement d\u00e9clarer une variable par la m\u00eame occasion\u2009:</p> <pre><code>struct Point {\n    double x;\n    double y;\n    double z;\n} foo;\nstruct Point bar;\n</code></pre> <p>Notons que les noms de structures sont stock\u00e9s dans un espace de noms diff\u00e9rent de celui des variables. C'est-\u00e0-dire qu'il n'y a pas de collision possible et qu'un identifiant de fonction ou de variable ne pourra jamais \u00eatre compar\u00e9 \u00e0 un identifiant de structure. Aussi, l'\u00e9criture suivante, bien que perturbante, est tout \u00e0 fait possible\u2009:</p> <pre><code>struct point { double x; double y; double z; };\nstruct point point;\npoint.x = 42;\n</code></pre>"}, {"location": "course-c/25-data-structures/composed-types/#initialisation_1", "title": "Initialisation", "text": "<p>Une structure se comporte \u00e0 peu de chose pr\u00e8s comme un tableau sauf que les \u00e9l\u00e9ments de la structure ne s'acc\u00e8dent pas avec l'op\u00e9rateur crochet, <code>[]</code> mais avec l'op\u00e9rateur <code>.</code>. N\u00e9anmoins une structure est repr\u00e9sent\u00e9e en m\u00e9moire comme un contenu lin\u00e9aire. Notre structure <code>struct Point</code> serait identique \u00e0 un tableau de trois <code>double</code> et par cons\u00e9quent l'initialisation suivante est possible\u2009:</p> <pre><code>struct Point point = { 3060426.957, 3192003.220, 4581359.381 };\n</code></pre> <p>N\u00e9anmoins on pr\u00e9f\u00e8rera la notation suivante, \u00e9quivalente\u2009:</p> <pre><code>struct Point point = { .x=3060426.957, .y=3192003.220, .z=4581359.381 };\n</code></pre> <p>Comme pour un tableau, les valeurs omises sont initialis\u00e9es \u00e0 z\u00e9ro. Et de la m\u00eame mani\u00e8re qu'un tableau, il est possible d'initialiser une structure \u00e0 z\u00e9ro avec <code>= {0};</code>.</p> <p>Il faut savoir que C99 restreint l'ordre dans lequel les \u00e9l\u00e9ments peuvent \u00eatre initialis\u00e9s. Ce dernier doit \u00eatre l'ordre dans lequel les variables sont d\u00e9clar\u00e9es dans la structure.</p> <p>Notons que des structures comportant des types diff\u00e9rents peuvent aussi \u00eatre initialis\u00e9es de la m\u00eame mani\u00e8re\u2009:</p> <pre><code>struct Product {\n    int weight; // Grams\n    double price; // Swiss francs\n    int category;\n    char name[64];\n}\n\nstruct Product apple = {321, 0.75, 24, \"Pomme Golden\"};\n</code></pre>"}, {"location": "course-c/25-data-structures/composed-types/#tableaux-de-structures", "title": "Tableaux de structures", "text": "<p>Une structure est un type comme un autre. Tout ce qui peut \u00eatre fait avec <code>char</code> ou <code>double</code> peut donc \u00eatre fait avec <code>struct</code>. Et donc, il est aussi possible de d\u00e9clarer un tableau de structures. Ici, donnons l'exemple d'un tableau de points initialis\u00e9s\u2009:</p> <pre><code>struct Point points[3] = {\n    {.x=1, .y=2, .z=3},\n    {.z=1, .x=2, .y=3},\n    {.y=1}\n};\n</code></pre> <p>Assigner une nouvelle valeur \u00e0 un point est facile\u2009:</p> <pre><code>point[2].x = 12;\n</code></pre>"}, {"location": "course-c/25-data-structures/composed-types/#structures-en-parametres", "title": "Structures en param\u00e8tres", "text": "<p>L'int\u00e9r\u00eat d'une structure est de pouvoir passer ou retourner un ensemble de donn\u00e9es \u00e0 une fonction. On a vu qu'une fonction ne permet de retourner qu'une seule primitive. Une structure est ici consid\u00e9r\u00e9e comme un seul conteneur et l'\u00e9criture suivante est possible\u2009:</p> <pre><code>struct Point generate_point(void) {\n    struct Point p = {\n        .x = rand(),\n        .y = rand(),\n        .z = rand()\n    };\n\n    return p;\n}\n</code></pre> <p>Il est \u00e9galement possible de passer une structure en param\u00e8tre d'une fonction\u2009:</p> <pre><code>double norm(struct point p) {\n    return sqrt(p.x * p.x + p.y * p.y + p.z * p.z);\n}\n\nint main(void) {\n    struct Point p = { .x = 12.54, .y = -8.12, .z = 0.68 };\n\n    double n = norm(p);\n}\n</code></pre> <p>Contrairement aux tableaux, les structures sont toujours pass\u00e9es par valeur, c'est-\u00e0-dire que l'entier du contenu de la structure sera copi\u00e9 sur la pile (stack) en cas d'appel \u00e0 une fonction. En revanche, en cas de passage par pointeur, seule l'adresse de la structure est pass\u00e9e \u00e0 la fonction appel\u00e9e qui peut d\u00e8s lors modifier le contenu\u2009:</p> <pre><code>struct Point {\n    double x;\n    double y;\n};\n\nvoid foo(struct Point m, struct Point *n) {\n    m.x++;\n    n-&gt;x++;\n}\n\nint main(void) {\n    struct Point p = {0}, q = {0};\n    foo(p, &amp;q);\n    printf(\"%g, %g\\n\", p.x, q.x);\n}\n</code></pre> <p>Le r\u00e9sultat affich\u00e9 sera <code>0.0, 1.0</code>. Seule la seconde valeur est modifi\u00e9e.</p> <p>Hint</p> <p>Lorsqu'un membre d'une structure est acc\u00e9d\u00e9, via son pointeur, on utilise la notation <code>-&gt;</code> au lieu de <code>.</code> car il est n\u00e9cessaire de d\u00e9r\u00e9f\u00e9rencer le pointeur. Il s'agit d'un sucre syntaxique permettant d'\u00e9crire <code>p-&gt;x</code> au lieu de <code>(*p).x</code></p>"}, {"location": "course-c/25-data-structures/composed-types/#structures-flexibles", "title": "Structures flexibles", "text": "<p>Introduits avec C99, les membres de structures flexibles ou flexible array members (\u00a76.7.2.1) est un membre de type tableau d'une structure d\u00e9fini sans dimension. Ces membres ne peuvent appara\u00eetre qu'\u00e0 la fin d'une structure.</p> <pre><code>struct Vector {\n    char name[16]; // name of the vector\n    size_t len; // length of the vector\n    double array[]; // flexible array member\n};\n</code></pre> <p>Cette \u00e9criture permet par exemple de r\u00e9server un espace m\u00e9moire plus grand que la structure de base, et d'utiliser le reste de l'espace comme tableau flexible.</p> <pre><code>struct Vector *vector = malloc(1024);\nstrcpy(vector-&gt;name, \"Mon vecteur\");\nvector-&gt;len = 1024 - 16 - 4;\nfor (int i = 0; i &lt; vector-&gt;len; i++)\n    vector-&gt;array[i] = ...\n</code></pre> <p>Ce type d'\u00e9criture est souvent utilis\u00e9 pour des contenus ayant un en-t\u00eate fixe comme des images BMP ou des fichiers sons WAVE.</p>"}, {"location": "course-c/25-data-structures/composed-types/#structure-de-structures", "title": "Structure de structures", "text": "<p>On comprend ais\u00e9ment que l'avantage des structures et le regroupement de variables. Une structure peut \u00eatre la composition d'autres types composites.</p> <p>Nous d\u00e9clarons ici une structure <code>struct Line</code> compos\u00e9e de <code>struct Point</code> :</p> <pre><code>struct Line {\n    struct Point a;\n    struct Point b;\n};\n</code></pre> <p>L'acc\u00e8s \u00e0 ces diff\u00e9rentes valeurs s'effectue de la fa\u00e7on suivante\u2009:</p> <pre><code>struct Line line = {.a.x = 23, .a.y = 12, .b.z = 33};\nprintf(\"%g, %g\", line.a.x, line.b.x);\n</code></pre>"}, {"location": "course-c/25-data-structures/composed-types/#alignement-memoire", "title": "Alignement m\u00e9moire", "text": "<p>Une structure est agenc\u00e9e en m\u00e9moire dans l'ordre de sa d\u00e9claration. C'est donc un agencement lin\u00e9aire en m\u00e9moire\u2009:</p> <pre><code>struct Line lines[2]; // Chaque point est un double, cod\u00e9 sur 8 bytes.\n</code></pre> <p>Ci-dessous est repr\u00e9sent\u00e9 l'offset m\u00e9moire (en bytes) \u00e0 laquelle est stock\u00e9 chaque membre de la structure, ainsi que l'\u00e9l\u00e9ment correspondant.</p> <pre><code>0x0000 line[0].a.x\n0x0008 line[0].a.y\n0x0010 line[0].a.z\n0x0018 line[0].b.x\n0x0020 line[0].b.y\n0x0028 line[0].b.z\n0x0030 line[1].a.x\n0x0038 line[1].a.y\n0x0040 line[1].a.z\n0x0048 line[1].b.x\n0x0050 line[1].b.y\n0x0048 line[1].b.z\n</code></pre> <p>N\u00e9anmoins dans certains cas, le compilateur se r\u00e9serve le droit d'optimiser l' alignement m\u00e9moire. Une architecture 32-bits aura plus de facilit\u00e9 \u00e0 acc\u00e9der \u00e0 des grandeurs de 32 bits or, une structure compos\u00e9e de plusieurs entiers 8-bits demanderait au processeur un co\u00fbt additionnel pour optimiser le stockage d'information. Consid\u00e9rons par exemple la structure suivante\u2009:</p> <pre><code>struct NoAlign\n{\n    int8_t c;\n    int32_t d;\n    int64_t i;\n    int8_t a[3];\n};\n</code></pre> <p>Imaginons pour comprendre qu'un casier m\u00e9moire sur une architecture 32-bits est assez grand pour y stocker 4 bytes. Tentons de repr\u00e9senter en m\u00e9moire cette structure en little-endian, en consid\u00e9rant des casiers de 32-bits\u2009:</p> <pre><code> c    d             i           a\n\u251e\u2500\u2540\u2500\u252c\u2500\u252c\u2500\u2510 \u250c\u2500\u2540\u2500\u252c\u2500\u252c\u2500\u2510 \u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510 \u250c\u2500\u2540\u2500\u252c\u2500\u252c\u2500\u2510\n\u2502c\u2502d\u2502d\u2502d\u2502 \u2502d\u2502i\u2502i\u2502i\u2502 \u2502i\u2502i\u2502i\u2502i\u2502 \u2502i\u2502a\u2502a\u2502a\u2502\n\u25020\u25020\u25021\u25022\u2502 \u25023\u25020\u25021\u25022\u2502 \u25023\u25024\u25025\u25026\u2502 \u25027\u25020\u25021\u25022\u2502\n\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518 \u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518 \u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518 \u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n    A         B         C         D\n</code></pre> <p>On constate que la valeur <code>d</code> est \u00e0 cheval entre deux casiers. De m\u00eame que la valeur <code>i</code> est r\u00e9partie sur trois casiers au lieu de deux. Le processeur communique avec la m\u00e9moire en  utilisant des bus m\u00e9moire, ils sont l'analogie d'une autoroute qui ne peut accueillir que des voitures, chacune ne pouvant transporter que 4 passagers. Un passager ne peut pas arpenter l'autoroute sans voiture. Le processeur est la gare de triage et s'occupe de r\u00e9assembler les passagers, et l'op\u00e9ration consistant \u00e0 demander \u00e0 un passager de sortir de la voiture <code>B</code> pour s'installer dans une autre, ou m\u00eame se d\u00e9placer de la place du conducteur \u00e0 la place du passager arri\u00e8re prend du temps.</p> <p>Le compilateur sera donc oblig\u00e9 de faire du z\u00e8le pour acc\u00e9der \u00e0 d. formellement l'acc\u00e8s \u00e0 <code>d</code> pourrait s'\u00e9crire ainsi\u2009:</p> <pre><code>int32_t d = (data[0] &lt;&lt; 8) | (data[1] &amp; 0x0F);\n</code></pre> <p>Pour \u00e9viter ces man\u0153uvres, le compilateur, selon l'architecture donn\u00e9e, va ins\u00e9rer des \u00e9l\u00e9ments de rembourrage (padding) pour forcer l'alignement m\u00e9moire et ainsi optimiser les lectures. La m\u00eame structure que ci-dessus sera fort probablement impl\u00e9ment\u00e9e de la fa\u00e7on suivante\u2009:</p> <pre><code>struct Align\n{\n    int8_t c;\n    int8_t __pad1[3]; // Ins\u00e9r\u00e9 par le compilateur\n    int32_t d;\n    int64_t i;\n    int8_t a[3];\n    int8_t __pad2; // Ins\u00e9r\u00e9 par le compilateur\n};\n</code></pre> <p>En reprenant notre analogie de voitures, le stockage est maintenant fait comme ceci\u2009:</p> <pre><code>\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510 \u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510 \u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510 \u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510 \u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\n\u2502c\u2502 \u2502 \u2502 \u2502 \u2502d\u2502d\u2502d\u2502d\u2502 \u2502i\u2502i\u2502i\u2502i\u2502 \u2502i\u2502i\u2502i\u2502i\u2502 \u2502a\u2502a\u2502a\u2502 \u2502\n\u25020\u2502 \u2502 \u2502 \u2502 \u25020\u25021\u25022\u25023\u2502 \u25020\u25021\u25022\u25023\u2502 \u25024\u25025\u25026\u25027\u2502 \u25020\u25021\u25022\u2502 \u2502\n\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518 \u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518 \u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518 \u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518 \u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n    A         B         C         D         E\n</code></pre> <p>Le compromis est qu'une voiture suppl\u00e9mentaire est n\u00e9cessaire, mais le processeur n'a plus besoin de r\u00e9agencer les passagers. L'acc\u00e8s \u00e0 <code>d</code> est ainsi facilit\u00e9 au d\u00e9triment d'une perte substantielle de l'espace de stockage.</p> <p>Ceci \u00e9tant, en changeant l'ordre des \u00e9l\u00e9ments dans la structure pour que chaque membre soit align\u00e9 sur 32-bits, il est possible d'obtenir un meilleur compromis\u2009:</p> <pre><code>struct Align\n{\n    int32_t d;\n    int64_t i;\n    int8_t a[3];\n    int8_t c;\n};\n</code></pre> <pre><code>\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510 \u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510 \u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510 \u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\n\u2502d\u2502d\u2502d\u2502d\u2502 \u2502i\u2502i\u2502i\u2502i\u2502 \u2502i\u2502i\u2502i\u2502i\u2502 \u2502a\u2502a\u2502a\u2502c\u2502\n\u25020\u25021\u25022\u25023\u2502 \u25020\u25021\u25022\u25023\u2502 \u25024\u25025\u25026\u25027\u2502 \u25020\u25021\u25022\u25023\u2502\n\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518 \u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518 \u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518 \u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n    A         B         C         D\n</code></pre> <p>L'option <code>-Wpadded</code> de GCC permet de lever une alerte lorsqu'une structure est align\u00e9e par le compilateur. Si l'on utilise par exemple une structure pour \u00e9crire un fichier binaire respectant un format pr\u00e9cis par exemple l'en-t\u00eate d'un fichier BMP. Et que cette structure <code>BitmapFileHeader</code> est enregistr\u00e9e avec <code>fwrite(header, sizeof(BitmapFileHeader), ...)</code>. Si le compilateur rajoute des \u00e9l\u00e9ments de rembourrage, le fichier BMP serait alors compromis. Il faudrait donc consid\u00e9rer l'alerte <code>Wpadded</code> comme une erreur critique.</p> <p>Pour pallier \u00e0 ce probl\u00e8me, lorsqu'une structure m\u00e9moire doit \u00eatre respect\u00e9e dans un ordre pr\u00e9cis. Une option de compilation non standard existe. La directive <code>#pragma pack</code> permet de forcer un type d'alignement pour une certaine structure. Consid\u00e9rons par exemple la structure suivante\u2009:</p> <pre><code>struct Test\n{\n    char a;\n    int b;\n    char c;\n};\n</code></pre> <p>Elle serait tr\u00e8s probablement repr\u00e9sent\u00e9e en m\u00e9moire de la fa\u00e7on suivante\u2009:</p> <pre><code>\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510 \u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510 \u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\n\u2502a\u2502 \u2502 \u2502 \u2502 \u2502b\u2502b\u2502b\u2502b\u2502 \u2502c\u2502 \u2502 \u2502 \u2502\n\u25020\u2502 \u2502 \u2502 \u2502 \u25020\u25021\u25022\u25023\u2502 \u25020\u2502 \u2502 \u2502 \u2502\n\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518 \u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518 \u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n    A         B         C\n</code></pre> <p>En revanche si elle est d\u00e9crite en utilisant un packing sur 8-bits, avec <code>#pragma pack(1)</code> on aura l'alignement m\u00e9moire suivant\u2009:</p> <pre><code>\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510 \u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\n\u2502a\u2502b\u2502b\u2502b\u2502 \u2502b\u2502c\u2502 \u2502 \u2502\n\u25020\u25020\u25021\u25022\u2502 \u25023\u25021\u2502 \u2502 \u2502\n\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518 \u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n    A         B\n</code></pre>"}, {"location": "course-c/25-data-structures/composed-types/#champs-de-bits", "title": "Champs de bits", "text": "<p>Les champs de bits sont des structures dont une information suppl\u00e9mentaire est ajout\u00e9e\u2009: le nombre de bits utilis\u00e9s.</p> <p>Prenons l'exemple du module I2C du microcontr\u00f4leur TMS320F28335. Le registre <code>I2CMDR</code> d\u00e9crit \u00e0 la page 23 est un registre 16-bits qu'il conviendrait de d\u00e9crire avec un champ de bits\u2009:</p> <pre><code>struct I2CMDR {\n    int  bc  :3;\n    bool fdf :1;\n    bool stb :1;\n    bool irs :1;\n    bool dlb :1;\n    bool rm  :1;\n    bool xa  :1;\n    bool trx :1;\n    bool mst :1;\n    bool stp :1;\n    bool _reserved :1;\n    bool stt  :1;\n    bool free :1;\n    bool nackmod :1;\n};\n</code></pre> <p>Activer le bit <code>stp</code> (bit num\u00e9ro 12) devient une op\u00e9ration triviale\u2009:</p> <pre><code>struct I2CMDR i2cmdr;\n\ni2cmdr.stp = true;\n</code></pre> <p>Alors qu'elle demanderait une manipulation de bit sinon\u2009:</p> <pre><code>int32_t i2cmdr;\n\ni2cmdr |= 1 &lt;&lt; 12;\n</code></pre> <p>Notons que les champs de bits, ainsi que les structures seront d\u00e9clar\u00e9s diff\u00e9remment selon que l'architecture cible est little-endian ou big-endian.</p>"}, {"location": "course-c/25-data-structures/composed-types/#unions", "title": "Unions", "text": "<p>Une union est une variable qui peut avoir plusieurs repr\u00e9sentations d'un m\u00eame contenu m\u00e9moire. Rappelez-vous, nous nous demandions quelle \u00e9tait l'interpr\u00e9tation d'un contenu m\u00e9moire donn\u00e9. Il est possible en C d'avoir toutes les interpr\u00e9tations \u00e0 la fois\u2009:</p> <pre><code>#include &lt;stdint.h&gt;\n#include &lt;stdio.h&gt;\n\nunion Mixed\n{\n    int32_t signed32;\n    uint32_t unsigned32;\n    int8_t signed8[4];\n    int16_t signed16[2];\n    float float32;\n};\n\nint main(void) {\n    union Mixed m = {\n        .signed8 = {0b11011011, 0b0100100, 0b01001001, 0b01000000}\n    };\n\n    printf(\n        \"int32_t\\t%d\\n\"\n        \"uint32_t\\t%u\\n\"\n        \"char\\t%c, %c, %c, %c\\n\"\n        \"short\\t%hu, %hu\\n\"\n        \"float\\t%f\\n\",\n        m.signed32,\n        m.unsigned32,\n        m.signed8[0], m.signed8[1], m.signed8[2], m.signed8[3],\n        m.signed16[0], m.signed16[1],\n        m.float32\n    );\n}\n</code></pre> <p>Les unions sont tr\u00e8s utilis\u00e9es en combinaison avec des champs de bits. Pour reprendre l'exemple du champ de bit \u00e9voqu\u00e9 plus haut, on peut souhaiter acc\u00e9der au registre soit sous la forme d'un entier 16-bits soit via chacun de ses bits ind\u00e9pendamment.</p> <pre><code>union i2cmdr {\n    struct {\n        int  bc  :3;\n        bool fdf :1;\n        bool stb :1;\n        bool irs :1;\n        bool dlb :1;\n        bool rm  :1;\n        bool xa  :1;\n        bool trx :1;\n        bool mst :1;\n        bool stp :1;\n        bool _reserved :1;\n        bool stt  :1;\n        bool free :1;\n        bool nackmod :1;\n    } bits;\n    uint16_t all;\n};\n</code></pre>"}, {"location": "course-c/25-data-structures/composed-types/#creation-de-types", "title": "Cr\u00e9ation de types", "text": "<p>Le mot cl\u00e9 <code>typedef</code> permet de d\u00e9clarer un nouveau type. Il est particuli\u00e8rement utilis\u00e9 conjointement avec les structures et les unions afin de s'affranchir de la lourdeur d'\u00e9criture (pr\u00e9fixe <code>struct</code>), et dans le but de cacher la complexit\u00e9 d'un type \u00e0 l'utilisateur qui le manipule.</p> <p>L'exemple suivant d\u00e9clare un type <code>Point</code> et un prototype de fonction permettant l'addition de deux points.</p> <pre><code>typedef struct {\n    double x;\n    double y;\n} Point;\n\nPoint add(Point a, Point b);\n</code></pre>"}, {"location": "course-c/25-data-structures/composed-types/#compound-literals", "title": "Compound Literals", "text": "<p>Na\u00efvement traduit en litt\u00e9raux compos\u00e9s, un compound literal est une m\u00e9thode de cr\u00e9ation d'un type compos\u00e9 \u00ab\u2009\u00e0 la vol\u00e9e\u2009\u00bb utilis\u00e9 de la m\u00eame fa\u00e7on que les transtypages.</p> <p>Reprenons notre structure Point <code>struct Point</code> vue plus haut. Si l'on souhaite changer la valeur du point <code>p</code> il faudrait on pourrait \u00e9crire ceci\u2009:</p> <pre><code>struct Point p; // D\u00e9clar\u00e9 plus haut\n\n// ...\n\n{\n    struct Point q = {.x=1, .y=2, .z=3};\n    p = q;\n}\n</code></pre> <p>Notons que passer par une variable interm\u00e9diaire <code>q</code> n'est pas tr\u00e8s utile. Il serait pr\u00e9f\u00e9rable d'\u00e9crire ceci\u2009:</p> <pre><code>p = {.x=1, .y=2, .z=3};\n</code></pre> <p>N\u00e9anmoins cette \u00e9criture m\u00e8nera \u00e0 une erreur de compilation, car le compilateur cherchera \u00e0 d\u00e9terminer le type de l'expression <code>{.x=1, .y=2, .z=3}</code>. Il est alors essentiel d'utiliser la notation suivante\u2009:</p> <pre><code>p = (struct Point){.x=1, .y=2, .z=3};\n</code></pre> <p>Cette notation de litt\u00e9raux compos\u00e9s peut \u00e9galement s'appliquer aux tableaux. L'exemple suivant montre l'initialisation d'un tableau \u00e0 la vol\u00e9e pass\u00e9 \u00e0 la fonction <code>foo</code> :</p> <pre><code>void foo(int array[3]) {\n    for (int i = 0; i &lt; 3; i++) printf(\"%d \", array[i]);\n}\n\nvoid main() {\n    foo((int []){1,2,3});\n}\n</code></pre> <p>Exercise\u2009: Mendele\u00efev</p> <p>Chaque \u00e9l\u00e9ment du tableau p\u00e9riodique des \u00e9l\u00e9ments comporte les propri\u00e9t\u00e9s suivantes\u2009:</p> <ul> <li>Un nom jusqu'\u00e0 20 lettres</li> <li>Un symbole jusqu'\u00e0 2 lettres</li> <li>Un num\u00e9ro atomique de 1 \u00e0 118 (2019)</li> <li> <p>Le type de l'\u00e9l\u00e9ment</p> <ul> <li>M\u00e9taux (Alcalin, Alcalino-terreux, Lanthanides, Actinides, M\u00e9taux de transition, M\u00e9taux pauvres)</li> <li>M\u00e9tallo\u00efdes</li> <li>Non-m\u00e9taux (Autres, Halog\u00e8ne, Gaz noble)</li> </ul> </li> <li> <p>La p\u00e9riode\u2009: un entier de 1 \u00e0 7</p> </li> <li>Le groupe\u2009: un entier de 1 \u00e0 18</li> </ul> <p>D\u00e9clarer une structure de donn\u00e9es permettant de stocker tous les \u00e9l\u00e9ments chimiques de telle fa\u00e7on qu'ils puissent \u00eatre acc\u00e9d\u00e9s comme\u2009:</p> <pre><code>assert(strcmp(table.element[6].name, \"Helium\") == 0);\nassert(strcmp(table.element[54].type, \"Gaz noble\") == 0);\nassert(table.element[11].period == 3);\n\nElement *el = table.element[92];\nassert(el-&gt;atomic_weight == 92);\n</code></pre>"}, {"location": "course-c/25-data-structures/pointers/", "title": "Pointers", "text": ""}, {"location": "course-c/25-data-structures/pointers/#pointeurs", "title": "Pointeurs", "text": "<p>Attention les v\u00e9los, on s'attaque \u00e0 un sujet d\u00e9licat, difficile, scabreux, mais n\u00e9cessaire. Un sujet essentiel, indispensable et fantastique\u2009: les pointeurs.</p> <p>Les pointeurs sont des variables qui, au lieu de stocker une valeur, stockent une adresse m\u00e9moire. Dans quel but me direz-vous\u2009? Pour cr\u00e9er des indirections, simplifier l'ex\u00e9cution du code.</p> <p>Prenons un exemple concret. Le Vicomte de Valmont d\u00e9cide d'\u00e9crire \u00e0 la marquise de Merteuil et il r\u00e9dige une lettre. Il cachette sa lettre et la d\u00e9pose dans sa bo\u00eete aux lettres pour enl\u00e8vement par le facteur moyennant quelques sous. En des termes programmatiques, on a\u2009:</p> <pre><code>char lettre[] = \"Ch\u00e8re Marquise, ...\";\n</code></pre> <p>Cette variable <code>lettre</code> est d\u00e8s lors enregistr\u00e9e en m\u00e9moire \u00e0 l'adresse <code>0x12345abc</code> qui pourrait correspondre \u00e0 l'emplacement de la bo\u00eete aux lettres du Vicomte.</p> <p>Le facteur qui ne craint pas la besogne prend connaissance du courrier \u00e0 livrer, mais constate avec effroi que le cachet de cire a fondu sous l'effet du r\u00e9chauffement climatique. La lettre est coll\u00e9e au fond de la bo\u00eete et il ne parvient pas \u00e0 la d\u00e9tacher. Pire encore, et ajoutant \u00e0 la situation d\u00e9j\u00e0 cocasse un dramatisme sans \u00e9quivoque, \u00e0 forcer de ses maigres doigts le papier de l'enveloppe se d\u00e9chire et le contenu de lettre ind\u00e9collable lui est r\u00e9v\u00e9l\u00e9e.</p> <p>Je l'admets volontiers, il me faut bien faire quelques pirouettes pour justifier qu'une valeur en m\u00e9moire ne peut \u00eatre transport\u00e9e d'un lieu \u00e0 un autre \u00e0 simple dos de facteur. Aussi, notre facteur qui est si bon, mais qui n'a plus la m\u00e9moire de sa jeunesse, ni papier d'ailleurs, d\u00e9cide de m\u00e9moriser la lettre et de la retranscrire chez madame la Marquise qu'il conna\u00eet bien. Or comme il est atteint de la maladie de 64-bits il n'arrive \u00e0 m\u00e9moriser que 8 caract\u00e8res <code>Ch\u00e8re Ma</code>. Sur son bolide, il arrive \u00e0 destination et retranscrit dans le fond de la bo\u00eete de madame de Merteuil les huit caract\u00e8res fid\u00e8lement retranscrits. Comme il est bonnet, mais assidu, il consacre le restant de sa journ\u00e9e en des allers-retours usant la gomme de son tout nickel\u00e9 jusqu'\u00e0 ce que toute la lettre ait \u00e9t\u00e9 retranscrite.</p> <p>On se retrouve avec une copie de la lettre chez madame de Merteuil\u2009:</p> <pre><code>char valmont_mailbox[] = \"Ch\u00e8re Maquise, ...\";\nchar merteil_mailbox[] = \"Ch\u00e8re Maquise, ...\";\n</code></pre> <p>La canicule n'\u00e9tant pas finie, et cette physique discutable ne pouvant \u00eatre d\u00e9jou\u00e9es, la marquise d\u00e9cide de r\u00e9soudre le probl\u00e8me et se rend \u00e0 Tarente (un tr\u00e8s mauvais choix par jour de canicule) et formule sa r\u00e9ponse sur le mur sud du Castello Aragonese ayant pr\u00e9alablement pris soin de noter la position GPS du mur avec exactitude (<code>0x30313233</code>):</p> <pre><code>char castello_wall[] = \"Cher Vicomte ...\";\nchar (*gps_position)[] = &amp;castello_wall;\n</code></pre> <p>De retour chez elle, elle prie le facteur de transmettre au vicomte de Valmont ce simple mot\u2009: <code>0x30313233</code>. Le facteur parvient sans mal \u00e0 m\u00e9moriser les 4 octets du message.</p> <p>La variable <code>gps_position</code> ne contient donc pas le message, mais seulement l'adresse m\u00e9moire de ce message. Il s'agit ici d'un pointeur sur un tableau de caract\u00e8res.</p> <p>Entre-temps, le vicomte qui est paresseux s'est \u00e9quip\u00e9 d'un t\u00e9l\u00e9scripteur capable d'ex\u00e9cuter du code C et il parvient \u00e0 lire le message de sa complice la marquise.</p> <pre><code>printf(\"%s\", *gps_position);\n</code></pre> <p>S'il avait oubli\u00e9 l'ast\u00e9risque (<code>*</code>, 002A) dans cette derni\u00e8re ligne, il n'aurait pas vu le message esp\u00e9r\u00e9, mais simplement <code>0123</code> qui correspond au contenu \u00e0 l'adresse m\u00e9moire ou se trouve l'adresse du message (et non le message).</p> <p>L'ast\u00e9risque agit donc comme un d\u00e9r\u00e9f\u00e9rencement, autrement dit, la demande expresse faite au d\u00e9vou\u00e9 facteur d'aller \u00e0 l'adresse donn\u00e9e r\u00e9cup\u00e9rer le contenu du message.</p> <p>Oui, mais, on utilise un ast\u00e9risque pour d\u00e9r\u00e9f\u00e9rencer, mais dans l'exemple pr\u00e9c\u00e9dant on a utilis\u00e9 l'esperluette (<code>&amp;</code>, 0026): <code>&amp;castello_wall</code>, pourquoi\u2009? L'esperluette quand elle pr\u00e9fixe une variable peut \u00eatre traduite par l'adresse de. Cela revient \u00e0 l'\u00e9tape pendant laquelle la marquise a mesur\u00e9 la position GPS du mur sur \u00e0 Tarente.</p> <p>Il manque encore une chose, il y a aussi une ast\u00e9risque sur <code>(*gps_position)[]</code>. Cela vaudrait-il dire qu\u2019on d\u00e9r\u00e9f\u00e9rence la position GPS pour affecter l'adresse du mur\u2009? Non, pas du tout... Et c'est d'ailleurs \u00e0 cette \u00e9tape que les novices perdent le fil. O\u00f9 en \u00e9tais-je\u2009?</p> <p>Notons qu'il y a plusieurs interpr\u00e9tations de l'ast\u00e9risque en C\u2009:</p> <ul> <li>Op\u00e9rateur de multiplication\u2009: <code>a * b</code></li> <li>D\u00e9r\u00e9f\u00e9rencement d'un pointeur\u2009: <code>*ptr</code></li> <li>D\u00e9claration d'un pointeur\u2009: <code>int * ptr</code></li> </ul> <p>Donc ici, on d\u00e9clare un pointeur. En appliquant la r\u00e8gle gauche-droite que l'on verra plus bas\u2009:</p> <pre><code>char (*gps_position)[]\n       ^^^^^^^^^^^^        1. gps_position est\n                   ^       2. ...\n      ^                    3. un pointeur sur\n                    ^^     4. un tableau de\n^^^^                       5. caract\u00e8res\n                           6. PROFIT...\n</code></pre> <p>R\u00e9sumons\u2009:</p> <ul> <li>Un pointeur est une variable</li> <li>Il contient une adresse m\u00e9moire</li> <li>Il peut \u00eatre d\u00e9r\u00e9f\u00e9renc\u00e9 pour en obtenir la valeur de l'\u00e9l\u00e9ment qu'il pointe</li> <li>L'adresse d'une variable peut \u00eatre obtenue avec une esperluette</li> </ul>"}, {"location": "course-c/25-data-structures/pointers/#pointeur-simple", "title": "Pointeur simple", "text": "<p>Le format le plus simple d'un pointeur sur un entier s'\u00e9crit avec l'ast\u00e9risque <code>*</code>:</p> <pre><code>int* ptr = NULL;\n</code></pre> <p>La valeur <code>NULL</code> correspond \u00e0 l'adresse nulle <code>0x00000000</code>. On utilise cette convention pour bien indiquer qu'il s'agit d'une adresse et non d'une valeur scalaire.</p> <p>nul, null, nulll</p> <p>Attention \u00e0 l'\u00e9criture de <code>NULL</code>:</p> <ul> <li><code>nul</code> est le caract\u00e8re de fin de cha\u00eene de caract\u00e8res <code>'\\0'</code> ;</li> <li><code>null</code> est une adresse qui pointe nulle part\u2009;</li> <li><code>nulll</code> veut dire que vous avez fait une faute de frappe.</li> </ul> <p>\u00c0 tout moment, la valeur du pointeur peut \u00eatre assign\u00e9e \u00e0 l'adresse d'un entier puisque nous avons d\u00e9clar\u00e9 un pointeur sur un entier\u2009:</p> <pre><code>int boiling = 100;\nint freezing = 0;\n\nfor (char i = 0; i &lt; 10; i++) {\n    ptr = i % 2 ? &amp;boiling : &amp;freezing;\n    printf(\"%d\", *ptr);\n}\n</code></pre> <p>Lorsque nous avions vu les tableaux, nous \u00e9crivions\u2009:</p> <pre><code>int array[10] = {0,1,2,3,4,5,6,7,8,9};\n</code></pre> <p>Vous ne le saviez pas, mais \ud834\udd3d plot twist \ud834\udd3d la variable <code>array</code> est un pointeur, et la preuve est que <code>array</code> peut \u00eatre d\u00e9r\u00e9f\u00e9renc\u00e9\u2009:</p> <pre><code>printf(\"%d\", *array); // Affiche 0\n</code></pre> <p>La diff\u00e9rence entre un tableau et un pointeur est la suivante\u2009:</p> <ul> <li>Il n'est pas possible d'assigner une adresse \u00e0 un tableau</li> <li>Il n'est pas possible d'assigner des valeurs \u00e0 un pointeur</li> </ul> <p>D'ailleurs, l'op\u00e9rateur crochet <code>[]</code> n'est rien d'autre qu'un sucre syntaxique:</p> <pre><code>a[b] == *(a + b);\n</code></pre> <p>Bien que ce soit une tr\u00e8s mauvaise id\u00e9e, il est tout \u00e0 fait possible d'\u00e9crire le code suivant puisque l'addition est commutative\u2009:</p> <pre><code>assert(4[a] == a[4]);\n</code></pre>"}, {"location": "course-c/25-data-structures/pointers/#arithmetique-de-pointeurs", "title": "Arithm\u00e9tique de pointeurs", "text": "<p>Fondamentalement un pointeur est une variable qui contient un ordinal, c'est-\u00e0-dire qu'il peut \u00eatre imagin\u00e9 l'ajout \u00e0 un pointeur une grandeur finie\u2009:</p> <pre><code>char str[] = \"Le vif z\u00e9phyr jubile sur les kumquats du clown gracieux\";\n\nfor (char* ptr = str; *ptr; ptr++) {\n    putchar(*ptr);\n}\n</code></pre> <p>Imaginons que l'on souhaite repr\u00e9senter le carr\u00e9 magique suivant\u2009:</p> <pre><code>\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n\u2502 4 \u2502 9 \u2502 2 \u2502\n\u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 3 \u2502 5 \u2502 7 \u2502\n\u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 8 \u2502 1 \u2502 6 \u2502\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\n</code></pre> <p>On peut le repr\u00e9senter en m\u00e9moire lin\u00e9airement et utiliser de l'arithm\u00e9tique de pointeur pour le dessiner\u2009:</p> <pre><code>char magic[] = \"492\" \"357\" \"816\";\n\nchar* ptr = magic;\n\nfor (size_t row = 0; row &lt; 3; row++) {\n    for (size_t col = 0; col &lt; 3; col++)\n        putchar(*(ptr + row * 3 + col));\n    putchar('\\n');\n}\n</code></pre> <p>Mais\u2009? N'est-ce pas l\u00e0 ce que fait le compilateur lorsque l'adresse les \u00e9l\u00e9ments d'un tableau multidimensionnel\u2009?</p> <pre><code>char magic[][3] = {\"792\", \"357\", \"816\"};\n\nfor (size_t row = 0; row &lt; 3; row++) {\n    for (size_t col = 0; col &lt; 3; col++)\n        putchar(magic[row][col]);\n    putchar('\\n');\n}\n</code></pre> <p>Oui tr\u00e8s exactement, les deux codes sont similaires, mais l'un est plus \u00e9l\u00e9gant que l'autre, lequel d'apr\u00e8s vous\u2009?</p> <p>L'arithm\u00e9tique de pointeur est donc chose courante avec les tableaux. \u00c0 vrai dire, les deux concepts sont interchangeables\u2009:</p>  Arithm\u00e9tique sur tableau unidimensionnel \u00c9l\u00e9ment Premier Deuxi\u00e8me Troisi\u00e8me n i\u00e8me Acc\u00e8s tableau <code>a[0]</code> <code>a[1]</code> <code>a[2]</code> <code>a[n - 1]</code> Acc\u00e8s pointeur <code>*a</code> <code>*(a + 1)</code> <code>*(a + 2)</code> <code>*(a + n - 1)</code> <p>De m\u00eame, l'exercice peut \u00eatre r\u00e9p\u00e9t\u00e9 avec des tableaux \u00e0 deux dimensions\u2009:</p>  Arithm\u00e9tique sur tableau bidimensionnel \u00c9l\u00e9ment Premier Deuxi\u00e8me n ligne m colonne Acc\u00e8s tableau <code>a[0][0]</code> <code>a[1][1]</code> <code>a[n - 1][m - 1]</code> Acc\u00e8s pointeur <code>*(*(a+0)+0)</code> <code>*(*(a+1)+1)</code> <code>*(*(a+i-1)+j-1)</code>"}, {"location": "course-c/25-data-structures/pointers/#pointeur-et-chaines-de-caracteres", "title": "Pointeur et cha\u00eenes de caract\u00e8res", "text": "<pre><code>static const char* conjonctions[] = {\n    \"mais\", \"ou\", \"est\", \"donc\", \"or\", \"ni\", \"car\"\n};\n</code></pre> <p> Pointeur sur une cha\u00eene de caract\u00e8re</p> <p>Cette structure est tr\u00e8s exactement la m\u00eame que pour les arguments transmis \u00e0 la fonction <code>main</code>: la d\u00e9finition <code>char *argv[]</code>.</p>"}, {"location": "course-c/25-data-structures/pointers/#structures-et-pointeurs", "title": "Structures et pointeurs", "text": ""}, {"location": "course-c/25-data-structures/pointers/#initialisation-dun-pointeur-sur-une-structure", "title": "Initialisation d'un pointeur sur une structure", "text": "<p>De la m\u00eame mani\u00e8re qu'avec les types standards, on peut d\u00e9finir un pointeur sur une structure de donn\u00e9es.</p> <pre><code>typedef struct Date {\n    unsigned char day;\n    unsigned char month;\n    unsigned int  year;\n} Date;\n</code></pre> <p>L'exemple pr\u00e9c\u00e9dent d\u00e9finit un type de donn\u00e9e Date. On pourrait donc initialiser un pointeur sur cette structure de la fa\u00e7on suivante\u2009:</p> <pre><code>Date date;\nDate *p;  // Pointeur sur un type Date\n\np = &amp;date;  // Initialisation du pointeur sur un type structur\u00e9\n</code></pre> <p>Le pointeur reste un pointeur, soit un espace m\u00e9moire qui contient une adresse vers la structure <code>Date</code>. En cons\u00e9quence, la taille de ce pointeur est de 8 bytes sur une machine 64 bits\u2009:</p> <pre><code>Date *p;\nassert(sizeof(p) == 8);\n</code></pre>"}, {"location": "course-c/25-data-structures/pointers/#utilisation-dun-pointeur-sur-une-structure", "title": "Utilisation d'un pointeur sur une structure", "text": "<p>On a vu que les champs d'une structure sont accessibles au travers du <code>.</code> faisant la liaison entre la variable et le champ. Cela est valable si la variable est du type structur\u00e9. Si la variable est du type pointeur sur une structure, on remplacera le <code>.</code> par <code>-&gt;</code>.</p> <pre><code>Date date;\nDate *p;\n\np = &amp;date;\n\np-&gt;day = 29;\np-&gt;month = 12;\np-&gt;year = 1964;\n</code></pre> <p>La syntaxe <code>-&gt;</code> est un sucre syntaxique. Les deux \u00e9critures suivantes sont par cons\u00e9quent \u00e9quivalentes\u2009:</p> <pre><code>p-&gt;year\n(*p).year\n</code></pre>"}, {"location": "course-c/25-data-structures/pointers/#utilisation-dun-pointeur-recursif-sur-une-structure", "title": "Utilisation d'un pointeur r\u00e9cursif sur une structure", "text": "<p>Lorsqu'on utilise des listes cha\u00een\u00e9es, on a besoin de cr\u00e9er une structure contenant des donn\u00e9es ainsi qu'un pointeur sur un \u00e9l\u00e9ment pr\u00e9c\u00e9dent et un autre sur l'\u00e9l\u00e9ment suivant. Ces pointeurs sont du m\u00eame type que la structure dans laquelle ils sont d\u00e9clar\u00e9s et cela impose un style d'\u00e9criture sp\u00e9cifique\u2009:</p> <pre><code>typedef struct Element {\n  struct Element *prev;  // Pointeur sur l'\u00e9l\u00e9ment pr\u00e9c\u00e9dent\n  struct Element *next;  // Pointeur sur l'\u00e9l\u00e9ment suivant\n  unsigned long data;  // Donn\u00e9e d'une liste cha\u00een\u00e9e\n} Element;\n</code></pre> <p>Exemple d'utilisation\u2009:</p> <pre><code>Element e[3];\n\n// Premier \u00e9l\u00e9ment de la liste\ne[0].prev = NULL;\ne[0].next = &amp;e[1];\n\n// Second \u00e9l\u00e9ment de la liste\ne[1].prev = &amp;e[0];\ne[1].next = &amp;e[2];\n\n// troisi\u00e8me \u00e9l\u00e9ment de la liste\ne[2].prev = &amp;e[1];\ne[2].next = NULL;\n</code></pre>"}, {"location": "course-c/25-data-structures/pointers/#pointeurs-et-parametres-de-fonctions", "title": "Pointeurs et param\u00e8tres de fonctions", "text": "<p>Les fonctions comportent une liste de param\u00e8tres permettant de retourner une information au programme appelant. Il est souvent indispensable de pouvoir fournir \u00e0 une fonction des param\u00e8tres qu'elle peut modifier lors de son ex\u00e9cution. Pour ce faire, on passera par l'utilisation de pointeurs.</p>"}, {"location": "course-c/25-data-structures/pointers/#parametres-sous-la-forme-de-pointeurs", "title": "Param\u00e8tres sous la forme de pointeurs", "text": "<p>Le prototype d'une fonction recevant un (ou plusieurs) pointeur s'\u00e9crit de la mani\u00e8re suivante\u2009:</p> <pre><code>type fonction(Type *param);\n</code></pre> <p>Cette fonction re\u00e7oit un param\u00e8tre (param) qui est un pointeur sur le type <code>Type</code>.</p> <p>Exemple de prototype\u2009:</p> <pre><code>int compute(double x, double *pres);\n</code></pre> <p>La fonction calcul prend 2 param\u00e8tres. Le premier (x) est du type double. Le second (pres) est un pointeur sur un double. Il sera donc possible, lors de l'appel de la fonction, de lui donner l'adresse d'une variable dans laquelle la fonction placera le r\u00e9sultat du calcul.</p> <pre><code>int calcul(double x, double * pres) {\n    *pres = x * 2.;  // calcul du double de x\n                     // place le resultat \u00e0 l'adresse pres\n    return 0;  // code retour = 0 (int)\n}\n\nint main() {\n    double value = 7.;\n    double r = 0.;\n    int res = 0;\n\n    res = compute(value, &amp;r);\n    // res vaut maintenant 14.\n}\n</code></pre> <p>Lors de l'appel d'une fonction recevant un pointeur comme param\u00e8tre, on placera le symbole <code>&amp;</code> pour lui donner l'adresse de la variable.</p>"}, {"location": "course-c/25-data-structures/pointers/#transtypage-de-pointeurs-cast", "title": "Transtypage de pointeurs (cast)", "text": "<p>Le <code>cast</code> de pointeur s'av\u00e8re n\u00e9cessaire lorsqu'un pointeur du type <code>void</code> est d\u00e9clar\u00e9, comme c'est le cas pour la fonction de copie m\u00e9moire <code>memcpy</code>. En effet, cette fonction accepte en entr\u00e9e un pointeur vers une r\u00e9gion m\u00e9moire source, et un pointeur vers une r\u00e9gion m\u00e9moire de destination. D'un cas d'utilisation \u00e0 un autre, le format de ces r\u00e9gions m\u00e9moires peut \u00eatre de nature tr\u00e8s diff\u00e9rente\u2009:</p> <pre><code>char message[] = \"Mind the gap, please!\";\nint array[128];\nstruct { int a; char b; float c[3] } elements[128];\n</code></pre> <p>Il faudrait donc autant de fonctions <code>memcpy</code> que de type possible, ce qui n'est ni raisonnable, ni m\u00eame imaginable. Face \u00e0 ce dilemme, on utilise un pointeur neutre, celui qui n'envie personne et que personne n'envie <code>void</code> et qui permet sans autre\u2009:</p> <pre><code>void *ptr;\n\nptr = message;\nptr = array;\nptr = elements;\n</code></pre> <p>Que pensez-vous que <code>sizeof(void)</code> devrait retourner\u2009? Formellement ceci devrait mener \u00e0 une erreur de compilation, car <code>void</code> n'a pas de substance, et donc aucune taille associ\u00e9e. N\u00e9anmoins <code>gcc</code> est tr\u00e8s permissif de base et (\u00e0 ma grande surprise), il ne g\u00e9n\u00e8re par d\u00e9faut ni warning, ni erreurs sans l'option <code>-Wpointer-arith</code> sur laquelle nous aurons tout le loisir de revenir.</p> <p>L'int\u00e9r\u00eat d'un pointeur, c'est justement de pointer une r\u00e9gion m\u00e9moire et le plus souvent, de la balayer gr\u00e2ce \u00e0 l'arithm\u00e9tique de pointeurs. Notre fonction de copie m\u00e9moire doit en somme pouvoir parcourir toute la r\u00e9gion m\u00e9moire de source et de destination et de ce fait incr\u00e9menter le pointeur. Mais, n'ayant aucune taille l'arithm\u00e9tique de pointeur n'est pas autoris\u00e9e avec le pointeur <code>void</code> et nous voil\u00e0 bien avanc\u00e9s, notre pointeur ne nous est gu\u00e8re d'usage que son utilit\u00e9 \u00e9ponyme\u2009: rien.</p> <p>Or, le titre de cette section \u00e9tant le transtypage, il doit donc y avoir moyen de s'en sortir par une pirouette programmatique dans laquelle je d\u00e9clare un nouveau pointeur du type char auquel j'associe la valeur de ptr par un cast explicite.</p> <pre><code>char *iptr = (char*)ptr;\n</code></pre> <p>D\u00e8s lors, l'arithm\u00e9tique est redevient possible <code>iptr++</code>. Pourquoi ne pas avoir utilis\u00e9 ce subterfuge plus t\u00f4t me direz-vous\u2009? En effet, il m'aurait \u00e9t\u00e9 possible d'\u00e9crire <code>char *ptr = (char*)elements;</code> directement et sans d\u00e9tour, mais ceci aurait alors men\u00e9 \u00e0 ce prototype-ci\u2009:</p> <pre><code>void *memcpy(char* dest, const char* src, size_t n);\n</code></pre> <p>La cl\u00e9 est dans le standard ISO/IEC 9899:2011 section 6.3.2.3 page 55\u2009:</p> <p>A pointer to void may be converted to or from a pointer to any object type. A pointer to any object type may be converted to a pointer to void and back again\u2009; the result shall compare equal to the original pointer.</p> <p>Autrement dit, il n'est pas n\u00e9cessaire ni recommand\u00e9 de faire un transtypage explicite pour convertir vers et en provenance d'un pointeur sur <code>void</code>. Et donc, l'astuce de memcpy est que la fonction accepte n'importe quel type de pointeur et c'est le message auto document\u00e9 du code.</p> <p>Et quant \u00e0 l'impl\u00e9mentation de cette fonction me direz-vous\u2009? Une possibilit\u00e9 serait\u2009:</p> <pre><code>void memcpy(void *dest, void *src, size_t n)\n{\n    char* csrc = src;\n    char* cdest = dest;\n\n    for (size_t i = 0; i &lt; n; i++)\n        cdest[i] = csrc[i];\n}\n</code></pre> <p>O\u00f9 plus concis\u2009:</p> <pre><code>void memcpy(void *dest, void *src, size_t n)\n{\n    for (size_t i = 0; i &lt; n; i++)\n        ((char*)dst)[i] = ((char*)src)[i];\n}\n</code></pre> <p>Or, rien de tout ceci n'est juste. <code>memcpy</code> est une fonction fondamentale en C, ce pourquoi nous nous y attardons temps. Elle est constamment utilis\u00e9e et doit \u00eatre extr\u00eamement performante. Aussi, si le compilateur cible une architecture 64-bits pourquoi diable copier les \u00e9l\u00e9ments par paquet de 8-bits. C'est un peu comme si notre facteur, au d\u00e9but de ce chapitre, aurait fait ses allers-retours avec en t\u00eate qu'un octet par trajet. L'impl\u00e9mentation d\u00e9pend donc de l'architecture cible et doit tenir compte des \u00e9ventuels effets de bords. Par exemple s'il faut copier un tableau de 9 x 32 bits. Une architecture 64-bits aura une grande facilit\u00e9 \u00e0 copier les 8 premiers octets, mais quant au dernier, il s'agit d'un cas particulier et selon la taille de la copie et l'architecture du processeur, l'impl\u00e9mentation devra \u00eatre ajust\u00e9e. C'est pourquoi ce type tr\u00e8s bas niveau de fonction est l'affaire d'une cuisine interne du compilateur et dont le d\u00e9veloppeur ne doit pas se soucier. Vous \u00eates comme Thomas l'ap\u00f4tre, et ne me croyez pas\u2009? Alors, digressons et essayons\u2009:</p> <pre><code>#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    char a[] = \"La Broye c'est fantastique!\";\n    char b[sizeof(a)];\n\n    memcpy(a, b, sizeof(a));\n\n    printf(\"%s %s\", a, b);\n}\n</code></pre> <p>On observe qu'il n'y a aucun appel de fonction \u00e0 <code>memcpy</code> comme c'est le cas pour <code>printf</code> (<code>bl printf</code>). La copie tient place en 6 instructions.</p> <pre><code>main :\n    // Entry\n    str     lr, [sp, #-4]!\n    sub     sp, sp, #60\n\n    // Inline memcpy\n    mov     ip, sp      // Destination address\n    add     lr, sp, #28 // Source address (char b located 28 octets after a)\n\n    ldmia   lr!, {r0, r1, r2, r3}   // Load 4 x 32-bits\n    stmia   ip!, {r0, r1, r2, r3}   // Store 4 x 32-bits\n\n    ldm     lr, {r0, r1, r2}        // Load 3 x 32-bits\n    stm     ip, {r0, r1, r2}        // Store 3 x 32-bits\n\n    // Display (printf)\n    add     r2, sp, #28\n    mov     r1, sp\n    ldr     r0, .L4\n    bl      printf\n\n    // Exit\n    mov     r0, #0\n    add     sp, sp, #60\n    ldr     pc, [sp], #4\n.L4 :\n    .word   .LC0\n.LC0 :\n    .ascii  \"La Broye c'est fantastique!\\000\"\n</code></pre> <p>Vous pouvez jouer avec cet exemple sur le site godbolt.</p>"}, {"location": "course-c/25-data-structures/pointers/#pointeurs-de-fonctions", "title": "Pointeurs de fonctions", "text": "<p>Un pointeur peut pointer n'importe o\u00f9 en m\u00e9moire, et donc il peut \u00e9galement pointer non pas sur une variable, mais sur une fonction. Les pointeurs de fonctions sont tr\u00e8s utiles pour des fonctions de rappel (callback).</p> <p>Par exemple on veut appliquer une transformation sur tous les \u00e9l\u00e9ments d'un tableau, mais la transformation n'est pas connue \u00e0 l'avance. On pourrait \u00e9crire\u2009:</p> <pre><code>int is_odd(int n)\n{\n    return !(n % 2);\n}\n\nvoid map(int array[], int (*callback)(int), size_t length)\n{\n    for (size_t i = 0; i &lt; length; i++) {\n        array[i] = callback(array[i]);\n    }\n}\n\nvoid main(void)\n{\n    int array[] = {1,2,3,4,5};\n\n    map(array, is_odd);\n}\n</code></pre> <p>Avec la r\u00e8gle gauche droite, on parvient \u00e0 d\u00e9cortiquer la d\u00e9claration\u2009:</p> <pre><code>int (*callback)(int)\n      ^^^^^^^^        callback is\n              ^\n     ^                a pointer on\n               ^^^^^  a function taking an int\n^^^                   and returning an int\n</code></pre>"}, {"location": "course-c/25-data-structures/pointers/#la-regle-gauche-droite", "title": "La r\u00e8gle gauche-droite", "text": "<p>Cette r\u00e8gle est une recette magique permettant de correctement d\u00e9cortiquer une d\u00e9claration C contenant des pointeurs. Il faut tout d'abord lire\u2009:</p>  R\u00e8gles gauche droite Symbole Traduction Direction <code>*</code> <code>pointeur sur</code> Toujours \u00e0 gauche <code>[]</code> <code>tableau de</code> Toujours \u00e0 droite <code>()</code> <code>fonction retournant</code> Toujours \u00e0 droite Premi\u00e8re \u00e9tape <p>Trouver l'identifiant et se dire <code>L'identifiant est</code>.</p> Deuxi\u00e8me \u00e9tape <p>Chercher le symbole \u00e0 droite de l'identifiant. Si vous trouvez un <code>()</code>, vous savez que cet identifiant est une fonction et vous avez L'identifiant est une fonction retournant. Si vous trouvez un <code>[]</code> vous dites alors L'identifiant est un tableau de. Continuez \u00e0 droite jusqu'\u00e0 ce que vous \u00eates \u00e0 court de symboles, OU que vous trouvez une parenth\u00e8se fermante <code>)</code>.</p> Troisi\u00e8me \u00e9tape <p>Regardez le symbole \u00e0 gauche de l'identifiant. S\u2019il n'est aucun des symboles pr\u00e9c\u00e9dents, dites quelque chose comme <code>int</code>. Sinon, convertissez le symbole en utilisant la table de correspondance. Continuez d'aller \u00e0 gauche jusqu'\u00e0 ce que vous \u00eates \u00e0 court de symboles OU que vous rencontrez une parenth\u00e8se ouvrante <code>(</code>.</p> Ensuite... <p>Continuez les \u00e9tapes 2 et 3 jusqu'\u00e0 ce que vous avez une d\u00e9claration compl\u00e8te.</p> <p>Voici quelques exemples\u2009:</p> <pre><code>int *p[];\n</code></pre> <ol> <li> <p>Trouver l'identifiant\u2009: <code>p</code>: <code>p est</code></p> <pre><code>int *p[];\n     ^\n</code></pre> </li> <li> <p>Se d\u00e9placer \u00e0 droite: <code>p est un tableau de</code></p> <pre><code>int *p[];\n      ^^\n</code></pre> </li> <li> <p>Se d\u00e9placer \u00e0 gauche: <code>p est un tableau de pointeurs sur</code></p> <pre><code>int *p[];\n    ^\n</code></pre> </li> <li> <p>Continuer \u00e0 gauche: <code>p est un tableau de pointeurs sur un int</code></p> <pre><code>int *p[];\n^^^\n</code></pre> </li> </ol>"}, {"location": "course-c/25-data-structures/pointers/#cdecl", "title": "cdecl", "text": "<p>Il existe un programme nomm\u00e9 cdecl qui permet de d\u00e9coder de complexes d\u00e9claration c\u2009:</p> <pre><code>$ cdecl 'char (*(*x[3])())[5]'\ndeclare x as array 3 of pointer to function returning pointer to array 5 of char\n</code></pre> <p>Une version en ligne est \u00e9galement disponible.</p>"}, {"location": "course-c/25-data-structures/pointers/#initialisation-par-transtypage", "title": "Initialisation par transtypage", "text": "<p>L'utilisation de structure peut \u00eatre utile pour initialiser un type de donn\u00e9e en utilisant un autre type de donn\u00e9e. Nous citons ici deux exemples.</p> <pre><code>int i = *(int*)(struct { char a; char b; char c; char d; }){'a', 'b', 'c', 'd'};\n</code></pre> <pre><code>union {\n    int matrix[10][10];\n    int vector[100];\n} data;\n</code></pre>"}, {"location": "course-c/25-data-structures/pointers/#enchevetrement-ou-aliasing", "title": "Enchev\u00eatrement ou Aliasing", "text": "<p>Travailler avec les pointeurs demande une attention particuli\u00e8re \u00e0 tous les probl\u00e8mes d'alisasing dans lesquels diff\u00e9rents pointeurs pointent sur une m\u00eame r\u00e9gion m\u00e9moire.</p> <p>Mettons que l'on souhaite simplement d\u00e9placer une r\u00e9gion m\u00e9moire vers une nouvelle r\u00e9gion m\u00e9moire. On pourrait impl\u00e9menter le code suivant\u2009:</p> <pre><code>void memory_move(char *dst, char*src, size_t size) {\n    for (int i = 0; i &lt; size; i++)\n        *dst++ = *src++;\n}\n</code></pre> <p>Ce code est tr\u00e8s simple mais il peut poser probl\u00e8me selon les cas. Imaginons que l'on dispose d'un tableau simple de dix \u00e9l\u00e9ments et de deux pointeurs <code>*src</code> et <code>*dst</code>. Pour d\u00e9placer la r\u00e9gion du tableau de 4 \u00e9l\u00e9ments vers la droite. On se dirait que le code suivant pourrait fonctionner\u2009:</p> <pre><code>\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\n\u25020\u25021\u25022\u25023\u25024\u25025\u25026\u25027\u25028\u25029\u2502\n\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n ^*src ^*dst\n      \u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\n      \u25020\u25021\u25022\u25023\u25024\u25025\u25026\u2502\n      \u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n       \u2193 \u2193 \u2193 \u2193 \u2193 \u2193 \u2193\n\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\n\u25020\u25021\u25022\u25020\u25021\u25022\u25023\u25024\u25025\u25026\u2502\n\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n</code></pre> <p>Na\u00efvement l'ex\u00e9cution suivante devrait fonctionner, mais les deux pointeurs source et destination s'enchev\u00eatrent et le r\u00e9sultat n'est pas celui escompt\u00e9.</p> <pre><code>char array[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\nchar *src = &amp;array[0];\nchar *dst = &amp;array[3];\n\nmemory_move(b, a, 7);\n</code></pre> <pre><code>\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\n\u25020\u25021\u25022\u25023\u25024\u25025\u25026\u25027\u25028\u25029\u2502 Tableau d'origine\n\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\n\u25020\u25021\u25022\u25020\u25021\u25022\u25020\u25021\u25022\u25020\u2502 Op\u00e9ration avec `memory_move`\n\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\n\u25020\u25021\u25022\u25020\u25021\u25022\u25023\u25024\u25025\u25026\u2502 Op\u00e9ration avec `memmove` (fonction standard)\n\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\n</code></pre> <p>Notre simple fonction de d\u00e9placement m\u00e9moire ne fonctionne pas avec des r\u00e9gions m\u00e9moires qui s'enchev\u00eatrent. En revanche, la fonction standard <code>memmove</code> de <code>&lt;stdlib.h&gt;</code> fonctionne, car elle autorise, au d\u00e9triment d'une plus grande complexit\u00e9, de g\u00e9rer ce type de situation.</p> <p>Notons que sa fonction voisine <code>memcpy</code> ne dois jamais \u00eatre utilis\u00e9e en cas d'aliasing. Cette fonction se veut performante, c'est-\u00e0-dire qu'elle peut \u00eatre impl\u00e9ment\u00e9e en suivant le m\u00eame principe que notre exemple <code>memory_move</code>. Le standard C99 ne d\u00e9finit pas le comportement de <code>memcpy</code> pour des pointeurs qui se chevauchent.</p>"}, {"location": "course-c/25-data-structures/pointers/#exercices-de-revision", "title": "Exercices de r\u00e9vision", "text": "<p>Exercise\u2009: Esperluettes cascad\u00e9es</p> <p>Quel est le type de\u2009:</p> <pre><code>*&amp;*&amp;*&amp;*&amp;*&amp;*&amp;(int)x;\n</code></pre> <p>Exercise\u2009: Passage par adresse</p> <p>Donnez les valeurs affich\u00e9es par ce programme pour les variables <code>a</code> \u00e0 <code>e</code>.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint test(int a, int * b, int * c, int * d) {\n    a = *b;\n    *b = *b + 5;\n    *c = a + 2;\n    d = c;\n    return *d;\n}\n\nint main(void) {\n    int a = 0, b = 100, c = 200, d = 300, e = 400;\n    e = test(a, &amp;b, &amp;c, &amp;d);\n    printf(\"a:%d, b:%d, c:%d, d:%d, e:%d\\n\", a, b, c, d, e);\n}\n</code></pre> Solution <pre><code>a:0, b:105, c:102, d:300, e:102\n</code></pre>"}, {"location": "course-c/25-data-structures/containers/", "title": "Conteneurs de donn\u00e9es", "text": "<p>Un conteneur de donn\u00e9es est une structure informatique de donn\u00e9es qui permet de stocker des \u00e9l\u00e9ments de fa\u00e7on organis\u00e9e. Il existe de nombreux types de conteneurs de donn\u00e9es, chacun ayant ses propres avantages et inconv\u00e9nients. Les conteneurs de donn\u00e9es les plus courants sont les tableaux, les listes cha\u00een\u00e9es, les piles, les files, les arbres, les graphes, etc.</p> <p>En r\u00e8gle g\u00e9n\u00e9rale, le d\u00e9veloppeur n'impl\u00e9mente pas directement ces conteneurs de donn\u00e9es, mais utilise des biblioth\u00e8ques qui les fournissent. Ces biblioth\u00e8ques sont souvent incluses dans les langages de programmation, mais il existe \u00e9galement des biblioth\u00e8ques tierces qui fournissent des impl\u00e9mentations de conteneurs de donn\u00e9es pour de nombreux langages de programmation.</p> <p>H\u00e9las en C, il n'existe pas de biblioth\u00e8que standard qui fournit des conteneurs de donn\u00e9es de haut niveau.</p>"}, {"location": "course-c/25-data-structures/containers/#types-de-donnees-abstraits", "title": "Types de donn\u00e9es abstraits", "text": "<p>Un type de donn\u00e9e abstrait (ADT pour Abstract Data Type) cache g\u00e9n\u00e9ralement une structure dont le contenu n'est pas connu de l'utilisateur final. Ceci est rendu possible par le standard (C99 \u00a76.2.5) par l'usage de types incomplets.</p> <p>Pour m\u00e9moire, un type incomplet d\u00e9crit un objet dont on ne conna\u00eet pas sa taille en m\u00e9moire.</p> <p>L'exemple suivant d\u00e9clare un nouveau type structure qui n'est alors pas (encore) connu dans le fichier courant\u2009:</p> <pre><code>typedef struct Unknown *Known;\n\nint main() {\n    Known foo; // Autoris\u00e9, le type est incomplet\n\n    foo + 1; // Impossible car la taille de foo est inconnue.\n    foo-&gt;key; // Impossible car le type est incomplet.\n}\n</code></pre> <p>De fa\u00e7on g\u00e9n\u00e9rale, les types abstraits sont utilis\u00e9s dans l'\u00e9criture de biblioth\u00e8ques logicielles lorsqu'il est important que l'utilisateur final ne puisse pas compromettre le contenu du type et en for\u00e7ant cet utilisateur \u00e0 ne passer que par des fonctions d'acc\u00e8s.</p> <p>Prenons le cas du fichier <code>foobar.c</code> lequel d\u00e9crit une structure <code>struct Foo</code> et un type <code>Foo</code>. Notez que le type peut \u00eatre d\u00e9clar\u00e9 avant la structure. <code>Foo</code> restera abstrait jusqu'\u00e0 la d\u00e9claration compl\u00e8te de la structure <code>struct Foo</code> permettant de conna\u00eetre sa taille. Ce fichier contient \u00e9galement trois fonctions\u2009:</p> <ul> <li><code>init</code> permet d'initialiser la structure\u2009;</li> <li><code>get</code> permet de r\u00e9cup\u00e9rer la valeur contenue dans <code>Foo</code> ;</li> <li><code>set</code> permet d'assigner une valeur \u00e0 <code>Foo</code>.</li> </ul> <p>En plus, il existe un compteur d'acc\u00e8s <code>count</code> qui s'incr\u00e9mente lorsque l'on assigne une valeur et se d\u00e9cr\u00e9mente lorsque l'on r\u00e9cup\u00e8re une valeur.</p> <pre><code>#include &lt;stdlib.h&gt;\n\ntypedef struct Foo Foo;\n\nstruct Foo {\n    int value;\n    int count;\n};\n\nvoid init(Foo** foo) {\n    *foo = malloc(sizeof(Foo)); // Allocation dynamique\n    (*foo)-&gt;count = (*foo)-&gt;value = 0;\n}\n\nint get(Foo* foo) {\n    foo-&gt;count--;\n    return foo-&gt;value;\n}\n\nvoid set(Foo* foo, int value) {\n    foo-&gt;count++;\n    foo-&gt;value = value;\n}\n</code></pre> <p>\u00c9videmment, on ne souhaite pas qu'un petit malin compromette ce compteur en \u00e9crivant maladroitement\u2009:</p> <pre><code>foo-&gt;count = 42; // Hacked this !\n</code></pre> <p>Pour s'en prot\u00e9ger, on a recours \u00e0 la compilation s\u00e9par\u00e9e (voir chapitre sur la compilation s\u00e9par\u00e9e [TranslationUnits]) dans laquelle le programme est d\u00e9coup\u00e9 en plusieurs fichiers. Le fichier <code>foobar.h</code> contiendra tout ce qui doit \u00eatre connu du programme principal, \u00e0 savoir les prototypes des fonctions, et le type abstrait\u2009:</p> <pre><code>#pragma once\n\ntypedef struct Foo Foo;\n\nvoid init(Foo** foo);\nint get(Foo* foo);\nvoid set(Foo* foo, int value);\n</code></pre> <p>Ce fichier sera inclus dans le programme principal <code>main.c</code> :</p> <pre><code>#include \"foobar.h\"\n#include &lt;stdio.h&gt;\n\nint main() {\n    Foo *foo;\n\n    init(&amp;foo);\n    set(foo, 23);\n    printf(\"%d\\n\", get(foo));\n}\n</code></pre> <p>En r\u00e9sum\u00e9, un type abstrait impose l'utilisation de fonctions interm\u00e9diaires pour modifier le type. Dans la grande majorit\u00e9 des cas, ces types repr\u00e9sentent des structures qui contiennent des informations internes qui ne sont pas destin\u00e9es \u00e0 \u00eatre modifi\u00e9es par l'utilisateur final.</p>"}, {"location": "course-c/25-data-structures/containers/#tableau-dynamique", "title": "Tableau dynamique", "text": "<p>Un tableau dynamique aussi appel\u00e9 vecteur est, comme son nom l'indique, allou\u00e9 dynamiquement dans le heap en fonction des besoins. Vous vous rappelez que le heap grossit \u00e0 chaque appel de <code>malloc</code> et diminue \u00e0 chaque appel de <code>free</code>.</p> <p>Un tableau dynamique est souvent sp\u00e9cifi\u00e9 par un facteur de croissance (rien \u00e0 voir avec les hormones). Lorsque le tableau est plein et que l'on souhaite rajouter un nouvel \u00e9l\u00e9ment, le tableau est r\u00e9allou\u00e9 dans un autre espace m\u00e9moire plus grand avec la fonction <code>realloc</code>. Cette derni\u00e8re n'est rien d'autre qu'un <code>malloc</code> suivi d'un <code>memcopy</code> suivi d'un <code>free</code>. Un nouvel espace m\u00e9moire est r\u00e9serv\u00e9, les donn\u00e9es sont copi\u00e9es du premier espace vers le nouveau, et enfin le premier espace est lib\u00e9r\u00e9. Voici un exemple\u2009:</p> <pre><code>// Alloue un espace de trois chars\nchar *buffer = malloc(3);\n\n// Rempli le buffer\nbuffer[0] = 'h';\nbuffer[1] = 'e';\nbuffer[2] = 'l'; // Le buffer est plein...\n\n// Augmente dynamiquement la taille du buffer \u00e0 5 chars\nchar *tmp = realloc(buffer, 5);\nassert(tmp != NULL);\nbuffer = tmp;\n\n// Continue de remplir le buffer\nbuffer[3] = 'l';\nbuffer[4] = 'o'; // Le buffer est \u00e0 nouveau plein...\n\n// Lib\u00e8re l'espace m\u00e9moire utilis\u00e9\nfree(buffer);\n</code></pre> <p>La taille du nouvel espace m\u00e9moire est plus grande d'un facteur donn\u00e9 que l'ancien espace. Selon les langages de programmation et les compilateurs, ces facteurs sont compris entre 3/2 et 2. C'est-\u00e0-dire que la taille du tableau prendra les tailles de 1, 2, 4, 8, 16, 32, etc.</p> <p>Lorsque le nombre d'\u00e9l\u00e9ments du tableau devient inf\u00e9rieur du facteur de croissance \u00e0 la taille effective du tableau, il est possible de faire l'op\u00e9ration inverse, c'est-\u00e0-dire r\u00e9duire la taille allou\u00e9e. En pratique cette op\u00e9ration est rarement impl\u00e9ment\u00e9e, car peu efficace (c.f. cette r\u00e9ponse sur stackoverflow).</p>"}, {"location": "course-c/25-data-structures/containers/#anatomie", "title": "Anatomie", "text": "<p>Un tableau dynamique est repr\u00e9sent\u00e9 en m\u00e9moire comme un contenu s\u00e9quentiel qui poss\u00e8de un d\u00e9but et une fin. On appelle son d\u00e9but la t\u00eate ou head et la fin du tableau, sa queue ou tail. Selon que l'on souhaite ajouter des \u00e9l\u00e9ments au d\u00e9but ou \u00e0 la fin du tableau, la complexit\u00e9 n'est pas la m\u00eame.</p> <p>Nous d\u00e9finirons par la suite le vocabulaire suivant\u2009:</p>  Vocabulaire des actions sur un tableau dynamique Action Terme technique Ajout d'un \u00e9l\u00e9ment \u00e0 la t\u00eate du tableau <code>unshift</code> Ajout d'un \u00e9l\u00e9ment \u00e0 la queue du tableau <code>push</code> Suppression d'un \u00e9l\u00e9ment \u00e0 la t\u00eate du tableau <code>shift</code> Suppression d'un \u00e9l\u00e9ment \u00e0 la queue du tableau <code>pop</code> <p>Nous comprenons rapidement qu'il est plus compliqu\u00e9 d'ajouter ou de supprimer un \u00e9l\u00e9ment depuis la t\u00eate du tableau, car il est n\u00e9cessaire ensuite de d\u00e9placer chaque \u00e9l\u00e9ment (l'\u00e9l\u00e9ment 0 devient l'\u00e9l\u00e9ment 1, l'\u00e9l\u00e9ment 1 devient l'\u00e9l\u00e9ment 2...).</p> <p>Un tableau dynamique peut \u00eatre repr\u00e9sent\u00e9 par la figure suivante\u2009:</p> <p> Tableau dynamique</p> <p>Un espace m\u00e9moire est r\u00e9serv\u00e9 dynamiquement sur le tas. Comme <code>malloc</code> ne retourne pas la taille de l'espace m\u00e9moire allou\u00e9, mais juste un pointeur sur cet espace, il est n\u00e9cessaire de conserver dans une variable la capacit\u00e9 du tableau. Notons qu'un tableau de 10 <code>int32_t</code> repr\u00e9sentera un espace m\u00e9moire de 4x10 bytes, soit 40 bytes. La m\u00e9moire ainsi r\u00e9serv\u00e9e par <code>malloc</code> n'est g\u00e9n\u00e9ralement pas vide, mais elle contient des valeurs, vestige d'une ancienne allocation m\u00e9moire d'un autre programme depuis que l'ordinateur a \u00e9t\u00e9 allum\u00e9. Pour conna\u00eetre le nombre d'\u00e9l\u00e9ments effectifs du tableau, il faut \u00e9galement le m\u00e9moriser. Enfin, le pointeur sur l'espace m\u00e9moire est aussi m\u00e9moris\u00e9.</p> <p>Les composants de cette structure de donn\u00e9e sont donc\u2009:</p> <ul> <li>Un entier non sign\u00e9 <code>size_t</code> repr\u00e9sentant la capacit\u00e9 totale du tableau dynamique \u00e0 un instant T.</li> <li>Un entier non sign\u00e9 <code>size_t</code> repr\u00e9sentant le nombre d'\u00e9l\u00e9ments effectivement dans le tableau.</li> <li>Un pointeur sur un entier <code>int *</code> contenant l'adresse m\u00e9moire de l'espace allou\u00e9 par <code>malloc</code>.</li> <li>Un espace m\u00e9moire allou\u00e9 par <code>malloc</code> et contenant des donn\u00e9es.</li> </ul> <p>L'op\u00e9ration <code>pop</code> retire l'\u00e9l\u00e9ment de la fin du tableau. Le nombre d'\u00e9l\u00e9ments est donc ajust\u00e9 en cons\u00e9quence.</p> <p> Suppression d'un \u00e9l\u00e9ment dans un tableau dynamique</p> <pre><code>if (elements &lt;= 0) exit(EXIT_FAILURE);\nint value = data[--elements];\n</code></pre> <p>L'op\u00e9ration <code>push</code> ajoute un \u00e9l\u00e9ment \u00e0 la fin du tableau.</p> <p> Ajout d'un \u00e9l\u00e9ment dans un tableau dynamique</p> <pre><code>if (elements &gt;= capacity) exit(EXIT_FAILURE);\ndata[elements++] = value;\n</code></pre> <p>L'op\u00e9ration <code>shift</code> retire un \u00e9l\u00e9ment depuis le d\u00e9but. L'op\u00e9ration \u00e0 une complexit\u00e9 de O(n) puisqu'\u00e0 chaque op\u00e9ration il est n\u00e9cessaire de d\u00e9placer chaque \u00e9l\u00e9ment qu'il contient.</p> <p> Suppression du premier \u00e9l\u00e9ment dans un tableau dynamique</p> <pre><code>if (elements &lt;= 0) exit(EXIT_FAILURE);\nint value = data[0];\nfor (int k = 0; k &lt; capacity; k++)\n    data[k] = data[k+1];\n</code></pre> <p>Une optimisation peut \u00eatre faite en d\u00e9pla\u00e7ant le pointeur de donn\u00e9e de 1 permettant de r\u00e9duite la complexit\u00e9 \u00e0 O(1) :</p> <pre><code>if (elements &lt;= 0) exit(EXIT_FAILURE);\nif (capacity &lt;= 0) exit(EXIT_FAILURE);\nint value = data[0];\ndata++;\ncapacity--;\n</code></pre> <p>Enfin, l'op\u00e9ration <code>unshift</code> ajoute un \u00e9l\u00e9ment depuis le d\u00e9but du tableau\u2009:</p> <p> Ajout d'un \u00e9l\u00e9ment en d\u00e9but d'un tableau dynamique</p> <pre><code>for (int k = elements; k &gt;= 1; k--)\n    data[k] = data[k - 1];\ndata[0] = value;\n</code></pre> <p>Dans le cas ou le nombre d'\u00e9l\u00e9ments atteint la capacit\u00e9 maximum du tableau, il est n\u00e9cessaire de r\u00e9allouer l'espace m\u00e9moire avec <code>realloc</code>. G\u00e9n\u00e9ralement on se contente de doubler l'espace allou\u00e9.</p> <pre><code>if (elements &gt;= capacity) {\n    data = realloc(data, capacity *= 2);\n}\n</code></pre>"}, {"location": "course-c/25-data-structures/containers/#buffer-circulaire", "title": "Buffer circulaire", "text": "<p>Un tampon circulaire aussi appel\u00e9 buffer circulaire ou ring buffer en anglais est g\u00e9n\u00e9ralement d'une taille fixe et poss\u00e8de deux pointeurs. L'un pointant sur le dernier \u00e9l\u00e9ment (tail) et l'un sur le premier \u00e9l\u00e9ment (head).</p> <p>Lorsqu'un \u00e9l\u00e9ment est supprim\u00e9 du buffer, le pointeur de fin est incr\u00e9ment\u00e9. Lorsqu'un \u00e9l\u00e9ment est ajout\u00e9, le pointeur de d\u00e9but est incr\u00e9ment\u00e9.</p> <p>Pour permettre la circulation, les indices sont calcul\u00e9s modulo la taille du buffer.</p> <p>Il est possible de repr\u00e9senter sch\u00e9matiquement ce buffer comme un cercle et ses deux pointeurs\u2009:</p> <p> Exemple d'un tampon circulaire</p> <p>Le nombre d'\u00e9l\u00e9ments dans le buffer est la diff\u00e9rence entre le pointeur de t\u00eate et le pointeur de queue, modulo la taille du buffer. N\u00e9anmoins, l'op\u00e9rateur <code>%</code> en C ne fonctionne que sur des nombres positifs et ne retourne pas le r\u00e9sidu positif le plus petit. En sommes, <code>-2 % 5</code> devrait donner <code>3</code>, ce qui est le cas en Python, mais en C, en C++ ou en PHP la valeur retourn\u00e9e est <code>-2</code>. Le modulo vrai, math\u00e9matiquement correct, peut \u00eatre calcul\u00e9 ainsi\u2009:</p> <pre><code>((A % M) + M) % M\n</code></pre> <p>Les indices sont boucl\u00e9s sur la taille du buffer, l'\u00e9l\u00e9ment suivant est donc d\u00e9fini par\u2009:</p> <pre><code>(i + 1) % SIZE\n</code></pre> <p>Voici une impl\u00e9mentation possible du buffer circulaire\u2009:</p> <pre><code>#define SIZE 16\n#define MOD(A, M) (((A % M) + M) % M)\n#define NEXT(A) (((A) + 1) % SIZE)\n\ntypedef struct Ring {\n    int buffer[SIZE];\n    int head;\n    int tail;\n} Ring;\n\nvoid init(Ring *ring) {\n    ring-&gt;head = ring-&gt;tail = 0;\n}\n\nint count(Ring *ring) {\n    return MOD(ring-&gt;head - ring-&gt;tail, size);\n}\n\nbool is_full(Ring *ring) {\n    return count(ring) == SIZE - 1;\n}\n\nbool is_empty(Ring *ring) {\n    return ring-&gt;tail == ring-&gt;head;\n}\n\nint* enqueue(Ring *ring, int value) {\n    if (is_full(ring)) return NULL;\n    ring-&gt;buffer[ring-&gt;head] = value;\n    int *el = &amp;ring-&gt;buffer[ring-&gt;head];\n    ring-&gt;head = NEXT(ring-&gt;head);\n    return el;\n}\n\nint* dequeue(Ring *ring) {\n    if (is_empty(ring)) return NULL;\n    int *el = &amp;ring-&gt;buffer[ring-&gt;tail];\n    ring-&gt;tail = NEXT(ring-&gt;tail);\n    return el;\n}\n</code></pre>"}, {"location": "course-c/25-data-structures/containers/#listes-chainees", "title": "Listes cha\u00een\u00e9es", "text": "<p>On s'aper\u00e7oit vite avec les tableaux que certaines op\u00e9rations sont plus co\u00fbteuses que d'autres. Ajouter ou supprimer un \u00e9l\u00e9ment \u00e0 la fin du tableau co\u00fbte \\(O(1)\\) amorti, mais ajouter ou supprimer un \u00e9l\u00e9ment \u00e0 l'int\u00e9rieur du tableau co\u00fbte \\(O(n)\\) du fait qu'il est n\u00e9cessaire de d\u00e9placer tous les \u00e9l\u00e9ments qui suivent l'\u00e9l\u00e9ment concern\u00e9.</p> <p>Une possible solution \u00e0 ce probl\u00e8me serait de pouvoir s'affranchir du lien entre les \u00e9l\u00e9ments et leurs positions en m\u00e9moire relative les uns aux autres.</p> <p>Pour illustrer cette id\u00e9e, imaginons un tableau statique dans lequel chaque \u00e9l\u00e9ment est d\u00e9crit par la structure suivante\u2009:</p> <pre><code>struct Element {\n    int value;\n    int index_next_element;\n};\n\nstruct Element elements[100];\n</code></pre> <p>Consid\u00e9rons les dix premiers \u00e9l\u00e9ments de la s\u00e9quence de nombre A130826 dans un tableau statique. Ensuite, r\u00e9partissons ces valeurs al\u00e9atoirement dans notre tableau <code>elements</code> d\u00e9clar\u00e9 plus haut entre les indices 0 et 19.</p> <p> Construction d'une liste chain\u00e9e \u00e0 l'aide d'un tableau</p> <p>On observe sur la figure ci-dessus que les \u00e9l\u00e9ments n'ont plus besoin de se suivre en m\u00e9moire, car il est possible facilement de chercher l'\u00e9l\u00e9ment suivant de la liste avec cette relation\u2009:</p> <pre><code>struct Element current = elements[4];\nstruct Element next = elements[current.index_next_element]\n</code></pre> <p>De m\u00eame, ins\u00e9rer une nouvelle valeur <code>13</code> apr\u00e8s la valeur <code>42</code> est tr\u00e8s facile\u2009:</p> <pre><code>// Recherche de l'\u00e9l\u00e9ment contenant la valeur 42\nstruct Element el = elements[0];\nwhile (el.value != 42 &amp;&amp; el.index_next_element != -1) {\n    el = elements[el.index_next_element];\n}\nif (el.value != 42) abort();\n\n// Recherche d'un \u00e9l\u00e9ment libre\nconst int length = sizeof(elements) / sizeof(elements[0]);\nint k;\nfor (k = 0; k &lt; length; k++)\n    if (elements[k].index_next_element == -1)\n        break;\nassert(k &lt; length &amp;&amp; elements[k].index_next_element == -1);\n\n// Cr\u00e9ation d'un nouvel \u00e9l\u00e9ment\nstruct Element new = (Element){\n    .value = 13,\n    .index_next_element = -1\n};\n\n// Insertion de l'\u00e9l\u00e9ment quelque part dans le tableau\nel.index_next_element = k;\nelements[el.index_next_element] = new;\n</code></pre> <p>Cette solution d'utiliser un lien vers l'\u00e9l\u00e9ment suivant et s'appelle liste cha\u00een\u00e9e. Chaque \u00e9l\u00e9ment dispose d'un lien vers l'\u00e9l\u00e9ment suivant situ\u00e9 quelque part en m\u00e9moire. Les op\u00e9rations d'insertion et de suppression au milieu de la cha\u00eene sont maintenant effectu\u00e9es en \\(O(1)\\) contre \\(O(n)\\) pour un tableau standard. En revanche l'espace n\u00e9cessaire pour stocker ce tableau est doubl\u00e9 puisqu'il faut associer \u00e0 chaque valeur le lien vers l'\u00e9l\u00e9ment suivant.</p> <p>D'autre part, la solution propos\u00e9e n'est pas optimale\u2009:</p> <ul> <li>L'\u00e9l\u00e9ment 0 est un cas particulier qu'il faut traiter diff\u00e9remment. Le premier \u00e9l\u00e9ment de la liste doit toujours \u00eatre positionn\u00e9 \u00e0 l'indice 0 du tableau. Ins\u00e9rer un nouvel \u00e9l\u00e9ment en d\u00e9but de tableau demande de d\u00e9placer cet \u00e9l\u00e9ment ailleurs en m\u00e9moire.</li> <li>Rechercher un \u00e9l\u00e9ment libre prend du temps.</li> <li>Supprimer un \u00e9l\u00e9ment dans le tableau laisse une place m\u00e9moire vide. Il devient alors difficile de savoir o\u00f9 sont les emplacements m\u00e9moires disponibles.</li> </ul> <p>Une liste cha\u00een\u00e9e est une structure de donn\u00e9es permettant de lier des \u00e9l\u00e9ments structur\u00e9s entre eux. La liste est caract\u00e9ris\u00e9e par\u2009:</p> <ul> <li>un \u00e9l\u00e9ment de t\u00eate (head),</li> <li>un \u00e9l\u00e9ment de queue (tail).</li> </ul> <p>Un \u00e9l\u00e9ment est caract\u00e9ris\u00e9 par\u2009:</p> <ul> <li>un contenu (payload),</li> <li>une r\u00e9f\u00e9rence vers l'\u00e9l\u00e9ment suivant et/ou pr\u00e9c\u00e9dent dans la liste.</li> </ul> <p>Les listes cha\u00een\u00e9es r\u00e9duisent la complexit\u00e9 li\u00e9e \u00e0 la manipulation d'\u00e9l\u00e9ments dans une liste. L'empreinte m\u00e9moire d'une liste cha\u00een\u00e9e est plus grande qu'avec un tableau, car \u00e0 chaque \u00e9l\u00e9ment de donn\u00e9e est associ\u00e9 un pointeur vers l'\u00e9l\u00e9ment suivant ou pr\u00e9c\u00e9dent.</p> <p>Ce surco\u00fbt est souvent part du compromis entre la complexit\u00e9 d'ex\u00e9cution du code et la m\u00e9moire utilis\u00e9e par ce programme.</p>  Co\u00fbt des op\u00e9rations dans des structures de donn\u00e9es r\u00e9cursives Structure de donn\u00e9e Pire cas Insertion Suppression Recherche (Tri\u00e9) Recherche (Non tri\u00e9) Tableau, pile, queue \\(O(n)\\) \\(O(n)\\) \\(O(\\log(n))\\) \\(O(n)\\) Liste cha\u00een\u00e9e simple \\(O(1)\\) \\(O(1)\\) \\(O(n)\\) \\(O(n)\\)"}, {"location": "course-c/25-data-structures/containers/#liste-simplement-chainee-linked-list", "title": "Liste simplement cha\u00een\u00e9e (linked-list)", "text": "<p>La figure suivante illustre un set d'\u00e9l\u00e9ments li\u00e9s entre eux \u00e0 l'aide d'un pointeur rattach\u00e9 \u00e0 chaque \u00e9l\u00e9ment. On peut s'imaginer que chaque \u00e9l\u00e9ment peut se situer n'importe o\u00f9 en m\u00e9moire et qu'il n'est alors pas indispensable que les \u00e9l\u00e9ments se suivent dans l'ordre.</p> <p>Il est indispensable de bien identifier le dernier \u00e9l\u00e9ment de la liste gr\u00e2ce \u00e0 son pointeur associ\u00e9 \u00e0 la valeur <code>NULL</code>.</p> <p> Liste cha\u00een\u00e9e simple</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstruct Point\n{\n    double x;\n    double y;\n    double z;\n};\n\nstruct Element\n{\n    struct Point point;\n    struct Element* next;\n};\n\nint main(void)\n{\n    struct Element a = {.point = {1,2,3}, .next = NULL};\n    struct Element b = {.point = {4,5,6}, .next = &amp;a};\n    struct Element c = {.point = {7,8,9}, .next = &amp;b};\n\n    a.next = &amp;c;\n\n    struct Element* walk = &amp;a;\n\n    for (size_t i = 0; i &lt; 10; i++)\n    {\n        printf(\"%d. P(x, y, z) = %0.2f, %0.2f, %0.2f\\n\",\n            i,\n            walk-&gt;point.x,\n            walk-&gt;point.y,\n            walk-&gt;point.z\n        );\n\n        walk = walk-&gt;next;\n    }\n}\n</code></pre>"}, {"location": "course-c/25-data-structures/containers/#operations-sur-une-liste-chainee", "title": "Op\u00e9rations sur une liste cha\u00een\u00e9e", "text": "<ul> <li>Cr\u00e9ation</li> <li>Nombre d'\u00e9l\u00e9ments</li> <li>Recherche</li> <li>Insertion</li> <li>Suppression</li> <li>Concat\u00e9nation</li> <li>Destruction</li> </ul> <p>Lors de la cr\u00e9ation d'un \u00e9l\u00e9ment, on utilise principalement le m\u00e9canisme de l'allocation dynamique ce qui permet de r\u00e9cup\u00e9rer l'adresse de l'\u00e9l\u00e9ment et de faciliter sa manipulation au travers de la liste. \u00a0Ne pas oublier de lib\u00e9rer la m\u00e9moire allou\u00e9e pour les \u00e9l\u00e9ments lors de leur suppression\u2026</p>"}, {"location": "course-c/25-data-structures/containers/#calcul-du-nombre-delements-dans-la-liste", "title": "Calcul du nombre d'\u00e9l\u00e9ments dans la liste", "text": "<p>Pour \u00e9valuer le nombre d'\u00e9l\u00e9ments dans une liste, on effectue le parcours de la liste \u00e0 partir de la t\u00eate, et on passe d'\u00e9l\u00e9ment en \u00e9l\u00e9ment gr\u00e2ce au champ next de la structure <code>Element</code>. On incr\u00e9ment le nombre d'\u00e9l\u00e9ments jusqu'\u00e0 ce que le pointeur next soit \u00e9gal \u00e0 <code>NULL</code>.</p> <pre><code>size_t count = 0;\n\nfor (Element *e = &amp;head; e != NULL; e = e-&gt;next)\n    count++;\n</code></pre>"}, {"location": "course-c/25-data-structures/containers/#detection-des-boucles", "title": "D\u00e9tection des boucles", "text": "<p>Attention, la technique pr\u00e9c\u00e9dente ne fonctionne pas dans tous les cas, sp\u00e9cialement lorsqu'il y a des boucles dans la liste cha\u00een\u00e9e. Prenons l'exemple suivant\u2009:</p> <p> Boucle dans une liste cha\u00een\u00e9e</p> <p>La liste se terminant par une boucle, il n'y aura jamais d'\u00e9l\u00e9ment de fin et le nombre d'\u00e9l\u00e9ments calcul\u00e9 sera infini. Or, cette liste a un nombre fixe d'\u00e9l\u00e9ments. Comment donc les compter\u2009?</p> <p>Il existe un algorithme nomm\u00e9 d\u00e9tection de cycle de Robert W. Floyd aussi appel\u00e9 algorithme du li\u00e8vre et de la tortue. Il consiste \u00e0 avoir deux pointeurs qui parcourent la liste cha\u00een\u00e9e. L'un avance deux fois plus vite que le second.</p> <p> Algorithme de d\u00e9tection de cycle de Robert W. Floyd</p> <pre><code>size_t compute_length(Element* head)\n{\n    size_t count = 0;\n\n    Element* slow = head;\n    Element* fast = head;\n\n    while (fast != NULL &amp;&amp; fast-&gt;next != NULL) {\n        slow = slow-&gt;next;\n        fast = fast-&gt;next-&gt;next;\n\n        count++;\n\n        if (slow == fast) {\n            // Collision\n            break;\n        }\n    }\n\n    // Case when no loops detected\n    if (fast == NULL || fast-&gt;next == NULL) {\n        return count;\n    }\n\n    // Move slow to head, keep fast at meeting point.\n    slow = head;\n    while (slow != fast) {\n        slow = slow-&gt;next;\n        fast = fast-&gt;next;\n\n        count--;\n    }\n\n    return count;\n}\n</code></pre> <p>Astuce</p> <p>Une bonne id\u00e9e pour se simplifier la vie est simplement d'\u00e9viter la cr\u00e9ation de boucles.</p>"}, {"location": "course-c/25-data-structures/containers/#insertion", "title": "Insertion", "text": "<p>L'insertion d'un \u00e9l\u00e9ment dans une liste cha\u00een\u00e9e peut-\u00eatre impl\u00e9ment\u00e9e de la fa\u00e7on suivante\u2009:</p> <pre><code>Element* insert_after(Element* e, void* payload)\n{\n    Element* new = malloc(sizeof(Element));\n\n    memcpy(new-&gt;payload, payload, sizeof(new-&gt;payload));\n\n    new-&gt;next = e-&gt;next;\n    e-&gt;next = new;\n\n    return new;\n}\n</code></pre>"}, {"location": "course-c/25-data-structures/containers/#suppression", "title": "Suppression", "text": "<p>La suppression implique d'acc\u00e9der \u00e0 l'\u00e9l\u00e9ment parent, il n'est donc pas possible \u00e0 partir d'un \u00e9l\u00e9ment donn\u00e9 de le supprimer de la liste.</p> <pre><code>void delete_after(Element* e)\n{\n    e-&gt;next = e-&gt;next-&gt;next;\n    free(e);\n}\n</code></pre>"}, {"location": "course-c/25-data-structures/containers/#recherche", "title": "Recherche", "text": "<p>Rechercher dans une liste cha\u00een\u00e9e est une question qui peut-\u00eatre complexe et il est n\u00e9cessaire de ce poser un certain nombre de questions\u2009:</p> <ul> <li>Est-ce que la liste est tri\u00e9e\u2009?</li> <li>Combien d'espace m\u00e9moire puis-je utiliser\u2009?</li> </ul> <p>On sait qu'une recherche id\u00e9ale s'effectue en \\(O(log(n))\\), mais que la solution triviale en \\(O(n)\\) est la suivante\u2009:</p>"}, {"location": "course-c/25-data-structures/containers/#liste-doublement-chainee", "title": "Liste doublement cha\u00een\u00e9e", "text": "<p> Liste cha\u00een\u00e9e simple</p>"}, {"location": "course-c/25-data-structures/containers/#liste-chainee-xor", "title": "Liste cha\u00een\u00e9e XOR", "text": "<p>L'inconv\u00e9nient d'une liste doublement cha\u00een\u00e9e est le surco\u00fbt n\u00e9cessaire au stockage d'un \u00e9l\u00e9ment. Chaque \u00e9l\u00e9ment contient en effet deux pointeurs sur l'\u00e9l\u00e9ment pr\u00e9c\u00e9dent (prev) et suivant (next).</p> <pre><code>...  A       B         C         D         E  ...\n        \u2013&gt;  next \u2013&gt;  next  \u2013&gt;  next  \u2013&gt;\n        &lt;\u2013  prev &lt;\u2013  prev  &lt;\u2013  prev  &lt;\u2013\n</code></pre> <p>Cette liste cha\u00een\u00e9e particuli\u00e8re compresse les deux pointeurs en un seul en utilisant l'op\u00e9ration XOR (d\u00e9not\u00e9e \u2295).</p> <pre><code>...  A        B         C         D         E  ...\n        &lt;\u2013&gt;  A\u2295C  &lt;-&gt;  B\u2295D  &lt;-&gt;  C\u2295E  &lt;-&gt;\n</code></pre> <p>Lorsque la liste est travers\u00e9e de gauche \u00e0 droite, il est possible de facilement reconstruire le pointeur de l'\u00e9l\u00e9ment suivant \u00e0 partir de l'adresse de l'\u00e9l\u00e9ment pr\u00e9c\u00e9dent.</p> <p>Les inconv\u00e9nients de cette structure sont\u2009:</p> <ul> <li>Difficult\u00e9s de d\u00e9bogage</li> <li>Complexit\u00e9 de mise en \u0153uvre</li> </ul> <p>L'avantage principal \u00e9tant le gain de place en m\u00e9moire.</p>"}, {"location": "course-c/25-data-structures/containers/#liste-chainee-deroulee-unrolled-linked-list", "title": "Liste cha\u00een\u00e9e d\u00e9roul\u00e9e (Unrolled linked list)", "text": "<p>Une liste cha\u00een\u00e9e d\u00e9roul\u00e9e rassemble les avantages d'un tableau et d'une liste cha\u00een\u00e9e. Elle permet d'accro\u00eetre les performances en r\u00e9duisant l'overhead de r\u00e9servation m\u00e9moire avec <code>malloc</code>.</p> <p> Liste cha\u00een\u00e9e d\u00e9roul\u00e9e</p> <pre><code>typedef struct Node {\n    struct Node *next;\n    size_t count;  // Nombre d'\u00e9l\u00e9ments\n    int elements[]; // Membre flexible contenant les \u00e9l\u00e9ments\n} Node;\n</code></pre>"}, {"location": "course-c/25-data-structures/containers/#piles-ou-lifo-last-in-first-out", "title": "Piles ou LIFO (Last In First Out)", "text": "<p>Une pile est une structure de donn\u00e9e tr\u00e8s similaire \u00e0 un tableau dynamique, mais dans laquelle les op\u00e9rations sont limit\u00e9es. Par exemple, il n'est possible que\u2009:</p> <ul> <li>d'ajouter un \u00e9l\u00e9ment (push) ;</li> <li>retirer un \u00e9l\u00e9ment (pop) ;</li> <li>obtenir le dernier \u00e9l\u00e9ment ajout\u00e9 (peek) ;</li> <li>tester si la pile est vide (is_empty) ;</li> <li>tester si la pile est pleine avec (is_full).</li> </ul> <p>Une utilisation possible de pile sur des entiers serait la suivante\u2009:</p> <pre><code>#include \"stack.h\"\n\nint main() {\n    Stack stack;\n    stack_init(&amp;stack);\n\n    stack_push(42);\n    assert(stack_peek() == 42);\n\n    stack_push(23);\n    assert(!stack_is_empty());\n\n    assert(stack_pop() == 23);\n    assert(stack_pop() == 42);\n\n    assert(stack_is_empty());\n}\n</code></pre> <p>Les piles peuvent \u00eatre impl\u00e9ment\u00e9es avec des tableaux dynamiques ou des listes cha\u00een\u00e9es (voir plus bas).</p>"}, {"location": "course-c/25-data-structures/containers/#queues-ou-fifo-first-in-first-out", "title": "Queues ou FIFO (First In First Out)", "text": "<p>Les queues sont aussi des structures tr\u00e8s similaires \u00e0 des tableaux dynamiques, mais elles ne permettent que les op\u00e9rations suivantes\u2009:</p> <ul> <li>ajouter un \u00e9l\u00e9ment \u00e0 la queue (push) aussi nomm\u00e9 enqueue ;</li> <li>supprimer un \u00e9l\u00e9ment au d\u00e9but de la queue (shift) aussi nomm\u00e9 dequeue ;</li> <li>tester si la queue est vide (is_empty) ;</li> <li>tester si la queue est pleine avec (is_full).</li> </ul> <p>Les queues sont souvent utilis\u00e9es lorsque des processus s\u00e9quentiels ou parall\u00e8les s'\u00e9changent des t\u00e2ches \u00e0 traiter\u2009:</p> <pre><code>#include \"queue.h\"\n#include &lt;stdio.h&gt;\n\nvoid get_work(Queue *queue) {\n    while (!feof(stdin)) {\n        int n;\n        if (scanf(\"%d\", &amp;n) == 1)\n            queue_enqueue(n);\n        scanf(\"%*[^\\n]%[\\n]\");\n    }\n}\n\nvoid process_work(Queue *queue) {\n    while (!is_empty(queue)) {\n        int n = queue_dequeue(queue);\n        printf(\"%d est %s\\n\", n, n % 2 ? \"impair\" : \"pair\";\n    }\n}\n\nint main() {\n    Queue* queue;\n\n    queue_init(&amp;queue);\n    get_work(queue);\n    process_work(queue);\n    queue_free(queue);\n}\n</code></pre>"}, {"location": "course-c/25-data-structures/containers/#performances", "title": "Performances", "text": "<p>Les diff\u00e9rentes structures de donn\u00e9es ne sont pas toutes \u00e9quivalentes en termes de performances. Il convient, selon l'application, d'opter pour la structure la plus adapt\u00e9e, et par cons\u00e9quent il est important de pouvoir comparer les diff\u00e9rentes structures de donn\u00e9es pour choisir la plus appropri\u00e9e. Est-ce que les donn\u00e9es doivent \u00eatre maintenues tri\u00e9es\u2009? Est-ce que la structure de donn\u00e9e est utilis\u00e9e comme une pile ou un tas\u2009? Quelle est la structure de donn\u00e9e avec le moins d'overhead pour les op\u00e9rations de <code>push</code> ou <code>unshift</code> ?</p> <p>L'indexation (indexing) est l'acc\u00e8s \u00e0 une certaine valeur du tableau par exemple avec <code>a[k]</code>. Dans un tableau statique et dynamique l'acc\u00e8s se fait par pointeur depuis le d\u00e9but du tableau soit\u2009: <code>*((char*)a + sizeof(a[0]) * k)</code> qui est \u00e9quivalant \u00e0 <code>*(a + k)</code>. L'indexation par arithm\u00e9tique de pointeur n'est pas possible avec les listes cha\u00een\u00e9es dont il faut parcourir chaque \u00e9l\u00e9ment pour d\u00e9couvrir l'adresse du prochain \u00e9l\u00e9ment\u2009:</p> <pre><code>int get(List *list) {\n    List *el = list-&gt;head;\n    for(int i = 0; i &lt; k; i++)\n        el = el.next;\n    return el.value;\n}\n</code></pre> <p>L'indexation d'une liste cha\u00een\u00e9e prend dans le cas le plus d\u00e9favorable \\(O(n)\\).</p> <p>Les arbres binaires ont une structure qui permet naturellement la dichotomique. Chercher l'\u00e9l\u00e9ment 5 prend 4 op\u00e9rations\u2009: <code>12 -&gt; 4 -&gt; 6 -&gt; 5</code>. L'indexation est ainsi possible en \\(O(log~n)\\).</p> <pre><code>            12\n             |\n         ----+----\n       /           \\\n      4            12\n     --            --\n   /    \\        /    \\\n  2      6      10    14\n / \\    / \\    / \\   /  \\\n1   3  5   7  9  11 13  15\n</code></pre> <p>Le tableau suivant r\u00e9sume les performances obtenues pour les diff\u00e9rentes structures de donn\u00e9es que nous avons vues dans ce chapitre\u2009:</p>  Comparaison des performances des structures r\u00e9cursives Action Tableau Liste Buffer Arbre Hash Map Statique Dynamique cha\u00een\u00e9e circulaire binaire Indexing 1 1 n 1 log n Unshift/Shift n n 1 1 log n Push/Pop 1 1 amorti 1 1 log n Insert/Delete n n 1 n log n Search n n n n log n Sort n log n n log n n log n n log n 1"}, {"location": "course-c/25-data-structures/containers/graphs/", "title": "Graphes", "text": "<p>Un graphe est un ensemble de sommets reli\u00e9s par des ar\u00eates. Les graphes sont utilis\u00e9s pour mod\u00e9liser des relations entre des objets. Par exemple, un graphe peut \u00eatre utilis\u00e9 pour repr\u00e9senter un r\u00e9seau social, un r\u00e9seau de transport, un r\u00e9seau de distribution, etc.</p> <p>C'est une variante g\u00e9n\u00e9rale des arbres. Un arbre est un graphe particulier o\u00f9 chaque sommet est reli\u00e9 \u00e0 un autre sommet par un chemin unique. Un graphe peut avoir des cycles, c'est-\u00e0-dire des chemins qui reviennent \u00e0 leur point de d\u00e9part.</p>"}, {"location": "course-c/25-data-structures/containers/graphs/#types-de-graphes", "title": "Types de graphes", "text": ""}, {"location": "course-c/25-data-structures/containers/graphs/#forets", "title": "For\u00eats", "text": "<p>Un graphe sans cycle est appel\u00e9 une for\u00eat. Une for\u00eat est un ensemble d'arbres. Un arbre est un graphe connexe sans cycle.</p>"}, {"location": "course-c/25-data-structures/containers/graphs/#graphes-orientes", "title": "Graphes orient\u00e9s", "text": "<p>Un graphe orient\u00e9 est un graphe dont les ar\u00eates ont une direction. Les graphes orient\u00e9s sont utilis\u00e9s pour mod\u00e9liser des relations asym\u00e9triques. Par exemple, un graphe orient\u00e9 peut \u00eatre utilis\u00e9 pour repr\u00e9senter un r\u00e9seau de transport o\u00f9 les ar\u00eates repr\u00e9sentent des routes \u00e0 sens unique.</p>"}, {"location": "course-c/25-data-structures/containers/graphs/#graphes-ponderes", "title": "Graphes pond\u00e9r\u00e9s", "text": "<p>Un graphe pond\u00e9r\u00e9 est un graphe dont les ar\u00eates ont un poids. Les graphes pond\u00e9r\u00e9s sont utilis\u00e9s pour mod\u00e9liser des relations quantitatives. Par exemple, un graphe pond\u00e9r\u00e9 peut \u00eatre utilis\u00e9 pour repr\u00e9senter un r\u00e9seau de transport o\u00f9 les ar\u00eates repr\u00e9sentent des routes avec une longueur ou un co\u00fbt associ\u00e9.</p>"}, {"location": "course-c/25-data-structures/containers/graphs/#graphes-bipartis", "title": "Graphes bipartis", "text": "<p>Un graphe biparti est un graphe dont les sommets peuvent \u00eatre divis\u00e9s en deux ensembles disjoints. Les ar\u00eates d'un graphe biparti relient les sommets des deux ensembles. Les graphes bipartis sont utilis\u00e9s pour mod\u00e9liser des relations binaires. Par exemple, un graphe biparti peut \u00eatre utilis\u00e9 pour repr\u00e9senter des relations d'adjacence entre deux ensembles d'objets.</p>"}, {"location": "course-c/25-data-structures/containers/graphs/#representation-des-graphes", "title": "Repr\u00e9sentation des graphes", "text": "<p>Il existe plusieurs fa\u00e7ons de repr\u00e9senter un graphe en m\u00e9moire. Les deux repr\u00e9sentations les plus courantes sont les listes d'adjacence et les matrices d'adjacence.</p>"}, {"location": "course-c/25-data-structures/containers/graphs/#liste-dadjacence", "title": "Liste d'adjacence", "text": "<p>Dans une liste d'adjacence, chaque sommet est associ\u00e9 \u00e0 une liste de ses voisins. Une liste d'adjacence est une structure de donn\u00e9es dynamique qui permet d'ajouter et de supprimer des ar\u00eates facilement. Cependant, elle n\u00e9cessite plus de m\u00e9moire que les matrices d'adjacence.</p>"}, {"location": "course-c/25-data-structures/containers/graphs/#matrice-dadjacence", "title": "Matrice d'adjacence", "text": "<p>Dans une matrice d'adjacence, chaque sommet est associ\u00e9 \u00e0 une ligne et une colonne de la matrice. La valeur de la case (i, j) de la matrice indique s'il existe une ar\u00eate entre les sommets i et j. Une matrice d'adjacence est une structure de donn\u00e9es statique qui permet de v\u00e9rifier rapidement l'existence d'une ar\u00eate. Cependant, elle n\u00e9cessite plus de m\u00e9moire que les listes d'adjacence.</p>"}, {"location": "course-c/25-data-structures/containers/graphs/#parcours-de-graphes", "title": "Parcours de graphes", "text": "<p>Il existe plusieurs algorithmes pour parcourir un graphe. Les deux algorithmes les plus courants sont le parcours en profondeur (DFS) et le parcours en largeur (BFS).</p>"}, {"location": "course-c/25-data-structures/containers/graphs/#dfs", "title": "DFS", "text": "<p>Le parcours en profondeur (Depth-First Search) est un algorithme r\u00e9cursif qui explore le graphe en profondeur. Il commence par un sommet de d\u00e9part et explore tous les sommets accessibles depuis ce sommet avant de passer au suivant. L'algorithme DFS est utilis\u00e9 pour trouver des cycles dans un graphe, pour v\u00e9rifier la connexit\u00e9 d'un graphe, pour trouver des composantes fortement connexes, etc.</p>"}, {"location": "course-c/25-data-structures/containers/graphs/#bfs", "title": "BFS", "text": "<p>Le parcours en largeur (Breadth-First Search) est un algorithme it\u00e9ratif qui explore le graphe en largeur. Il commence par un sommet de d\u00e9part et explore tous les sommets \u00e0 une distance k avant de passer \u00e0 la distance k+1. L'algorithme BFS est utilis\u00e9 pour trouver le plus court chemin entre deux sommets, pour trouver le nombre de composantes connexes, pour trouver le nombre de sommets \u00e0 une distance donn\u00e9e, etc.</p>"}, {"location": "course-c/25-data-structures/containers/graphs/#dijkstra", "title": "Dijkstra", "text": "<p>L'algorithme de Dijkstra est un algorithme qui permet de trouver le plus court chemin entre un sommet de d\u00e9part et tous les autres sommets d'un graphe pond\u00e9r\u00e9. L'algorithme de Dijkstra est bas\u00e9 sur le parcours en largeur et utilise une file de priorit\u00e9 pour explorer les sommets dans l'ordre croissant de leur distance par rapport au sommet de d\u00e9part.</p>"}, {"location": "course-c/25-data-structures/containers/maps/", "title": "Tableaux de hachage", "text": "<p>Les tableaux de hachage (Hash Table) sont une structure particuli\u00e8re dans laquelle une fonction dite de hachage est utilis\u00e9e pour transformer les entr\u00e9es en des indices d'un tableau.</p> <p>L'objectif est de stocker des cha\u00eenes de caract\u00e8res correspondant a des noms simples ici utilis\u00e9s pour l'exemple. Une possible r\u00e9partition serait la suivante\u2009:</p> <p> Tableau de hachage simple</p> <p>Si l'on cherche l'indice correspondant \u00e0 <code>Ada</code>, il convient de pouvoir calculer la valeur de l'indice correspondant \u00e0 partir de la valeur de la cha\u00eene de caract\u00e8re. Pour calculer cet indice aussi appel\u00e9 hash, il existe une infinit\u00e9 de m\u00e9thodes. Dans cet exemple, consid\u00e9rons une m\u00e9thode simple. Chaque lettre est identifi\u00e9e par sa valeur ASCII et la somme de toutes les valeurs ASCII est calcul\u00e9e. Le modulo 10 est ensuite calcul\u00e9 sur cette somme pour obtenir une valeur entre 0 et 9. Ainsi nous avons les calculs suivants\u2009:</p> <pre><code>Nom    Valeurs ASCII     Somme  Modulo 10\n---    --------------    -----  ---------\nMia -&gt; {77, 105, 97}  -&gt; 279 -&gt; 4\nTim -&gt; {84, 105, 109} -&gt; 298 -&gt; 1\nBea -&gt; {66, 101, 97}  -&gt; 264 -&gt; 0\nZoe -&gt; {90, 111, 101} -&gt; 302 -&gt; 5\nJan -&gt; {74, 97, 110}  -&gt; 281 -&gt; 6\nAda -&gt; {65, 100, 97}  -&gt; 262 -&gt; 9\nLeo -&gt; {76, 101, 111} -&gt; 288 -&gt; 2\nSam -&gt; {83, 97, 109}  -&gt; 289 -&gt; 3\nLou -&gt; {76, 111, 117} -&gt; 304 -&gt; 7\nMax -&gt; {77, 97, 120}  -&gt; 294 -&gt; 8\nTed -&gt; {84, 101, 100} -&gt; 285 -&gt; 10\n</code></pre> <p>Pour trouver l'indice de <code>\"Mia\"</code> il suffit donc d'appeler la fonction suivante\u2009:</p> <pre><code>int hash_str(char *s) {\n    int sum = 0;\n    while (*s != '\\0') sum += s++;\n    return sum % 10;\n}\n</code></pre> <p>L'assertion suivante est donc vraie\u2009:</p> <pre><code>assert(strcmp(table[hash_str(\"Mia\")], \"Mia\") == 0);\n</code></pre> <p>Rechercher <code>\"Mia\"</code> et obtenir <code>\"Mia\"</code> n'est certainement pas l'exemple le plus utile. N\u00e9anmoins il est possible d'encoder plus qu'une cha\u00eene de caract\u00e8re et utiliser plut\u00f4t une structure de donn\u00e9e\u2009:</p> <pre><code>struct Person {\n    char name[3 + 1 /* '\\0' */];\n    struct {\n        int month;\n        int day;\n        int year;\n    } born;\n    enum {\n        JOB_ASTRONOMER,\n        JOB_INVENTOR,\n        JOB_ACTRESS,\n        JOB_LOGICIAN,\n        JOB_BIOLOGIST\n    } job;\n    char country_code; // For example 41 for Switzerland\n};\n</code></pre> <p>Dans ce cas, le calcul du hash se ferait sur la premi\u00e8re cl\u00e9 d'un \u00e9l\u00e9ment\u2009:</p> <pre><code>int hash_person(struct Person person) {\n    int sum = 0;\n    while (*person.name != '\\0') sum += s++;\n    return sum % 10;\n}\n</code></pre> <p>L'acc\u00e8s \u00e0 une personne \u00e0 partir de la cl\u00e9 se r\u00e9sout donc en <code>O(1)</code> car il n'y a aucune it\u00e9ration ou recherche \u00e0 effectuer.</p> <p>Cette vid\u00e9o YouTube explique bien le fonctionnement des tableaux de hachage.</p>"}, {"location": "course-c/25-data-structures/containers/maps/#collisions", "title": "Collisions", "text": "<p>Lorsque la fonction de hachage est mal choisie, un certain nombre de collisions peuvent appara\u00eetre. Si l'on souhaite par exemple ajouter les personnes suivantes\u2009:</p> <pre><code>Sue -&gt; {83, 117, 101} -&gt; 301 -&gt; 4\nLen -&gt; {76, 101, 110} -&gt; 287 -&gt; 1\n</code></pre> <p>On voit que les positions <code>4</code> et <code>1</code> sont d\u00e9j\u00e0 occup\u00e9es par Mia et Tim.</p> <p>Une strat\u00e9gie de r\u00e9solution s'appelle Open adressing. Parmi les possibilit\u00e9s de cette strat\u00e9gie, le linear probing consiste \u00e0 v\u00e9rifier si la position du tableau est d\u00e9j\u00e0 occup\u00e9e et en cas de collision, chercher la prochaine place disponible dans le tableau\u2009:</p> <pre><code>Person people[10] = {0}\n\n// Add Mia\nPerson mia = {.name=\"Mia\", .born={.day=1,.month=4,.year=1991}};\nint hash = hash_person(mia);\nwhile (people[hash].name[0] != '\\0') hash++;\npeople[hash] = mia;\n</code></pre> <p>R\u00e9cup\u00e9rer une valeur dans le tableau demande une comparaison suppl\u00e9mentaire\u2009:</p> <pre><code>char key[] = \"Mia\";\nint hash = hash_str(key)\nwhile (strcmp(people[hash], key) != 0) hash++;\nPerson person = people[hash];\n</code></pre> <p>Lorsque le nombre de collisions est n\u00e9gligeable par rapport \u00e0 la table de hachage, la recherche d'un \u00e9l\u00e9ment est toujours en moyenne \u00e9gale \u00e0 \\(O(1)\\), mais lorsque le nombre de collisions est pr\u00e9pond\u00e9rant, la complexit\u00e9 se rapproche de celle de la recherche lin\u00e9aire \\(O(n)\\) et on perd tout avantage \u00e0 cette structure de donn\u00e9e.</p> <p>Dans le cas extr\u00eame, pour garantir un acc\u00e8s unitaire pour tous les noms de trois lettres, il faudrait un tableau de hachage d'une taille \\(26^3 = 17576\\) personnes. L'empreinte m\u00e9moire peut \u00eatre consid\u00e9rablement r\u00e9duite en stockant non pas une structure <code>struct Person</code> mais plut\u00f4t l'adresse vers cette structure\u2009:</p> <pre><code>struct Person *people[26 * 26 * 26] = { NULL };\n</code></pre> <p>Dans ce cas exag\u00e9r\u00e9, la fonction de hachage pourrait \u00eatre la suivante\u2009:</p> <pre><code>int hash_name(char name[4]) {\n    int base = 26;\n    return\n        (name[0] - 'A') * 1 +\n        (name[1] - 'a') * 26 +\n        (name[2] - 'a') * 26 * 26;\n}\n</code></pre>"}, {"location": "course-c/25-data-structures/containers/maps/#facteur-de-charge", "title": "Facteur de charge", "text": "<p>Le facteur de charge d'une table de hachage est donn\u00e9 par la relation\u2009:</p> \\[ \\text{Facteur de charge} = \\frac{\\text{Nombre total d'\u00e9l\u00e9ments}}{\\text{Taille de la table}} \\] <p>Plus ce facteur de charge est \u00e9lev\u00e9, dans le cas du linear probing, moins bon sera la performance de la table de hachage.</p> <p>Certains algorithmes permettent de redimensionner dynamiquement la table de hachage pour conserver un facteur de charge le plus faible possible. Quand le facteur de charge d\u00e9passe un certain seuil (souvent 0.7), la table de hachage est agrandi (souvent doubl\u00e9e comme pour un tableau dynamique) et les \u00e9l\u00e9ments sont re-hach\u00e9s dans la nouvelle table.</p>"}, {"location": "course-c/25-data-structures/containers/maps/#chainage", "title": "Cha\u00eenage", "text": "<p>Le cha\u00eenage ou chaining est une autre m\u00e9thode pour mieux g\u00e9rer les collisions. La table de hachage est coupl\u00e9e \u00e0 une liste cha\u00een\u00e9e.</p> <p> Cha\u00eenage d'une table de hachage</p>"}, {"location": "course-c/25-data-structures/containers/maps/#adressage-ouvert", "title": "Adressage ouvert", "text": "<p>L'adressage ouvert est une autre m\u00e9thode pour g\u00e9rer les collisions. Lorsqu'une collision est d\u00e9tect\u00e9e, une autre position est calcul\u00e9e pour stocker l'\u00e9l\u00e9ment.</p> <p>Si une collision est d\u00e9tect\u00e9e, on regardera la position suivante dans la table. Si elle est libre on l'utilise, sinon la suitante, jusqu'\u00e0 trouver une position libre. Cette m\u00e9thode est appel\u00e9e linear probing.</p> <p>Une autre m\u00e9thode consiste \u00e0 utiliser une fonction de hachage secondaire pour calculer la position suivante. Cette m\u00e9thode est appel\u00e9e double hashing.</p> <p>Si la m\u00e9thode est plus facile \u00e0 impl\u00e9menter, l'op\u00e9ration de suppression est plus complexe. En effet, il est souvent n\u00e9cessaire de re-hacher les \u00e9l\u00e9ments pour maintenir la performance de la table de hachage.</p>"}, {"location": "course-c/25-data-structures/containers/maps/#fonction-de-hachage", "title": "Fonction de hachage", "text": "<p>Nous avons vu plus haut une fonction de hachage calculant le modulo sur la somme des caract\u00e8res ASCII d'une cha\u00eene de caract\u00e8res. Nous avons \u00e9galement vu que cette fonction de hachage est source de nombreuses collisions. Les cha\u00eenes <code>\"Rea\"</code> ou <code>\"Rae\"</code> auront les m\u00eame hash puisqu'ils contiennent les m\u00eames lettres. De m\u00eame une fonction de hachage qui ne r\u00e9partit pas bien les \u00e9l\u00e9ments dans la table de hachage sera mauvaise. On sait par exemple que les voyelles sont nombreuses dans les mots et qu'il n'y en a que six et que la probabilit\u00e9 que nos noms de trois lettres contiennent une voyelle en leur milieu est tr\u00e8s \u00e9lev\u00e9e.</p> <p>L'id\u00e9e g\u00e9n\u00e9rale des fonctions de hachage est de r\u00e9partir uniform\u00e9ment les cl\u00e9s sur les indices de la table de hachage. L'approche la plus courante est de m\u00e9langer les bits de notre cl\u00e9 dans un processus reproductible.</p> <p>Une id\u00e9e mauvaise et \u00e0 ne pas retenir pourrait \u00eatre d'utiliser le caract\u00e8re pseudo-al\u00e9atoire de <code>rand</code> pour hacher nos noms\u2009:</p> <pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\nint hash(char *str, int mod) {\n    int h = 0;\n    while(*str != '\\0') {\n        srand(h + *str++);\n        h = rand();\n    }\n    return h % mod;\n}\n\nint main() {\n    char *names[] = {\n        \"Bea\", \"Tim\", \"Len\", \"Sam\", \"Ada\", \"Mia\",\n        \"Sue\", \"Zoe\", \"Rae\", \"Lou\", \"Max\", \"Tod\"\n    };\n    for (int i = 0; i &lt; sizeof(names) / sizeof(*names); i++)\n        printf(\"%s : %d\\n\", names[i], hash(names[i], 10));\n}\n</code></pre> <p>Cette approche nous donne une assez bonne r\u00e9partition\u2009:</p> <pre><code>$ ./a.out\nBea : 2\nTim : 3\nLen : 0\nSam : 3\nAda : 4\nMia : 3\nSue : 6\nZoe : 5\nRae : 8\nLou : 0\nMax : 3\nTod : 1\n</code></pre> <p>Dans la pratique, on utilisera volontiers des fonctions de hachage utilis\u00e9es en cryptographies tels que MD5 ou <code>SHA</code>. Consid\u00e9rons par exemple la premi\u00e8re partie du po\u00e8me Chanson de Pierre Corneille\u2009:</p> <pre><code>$ cat chanson.txt\nSi je perds bien des ma\u00eetresses,\nJ'en fais encor plus souvent,\nEt mes voeux et mes promesses\nNe sont que feintes caresses,\nEt mes voeux et mes promesses\nNe sont jamais que du vent.\n\n$ md5sum chanson.txt\n699bfc5c3fd42a06e99797bfa635f410  chanson.txt\n</code></pre> <p>Le hash de ce texte est exprim\u00e9 en hexad\u00e9cimal ( <code>0x699bfc5c3fd42a06e99797bfa635f410</code>). Converti en d\u00e9cimal <code>140378864046454182829995736237591622672</code> il peut \u00eatre r\u00e9duit en utilisant le modulo. Voici un exemple en C\u2009:</p> <pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;openssl/md5.h&gt;\n#include &lt;string.h&gt;\n\nint hash(char* str, int mod) {\n    // Compute MD5\n    unsigned int output[4];\n    MD5_CTX md5;\n    MD5_Init(&amp;md5);\n    MD5_Update(&amp;md5, str, strlen(str));\n    MD5_Final((char*)output, &amp;md5);\n\n    // 128-bits --&gt; 32-bits\n    unsigned int h = 0;\n    for (int i = 0; i &lt; sizeof(output)/sizeof(*output); i++) {\n        h ^= output[i];\n    }\n\n    // 32-bits --&gt; mod\n    return h % mod;\n}\n\nint main() {\n    char *text[] = {\n        \"La poule ou l'oeuf?\",\n        \"Les pommes sont cuites!\",\n        \"Aussi lentement que possible\",\n        \"La poule ou l'oeuf.\",\n        \"La poule ou l'oeuf!\",\n        \"Aussi vite que n\u00e9cessaire\",\n        \"Il ne faut pas l\u00e2cher la proie pour l\u2019ombre.\",\n        \"Le mieux est l'ennemi du bien\",\n    };\n\n    for (int i = 0; i &lt; sizeof(text) / sizeof(*text); i++)\n        printf(\"% 2d. %s\\n\", hash(text[i], 10), text[i]);\n}\n</code></pre> <pre><code>$ gcc hash.c -lcrypto\n$ ./a.out\n1. La poule ou l'oeuf?\n2. Les pommes sont cuites!\n3. Aussi lentement que possible\n4. La poule ou l'oeuf.\n5. La poule ou l'oeuf!\n6. Aussi vite que n\u00e9cessaire\n8. Il ne faut pas l\u00e2cher la proie pour l\u2019ombre.\n9. Le mieux est l'ennemi du bien\n</code></pre> <p>On peut constater qu'ici les indices sont bien r\u00e9partis et que la fonction de hachage choisie semble uniforme.</p>"}, {"location": "course-c/25-data-structures/containers/maps/#fonction-de-hachage-affine", "title": "Fonction de hachage affine", "text": "<p>Une autre m\u00e9thode pour calculer le hash consiste \u00e0 multiplier la valeur de chaque caract\u00e8re par une constante et de sommer le tout. Par exemple, la fonction de hachage suivante\u2009:</p> <pre><code>int hash(char *str, int mod) {\n    const int a = 31;\n    int h = 0;\n    while(*str != '\\0')\n        h = (h * a + *str++) % mod;\n    return h;\n}\n</code></pre> <p>La constante <code>a</code> est souvent choisie comme un nombre premier pour \u00e9viter les collisions.</p> <p>On peut \u00e9galement impl\u00e9menter cette fonction pour hacher des entiers\u2009:</p> <pre><code>int hash_int(int n, int mod) {\n    const int a = 31;\n    return (a * n) % mod;\n}\n</code></pre>"}, {"location": "course-c/25-data-structures/containers/maps/#murmurhash", "title": "MurmurHash", "text": "<p>Une autre fonction de hachage tr\u00e8s populaire est MurmurHash. Elle est tr\u00e8s rapide et produit des r\u00e9sultats de qualit\u00e9. Voici un exemple en C\u2009:</p> <pre><code>uint32_t murmur3_32(const char *key, uint32_t len, uint32_t seed) {\n    uint32_t h = seed;\n    if (len &gt; 3) {\n        const uint32_t *key_x4 = (const uint32_t *)key;\n        size_t i = len &gt;&gt; 2;\n        do {\n            uint32_t k = *key_x4++;\n            k *= 0xcc9e2d51;\n            k = (k &lt;&lt; 15) | (k &gt;&gt; 17);\n            k *= 0x1b873593;\n            h ^= k;\n            h = (h &lt;&lt; 13) | (h &gt;&gt; 19);\n            h = h * 5 + 0xe6546b64;\n        } while (--i);\n        key = (const char *)key_x4;\n    }\n    if (len &amp; 3) {\n        size_t i = len &amp; 3;\n        uint32_t k = 0;\n        key = &amp;key[i - 1];\n        do {\n            k &lt;&lt;= 8;\n            k |= *key--;\n        } while (--i);\n        k *= 0xcc9e2d51;\n        k = (k &lt;&lt; 15) | (k &gt;&gt; 17);\n        k *= 0x1b873593;\n        h ^= k;\n    }\n    h ^= len;\n    h ^= h &gt;&gt; 16;\n    h *= 0x85ebca6b;\n    h ^= h &gt;&gt; 13;\n    h *= 0xc2b2ae35;\n    h ^= h &gt;&gt; 16;\n    return h;\n}\n</code></pre> <p>Les valeurs de <code>seed</code> et <code>len</code> sont des valeurs arbitraires. La valeur de <code>seed</code> est souvent choisie al\u00e9atoirement. La valeur de <code>len</code> est la longueur de la cha\u00eene de caract\u00e8res \u00e0 hacher.</p> <p>On observe \u00e9galements des valeurs arbitraires pour les constantes <code>0xcc9e2d51</code>, <code>0x1b873593</code>, <code>0xe6546b64</code>, <code>0x85ebca6b</code>... Ces valeurs ont \u00e9t\u00e9 choisies pour leur qualit\u00e9 de m\u00e9lange des bits. Elles sont souvent d\u00e9termin\u00e9es empiriquement.</p>"}, {"location": "course-c/25-data-structures/containers/maps/#comparaison", "title": "Comparaison", "text": "<p>Voici une compaison de diff\u00e9rentes fonctions de hachage\u2009:</p>  Comparaison des fonctions de hachage Fonction de hachage Qualit\u00e9 Vitesse Taille MD5 Bonne (cryptographie) Lente 128 bits SHA-1 Tr\u00e8s bonne (cryptographie) Lente 160 bits SHA-256 Excellente (cryptographie) Tr\u00e8s lente 256 bits MurmurHash3 Bonne (non cryptographique) Tr\u00e8s rapide 32/128 bits CityHash Tr\u00e8s bonne (non cryptographique) Tr\u00e8s rapide 64/128 bits FNV-1a Bonne (non cryptographique) Rapide 32/64 bits DJB2 Acceptable (non cryptographique) Tr\u00e8s rapide 32 bits CRC32 Bonne pour la d\u00e9tection d'erreurs Tr\u00e8s rapide 32 bits"}, {"location": "course-c/25-data-structures/containers/maps/#perte-de-lordre", "title": "Perte de l'ordre", "text": "<p>Il est important de noter que les tableaux de hachage ne conservent pas l'ordre des \u00e9l\u00e9ments. Comme ils peuvent \u00eatre ins\u00e9r\u00e9s dans n'importe quelle position du tableau, il n'est pas possible de les parcourir dans l'ordre d'insertion.</p> <p>Pire, selon l'algorithme utlis\u00e9, il est possible que si la fonction de hachage ou la taille de la table est modifi\u00e9e en cours de route, les \u00e9l\u00e9ments soient d\u00e9plac\u00e9s dans le tableau, et donc que l'ordre de parcours change.</p> <p>Python</p> <p>En Python les tables de hachages sont des structures de base du langage appel\u00e9es <code>dict</code>. Avant la version 3.7, l'ordre des \u00e9l\u00e9ments n'\u00e9tait pas conserv\u00e9. Depuis la version 3.7, l'ordre d'insertion est conserv\u00e9. Cela est d\u00fb \u00e0 l'impl\u00e9mentation de la table de hachage qui utilise une seconde structure de donn\u00e9e de type liste cha\u00een\u00e9e pour conserver l'ordre d'insertion. Cela a un impact sur la quantit\u00e9 de m\u00e9moire utilis\u00e9e et la performance de la table de hachage car \u00e0 chaque insertion il faut \u00e9galement mettre \u00e0 jour la liste cha\u00een\u00e9e.</p>"}, {"location": "course-c/25-data-structures/containers/maps/#complexite-et-implementation", "title": "Complexit\u00e9 et impl\u00e9mentation", "text": "<p>La caract\u00e9ristique principale recherch\u00e9e dans une table de hachage est de permettre un acc\u00e8s en temps constant \\(O(1)\\) pour les op\u00e9rations de recherche.</p> <p>La complexit\u00e9 de la recherche est en moyenne est donc de \\(O(1)\\), mais peut atteindre \\(O(n)\\) dans le pire des cas, par exemple si le facteur de charge est \u00e9lev\u00e9 et que la table de hachage est mal r\u00e9partie. Il y a donc un compromis \u00e0 trouver entre la m\u00e9moire utilis\u00e9e et la performance de la table de hachage.</p>"}, {"location": "course-c/25-data-structures/containers/trees/", "title": "Arbres", "text": "<p> Arbre binaire IRL</p> <p>Les arbres sont des structures de donn\u00e9es non lin\u00e9aires qui sont compos\u00e9es de n\u0153uds. Chaque n\u0153ud a un ou plusieurs enfants, sauf pour le n\u0153ud racine qui n'a pas de parent. Les arbres sont souvent utilis\u00e9s pour repr\u00e9senter des hi\u00e9rarchies, comme les syst\u00e8mes de fichiers, les arbres g\u00e9n\u00e9alogiques, les arbres de d\u00e9cision, etc.</p> <p>Voici un exemple d'arbre, il repr\u00e9sente par exemple une structure de documents stock\u00e9s sur un ordinateur. En haut on voit le disque C\u2009: qui contient des dossiers et des fichiers. Chaque dossier peut contenir d'autres dossiers ou des fichiers. Il y a donc une hi\u00e9rarchie entre les \u00e9l\u00e9ments. Chaque dossier peut contenir plusieurs \u00e9l\u00e9ments, mais chaque \u00e9l\u00e9ment ne peut \u00eatre contenu que dans un seul dossier.</p> <p>On appelle ce type d'arbre un arbre n-aire dirig\u00e9. C'est-\u00e0-dire que chaque n\u0153ud peut avoir plusieurs enfants. L'arbre est dirig\u00e9 car il y a un sens de la racine vers les feuilles. Il y a donc des fl\u00e8ches qui indiquent le sens de la hi\u00e9rarchie.</p> <pre><code>%% Arbre n-aire dirig\u00e9\ngraph LR\n    C(C:)\n\n    C --&gt; Program_Files(Program Files)\n    C --&gt; Users(Utilisateurs)\n\n    Program_Files --&gt; Microsoft(Microsoft)\n    Program_Files --&gt; Adobe(Adobe)\n    Program_Files --&gt; Google(Google)\n\n    Microsoft --&gt; Office(Office)\n    Microsoft --&gt; Edge(Edge)\n    Microsoft --&gt; Teams(Teams)\n\n    Google --&gt; Chrome(Chrome)\n    Google --&gt; Drive(Drive)\n\n    Users --&gt; Bob(Bob)\n    Users --&gt; Alice(Alice)\n\n    Bob --&gt; Documents(Documents)\n    Bob --&gt; Downloads(Downloads)\n    Bob --&gt; Music(Music)\n\n    Alice --&gt; Documents_Alice(Documents)\n    Alice --&gt; Downloads_Alice(Downloads)\n\n    Documents --&gt; Resume(Resume.docx)\n    Documents --&gt; Project(Project.docx)\n\n    Downloads --&gt; Installer(Installer.exe)\n    Downloads --&gt; Music_Bob(Music.mp3)\n\n    Music --&gt; Album1(Album1)\n    Music --&gt; Album2(Album2)\n\n    Album1 --&gt; Song1(pink-floyd.mp3)\n    Album1 --&gt; Song2(doroth\u00e9e.mp3)\n\n    Documents_Alice --&gt; Thesis(Thesis.docx)\n    Documents_Alice --&gt; Notes(Notes.txt)\n\n    Downloads_Alice --&gt; App(App.exe)</code></pre>", "tags": ["arbres", "hierarchie"]}, {"location": "course-c/25-data-structures/containers/trees/#arbre-binaire", "title": "Arbre binaire", "text": "<p>Un arbre binaire est un arbre o\u00f9 chaque n\u0153ud a au plus deux enfants. Les enfants sont g\u00e9n\u00e9ralement appel\u00e9s le fils gauche et le fils droit. Les arbres binaires sont souvent utilis\u00e9s pour impl\u00e9menter des structures de donn\u00e9es comme les arbres de recherche binaires, les tas binaires, les arbres d'expression, etc.</p> <p>C'est une structure de donn\u00e9e tr\u00e8s utilis\u00e9e en informatique. En pratique, il est rare d'impl\u00e9menter un arbre binaire de mani\u00e8re explicite. On utilise plut\u00f4t des structures de donn\u00e9es qui sont bas\u00e9es sur des arbres binaires.</p> <p>Le C \u00e9tant un langage tr\u00e8s bas niveau, il n'y a pas de structure de donn\u00e9es arbre binaire dans la biblioth\u00e8que standard. En C++ en revanche il y a de nombreux conteneurs qui utilisent des arbres binaires comme <code>std::set</code>, <code>std::map</code>, <code>std::multiset</code>, <code>std::multimap</code>, <code>std::priority_queue</code>, etc.</p> <p>Voici l'exemple d'un arbre binaire. Chaque n\u0153ud est compos\u00e9 de deux enfants sauf pour les feuilles qui n'ont pas d'enfants. Le n\u0153ud <code>40</code> n'a lui que 1 enfant\u2009: l'enfant de droite.</p> <pre><code>%% Arbre binaire\ngraph TD\n    classDef ghost display: none;\n\n    50((50))\n\n    50 --&gt; 30((30))\n    50 --&gt; 70((70))\n\n    30 --&gt; 20((20))\n    30 --&gt; 40((40))\n\n    70 --&gt; 60((60))\n    70 --&gt; 80((80))\n\n    20 --&gt; 10((10))\n    20 --&gt; 25((25))\n\n    40 --&gt; ghost1(( ))\n    40 --&gt; 35((35))\n\n    60 --&gt; 55((55))\n    60 --&gt; 65((65))\n\n    80 --&gt; 75((75))\n    80 --&gt; 90((90))\n\n    class ghost1 ghost;\n    linkStyle 8 display: none;</code></pre> <p>Un arbre peut \u00eatre \u00e9quilibr\u00e9 ou d\u00e9s\u00e9quilibr\u00e9. Un arbre est \u00e9quilibr\u00e9 si la hauteur de ses sous-arbres gauche et droit diff\u00e8re d'au plus un. Un arbre \u00e9quilibr\u00e9 est souvent plus efficace pour les op\u00e9rations de recherche, d'insertion et de suppression.</p> <p>Voici l'exemple d'un arbre d\u00e9s\u00e9quilibr\u00e9\u2009:</p> <pre><code>%% Arbre binaire d\u00e9s\u00e9quilibr\u00e9\ngraph LR\n    classDef ghost display: none;\n\n    50((42))\n\n    50 --&gt; 30((30))\n    50 --&gt; 70((70))\n\n    30 --&gt; 20((20))\n    30 --&gt; 40((40))\n\n    70 --&gt; 60((60))\n    70 --&gt; 80((80))\n\n    20 --&gt; 10((10))\n\n\n\n    60 --&gt; 55((55))\n\n    10 --&gt; 12((12))\n    10 --&gt; 23((23))\n    23 --&gt; 35((35))</code></pre>", "tags": ["arbre-binaire"]}, {"location": "course-c/25-data-structures/containers/trees/#heap", "title": "Heap", "text": "<p>La structure de donn\u00e9e <code>heap</code> aussi nomm\u00e9e tas ne doit pas \u00eatre confondue avec le tas utilis\u00e9 en allocation dynamique. Il s'agit d'une forme particuli\u00e8re de l'arbre binaire dit \u00ab\u2009presque complet\u2009\u00bb, dans lequel la diff\u00e9rence de niveau entre les feuilles n'exc\u00e8de pas 1. C'est-\u00e0-dire que toutes les feuilles sont \u00e0 une distance identique de la racine plus ou moins 1.</p> <p>Un tas peut ais\u00e9ment \u00eatre repr\u00e9sent\u00e9 sous forme de tableau en utilisant la r\u00e8gle suivante\u2009:</p>  Op\u00e9ration d'acc\u00e8s \u00e0 un \u00e9l\u00e9ment d'un hea Cible D\u00e9but \u00e0 0 D\u00e9but \u00e0 1 Enfant de gauche \\(2*k  + 1\\) \\(2 * k\\) Enfant de droite \\(2*k  + 2\\) \\(2 * k + 1\\) Parent \\(floor(k-1) / 2\\) \\(floor(k) / 2\\) <p> Repr\u00e9sentation d'un *heap*</p>"}, {"location": "course-c/25-data-structures/containers/trees/#min-heap", "title": "Min-heap", "text": "<p>Un tas binaire est une structure de donn\u00e9es qui permet de stocker des \u00e9l\u00e9ments de mani\u00e8re ordonn\u00e9e. Un tas binaire est un arbre binaire complet o\u00f9 chaque n\u0153ud est plus petit que ses enfants. Un tas binaire est souvent utilis\u00e9 pour impl\u00e9menter une file de priorit\u00e9.</p> <p>Impl\u00e9mentation en C</p> min-heap.h<pre><code>#pragma once\n\n#include &lt;stddef.h&gt;\n#include &lt;stdio.h&gt;\n\ntypedef struct MinHeap MinHeap;\n\nMinHeap *min_heap_create(size_t element_size,\n    int (*compare)(const void *, const void *),\n    void (*free_function)(void *));\nvoid min_heap_destroy(MinHeap *heap);\nint min_heap_insert(MinHeap *heap, void *element);\nvoid *min_heap_extract_min(MinHeap *heap);\nsize_t min_heap_size(MinHeap *heap);\n\nvoid min_heap_to_mermaid(MinHeap *heap, FILE *output, void (print_element)(void *element, FILE *output));\n</code></pre> min-heap.c<pre><code>#include \"min-heap.h\"\n#include \"vector.h\"\n\n#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\nstruct MinHeap {\n    Vector *vector;\n    int (*compare)(const void *, const void *);\n};\n\nstatic void swap(void **a, void **b) {\n    void *temp = *a;\n    *a = *b;\n}\n\nstatic void heapify_up(MinHeap *heap, size_t index) {\n    if (index == 0) return;\n\n    size_t parent_index = (index - 1) / 2;\n    if (heap-&gt;compare(vector_get(heap-&gt;vector, index), vector_get(heap-&gt;vector, parent_index)) &lt; 0) {\n        swap(&amp;heap-&gt;vector-&gt;data[index], &amp;heap-&gt;vector-&gt;data[parent_index]);\n        heapify_up(heap, parent_index);\n    }\n}\n\nstatic void heapify_down(MinHeap *heap, size_t index) {\n    size_t left_child = 2 * index + 1;\n    size_t right_child = 2 * index + 2;\n    size_t smallest = index;\n\n    if (left_child &lt; vector_size(heap-&gt;vector) &amp;&amp;\n        heap-&gt;compare(vector_get(heap-&gt;vector, left_child), vector_get(heap-&gt;vector, smallest)) &lt; 0) {\n        smallest = left_child;\n    }\n    if (right_child &lt; vector_size(heap-&gt;vector) &amp;&amp;\n        heap-&gt;compare(vector_get(heap-&gt;vector, right_child), vector_get(heap-&gt;vector, smallest)) &lt; 0) {\n        smallest = right_child;\n    }\n    if (smallest != index) {\n        swap(&amp;heap-&gt;vector-&gt;data[index], &amp;heap-&gt;vector-&gt;data[smallest]);\n        heapify_down(heap, smallest);\n    }\n}\n\nMinHeap *min_heap_create(size_t element_size, int (*compare)(const void *, const void *), void (*free_function)(void *)) {\n    MinHeap *heap = (MinHeap *)malloc(sizeof(MinHeap));\n    if (!heap) return NULL;\n\n    heap-&gt;vector = vector_create(element_size, free_function);\n    if (!heap-&gt;vector) {\n        free(heap);\n        return NULL;\n    }\n\n    heap-&gt;compare = compare;\n    return heap;\n}\n\nvoid min_heap_destroy(MinHeap *heap) {\n    if (heap) {\n        vector_destroy(heap-&gt;vector);\n        free(heap);\n    }\n}\n\nint min_heap_insert(MinHeap *heap, void *element) {\n    if (vector_push_back(heap-&gt;vector, element) != 0) return -1;\n    heapify_up(heap, vector_size(heap-&gt;vector) - 1);\n    return 0;\n}\n\nvoid *min_heap_extract_min(MinHeap *heap) {\n    if (vector_size(heap-&gt;vector) == 0) return NULL;\n\n    void *min_element = vector_get(heap-&gt;vector, 0);\n    void *last_element = vector_get(heap-&gt;vector, vector_size(heap-&gt;vector) - 1);\n    vector_set(heap-&gt;vector, 0, last_element);\n    heap-&gt;vector-&gt;size--; // Adjust size without deallocating the last element\n\n    heapify_down(heap, 0);\n    return min_element;\n}\n\nsize_t min_heap_size(MinHeap *heap) {\n    return vector_size(heap-&gt;vector);\n}\n\nvoid min_heap_to_mermaid(MinHeap *heap, FILE *output, void (print_element)(void *element, FILE *output)) {\n    fprintf(output, \"graph TD\\n\");\n    for (size_t i = 0; i &lt; vector_size(heap-&gt;vector); i++) {\n        fprintf(output, \"  %zu((\\\"\", i);\n        if (print_element) {\n            print_element(vector_get(heap-&gt;vector, i), output);\n        } else {\n            fprintf(output, \"%d\", *(int *)vector_get(heap-&gt;vector, i));\n        }\n        fprintf(output, \"\\\"))\\n\");\n    }\n    for (size_t i = 0; i &lt; vector_size(heap-&gt;vector); i++) {\n        if (i &gt; 0) {\n            size_t parent = (i - 1) / 2;\n            fprintf(output, \"  %zu --&gt; %zu\\n\", parent, i);\n        }\n    }\n}\n</code></pre> <p>Le tas binaire utilise un tableau dynamique pour stocker les \u00e9l\u00e9ments. La r\u00e8gle est que chaque \u00e9l\u00e9ment voit son enfant de gauche \u00e0 l'indice <code>2 * k + 1</code> et l'enfant de droite \u00e0 l'indice <code>2 * k + 2</code>. Le parent d'un \u00e9l\u00e9ment est \u00e0 l'indice <code>(k - 1) / 2</code> quelque soit l'indice <code>k</code>.</p> <p>La propri\u00e9t\u00e9 principale du tas binaire est que chaque element de l'arbre est plus petit que ses enfants. Cela signifie que la racine de l'arbre est le plus petit \u00e9l\u00e9ment. Lorsqu'on retire un \u00e9l\u00e9ment du tas, on retire la racine et on la remplace par le dernier \u00e9l\u00e9ment du tableau il faut ensuite manipuler le tas pour que la propri\u00e9t\u00e9 soit respect\u00e9e. On appelle cette op\u00e9ration heapify.</p> <p>L'algorithme heapify est un algorithme r\u00e9cursif qui permet de r\u00e9tablir la propri\u00e9t\u00e9 du tas binaire. On part du dernier \u00e9l\u00e9ment de l'arbre qui poss\u00e8de au moins un enfant. On compare la valeur de l'\u00e9l\u00e9ment avec celle de son ou de ses enfants. Si la valeur de l'\u00e9l\u00e9ment est plus grande que celle de ses enfants, on \u00e9change les valeurs. On continue r\u00e9cursivement avec les enfants jusqu'\u00e0 ce que la propri\u00e9t\u00e9 soit respect\u00e9e.</p> <p>Si on insert un \u00e9l\u00e9ment dans le tableau dynamique, on l'ajoute \u00e0 la fin du tableau. Puis on doit r\u00e9tablir la propri\u00e9t\u00e9 du tas binaire. On compare la valeur de l'\u00e9l\u00e9ment avec celle de son parent. Si la valeur de l'\u00e9l\u00e9ment est plus petite que celle de son parent, on \u00e9change les valeurs. On continue r\u00e9cursivement avec le parent jusqu'\u00e0 ce que la propri\u00e9t\u00e9 soit respect\u00e9e, en remontant la branche.</p> <p>Prenons l'exemple initial de cet arbre stock\u00e9 en tableau\u2009:</p> <pre><code>int a[] = {1, 3, 6, 5, 9, 8};\n</code></pre> <pre><code>graph TD\n    1((1)) --&gt; 3((3))\n    1((1)) --&gt; 6((6))\n    3((3)) --&gt; 5((5))\n    3((3)) --&gt; 9((9))\n    6((6)) --&gt; 8((8))</code></pre> <p>On souhaite rajouter l'\u00e9l\u00e9ment <code>2</code>. On commence par l'ajouter \u00e0 la fin\u2009:</p> <pre><code>graph TD\n    1((1)) --&gt; 3((3))\n    1((1)) --&gt; 6((6))\n    3((3)) --&gt; 5((5))\n    3((3)) --&gt; 9((9))\n    6((6)) --&gt; 8((8))\n    6((6)) --&gt; 2((2))</code></pre> <p>On compare la valeur de <code>2</code> avec celle de son parent <code>6</code>. Comme <code>2</code> est plus petit que <code>6</code>, on \u00e9change les valeurs\u2009:</p> <pre><code>graph TD\n    1((1)) --&gt; 3((3))\n    1((1)) --&gt; 2((2))\n    3((3)) --&gt; 5((5))\n    3((3)) --&gt; 9((9))\n    2((2)) --&gt; 8((8))\n    2((2)) --&gt; 6((6))</code></pre> <p>On continue avec le parent de <code>2</code>, <code>1</code>. Comme <code>2</code> est plus grand que <code>1</code>, on s'arr\u00eate l\u00e0. Le tas binaire est maintenant r\u00e9tabli.</p> <p>Les utilisations les plus courantes de cette structure de donn\u00e9e sont\u2009:</p> <ul> <li>Tri par tas (Heap sort)</li> <li>Une queue prioritaire (Priority queue)</li> <li>D\u00e9terminer le k-i\u00e8me \u00e9l\u00e9ment le plus petit d'une collection (k-th smallest element)</li> </ul> <p>Voici un tableau r\u00e9sumant les complexit\u00e9s des diff\u00e9rentes op\u00e9rations dans un tas binaire minimal\u00a0:</p> Op\u00e9ration Complexit\u00e9 Insertion \\(O(log n)\\) Extraction du minimum \\(O(log n)\\) Acc\u00e8s au minimum \\(O(1)\\) Construction \\(O(n)\\) ou \\(O(n log n)\\) Suppression \\(O(log n)\\) Mise \u00e0 jour d'un \u00e9l\u00e9ment \\(O(log n)\\) <ul> <li> <p>Insertion : Lorsqu'un \u00e9l\u00e9ment est ajout\u00e9 au min-heap, il est ajout\u00e9 \u00e0 la fin et le processus de heapify up (ou bubble up) est effectu\u00e9 pour r\u00e9tablir la propri\u00e9t\u00e9 du tas. Ce processus implique de comparer et potentiellement d'\u00e9changer des \u00e9l\u00e9ments \u00e0 chaque niveau de l'arbre, ce qui prend \\(O(log n)\\) dans le pire des cas.</p> </li> <li> <p>Extraction du minimum : L'extraction de l'\u00e9l\u00e9ment minimum implique de retirer la racine du tas (le plus petit \u00e9l\u00e9ment), de placer le dernier \u00e9l\u00e9ment de l'arbre \u00e0 la racine, puis d'effectuer heapify down (ou sift down) pour r\u00e9tablir la propri\u00e9t\u00e9 du tas. Cela prend \\(O(log~n)\\) car il peut n\u00e9cessiter de descendre jusqu'au niveau le plus bas de l'arbre.</p> </li> <li> <p>Acc\u00e8s au minimum : L'acc\u00e8s au minimum est \\(O(1)\\) car l'\u00e9l\u00e9ment minimum est toujours \u00e0 la racine du tas.</p> </li> <li> <p>Construction : La complexit\u00e9 de la construction d'un tas \u00e0 partir d'une liste non tri\u00e9e peut \u00eatre \\(O(n)\\) en utilisant une technique appel\u00e9e heapify (ou build-heap). Cependant, si vous ins\u00e9rez chaque \u00e9l\u00e9ment un par un en utilisant la m\u00e9thode d'insertion standard, la complexit\u00e9 serait \\(O(n~log~n)\\).</p> </li> <li> <p>Suppression : La suppression d'un \u00e9l\u00e9ment (autre que la racine) implique de le remplacer par le dernier \u00e9l\u00e9ment du tas et d'effectuer heapify up ou heapify down selon le cas, ce qui prend O(log~n).</p> </li> <li> <p>Mise \u00e0 jour d'un \u00e9l\u00e9ment : La mise \u00e0 jour d'un \u00e9l\u00e9ment peut n\u00e9cessiter soit heapify up soit heapify down pour r\u00e9tablir la propri\u00e9t\u00e9 du tas, ce qui prend \\(O(log n)\\).</p> </li> </ul> <p>Ces complexit\u00e9s font des min-heaps une structure de donn\u00e9es efficace pour les files de priorit\u00e9 et les algorithmes n\u00e9cessitant des op\u00e9rations fr\u00e9quentes d'insertion et d'extraction du minimum.</p>", "tags": ["tas-binaire"]}, {"location": "course-c/25-data-structures/containers/trees/#arbre-binaire-de-recherche", "title": "Arbre binaire de recherche", "text": "<p>Un arbres binaires de recherche (Binary Search Tree, BST) est un arbre binaire dans lequel chaque n\u0153ud a une valeur et les valeurs des n\u0153uds de l'arbre sont ordonn\u00e9es. Pour chaque n\u0153ud, toutes les valeurs des n\u0153uds du sous-arbre gauche sont inf\u00e9rieures \u00e0 la valeur du n\u0153ud et toutes les valeurs des n\u0153uds du sous-arbre droit sont sup\u00e9rieures \u00e0 la valeur du n\u0153ud.</p> <p>L'impl\u00e9mentation d'un arbre binaire est souvent impl\u00e9ment\u00e9e avec une liste cha\u00een\u00e9e comportant deux enfants un <code>left</code> et un <code>right</code> :</p> <p> Arbre binaire \u00e9quilibr\u00e9</p> <p>Lorsqu'il est \u00e9quilibr\u00e9, un arbre binaire comporte autant d'\u00e9l\u00e9ments \u00e0 gauche qu'\u00e0 droite et lorsqu'il est correctement rempli, la valeur d'un \u00e9l\u00e9ment est toujours\u2009:</p> <ul> <li>La valeur de l'enfant de gauche est inf\u00e9rieure \u00e0 celle de son parent</li> <li>La valeur de l'enfant de droite est sup\u00e9rieure \u00e0 celle de son parent</li> </ul> <p>Cette propri\u00e9t\u00e9 est tr\u00e8s appr\u00e9ci\u00e9e pour rechercher et ins\u00e9rer des donn\u00e9es complexes. Admettons que l'on a un registre patient du type\u2009:</p> <pre><code>struct patient {\n    size_t id;\n    char firstname[64];\n    char lastname[64];\n    uint8_t age;\n}\n\ntypedef struct node {\n    struct patient data;\n    struct node* left;\n    struct node* right;\n} Node;\n</code></pre> <p>Si l'on cherche le patient num\u00e9ro <code>612</code>, il suffit de parcourir l'arbre de fa\u00e7on dichotomique\u2009:</p> <pre><code>Node* search(Node* node, size_t id)\n{\n    if (node == NULL)\n        return NULL;\n\n    if (node-&gt;data.id == id)\n        return node;\n\n    return search(node-&gt;data.id &gt; id ? node-&gt;left : node-&gt;right, id);\n}\n</code></pre> <p>L'insertion et la suppression d'\u00e9l\u00e9ments dans un arbre binaire font appel \u00e0 des rotations, puisque les \u00e9l\u00e9ments doivent \u00eatre ins\u00e9r\u00e9s dans le correct ordre et que l'arbre, pour \u00eatre performant, doit toujours \u00eatre \u00e9quilibr\u00e9. Ces rotations sont donc des m\u00e9canismes de r\u00e9\u00e9quilibrage de l'arbre ne sont pas triviaux, mais dont la complexit\u00e9 d'ex\u00e9cution reste simple, et donc performante.</p>"}, {"location": "course-c/25-data-structures/containers/trees/#queue-prioritaire", "title": "Queue prioritaire", "text": "<p>Une queue prioritaire ou priority queue, est une queue dans laquelle les \u00e9l\u00e9ments sont trait\u00e9s par ordre de priorit\u00e9. Imaginons des personnalit\u00e9s, toutes atteintes d'une rage de dents et qui font la queue chez un dentiste aux m\u0153urs discutables. Ce dernier ne prendra pas ses patients par ordre d'arriv\u00e9e, mais, par importance aristocratique.</p> <pre><code>typedef struct Person {\n   char *name;\n   enum SocialStatus {\n       PEON;\n       WORKER;\n       ENGINEER;\n       DOCTOR;\n       PROFESSOR;\n       PRESIDENT;\n       SUPERHERO;\n   } status;\n} Person;\n\nint main() {\n    ProrityQueue queue;\n    queue_init(queue);\n\n    for(int i = 0; i &lt; 100; i++) {\n       queue_enqueue(queue, (Person) {\n          .name = random_name(),\n          .status = random_status()\n       });\n\n       Person person;\n       queue_dequeue(queue, &amp;person);\n       dentist_heal(person);\n    }\n}\n</code></pre> <p>La queue prioritaire dispose donc aussi des m\u00e9thodes <code>enqueue</code> et <code>dequeue</code> mais le <code>dequeue</code> retournera l'\u00e9l\u00e9ment le plus prioritaire de la liste. Ceci se traduit par trier la file d'attente \u00e0 chaque op\u00e9ration <code>enqueue</code> ou <code>dequeue</code>. L'une de ces deux op\u00e9rations pourrait donc avoir une complexit\u00e9 de \\(O(n log n)\\). Heureusement, il existe des m\u00e9thodes de tris performantes si un tableau est d\u00e9j\u00e0 tri\u00e9 et qu'un seul nouvel \u00e9l\u00e9ment y est ajout\u00e9.</p> <p>L'impl\u00e9mentation de ce type de structure de donn\u00e9e s'appuie le plus souvent sur un heap, soit construite \u00e0 partir d'un tableau statique, soit un tableau dynamique.</p>"}, {"location": "course-c/25-data-structures/containers/trees/#arbre-avl", "title": "Arbre AVL", "text": "<p>Un arbre AVL est un arbre binaire de recherche \u00e9quilibr\u00e9. Il est \u00e9quilibr\u00e9 car la hauteur de ses sous-arbres gauche et droit diff\u00e8re d'au plus un. Cela signifie que la hauteur de l'arbre est en \\(O(log n)\\), ce qui rend les op\u00e9rations de recherche, d'insertion et de suppression en \\(O(log n)\\).</p> <p> AVL Tree</p> <p>AVL tire son nom de ses inventeurs Adelson-Velsky and Landis. C'est une structure de donn\u00e9es tr\u00e8s utilis\u00e9e en informatique pour impl\u00e9menter des dictionnaires, des bases de donn\u00e9es, des compilateurs, etc.</p> <p>Son impl\u00e9mentation compl\u00e8te sort du cadre de ce cours mais il est int\u00e9ressant de comprendre comment il fonctionne. L'arbre AVL est un arbre binaire de recherche o\u00f9 chaque n\u0153ud a un facteur d'\u00e9quilibre qui est la diff\u00e9rence entre la hauteur de son sous-arbre gauche et la hauteur de son sous-arbre droit. Si le facteur d'\u00e9quilibre d'un n\u0153ud est sup\u00e9rieur \u00e0 \\(1\\) ou inf\u00e9rieur \u00e0 \\(-1\\), l'arbre est d\u00e9s\u00e9quilibr\u00e9 et il faut le r\u00e9\u00e9quilibrer. Cela donne un crit\u00e8re de r\u00e9\u00e9quilibrage en fonction du facteur d'\u00e9quilibre.</p> <p>L'op\u00e9ration d'insertion dans un arbre AVL est similaire \u00e0 celle d'un arbre binaire de recherche. On ins\u00e8re le n\u0153ud \u00e0 la bonne place dans l'arbre. Puis on met \u00e0 jour le facteur d'\u00e9quilibre de chaque n\u0153ud sur le chemin de la racine. Si le facteur d'\u00e9quilibre d'un n\u0153ud est sup\u00e9rieur \u00e0 \\(1\\) ou inf\u00e9rieur \u00e0 \\(-1\\), on r\u00e9\u00e9quilibre l'arbre en effectuant des rotations.</p> <p>C'est cette op\u00e9ration de rotation qui est la plus complexe dans un arbre AVL. Il existe plusieurs types de rotations en fonction du facteur d'\u00e9quilibre du n\u0153ud. Il y a les rotations simples et les rotations doubles. Les rotations simples sont les rotations droite et gauche. Les rotations doubles sont les rotations gauche-droite et droite-gauche.</p>"}, {"location": "course-c/25-data-structures/containers/trees/#arbre-rouge-noir", "title": "Arbre rouge-noir", "text": "<p>Un arbre rouge-noir est un arbre binaire de recherche \u00e9quilibr\u00e9. Il est \u00e9quilibr\u00e9 car la hauteur de ses sous-arbres gauche et droit diff\u00e8re d'au plus deux. Cela signifie que la hauteur de l'arbre est en \\(O(log n)\\), ce qui rend les op\u00e9rations de recherche, d'insertion et de suppression en \\(O(log n)\\).</p> <p> Arbre rouge et noir</p> <p>Contrairement \u00e0 l'arbre AVL, l'arbre rouge-noir est plus simple \u00e0 impl\u00e9menter. Il utilise un bit de couleur pour chaque n\u0153ud pour indiquer si le n\u0153ud est rouge ou noir. L'arbre rouge-noir a cinq propri\u00e9t\u00e9s\u2009:</p> <ol> <li>Chaque n\u0153ud est soit rouge, soit noir.</li> <li>La racine est noire.</li> <li>Toutes les feuilles (n\u0153uds NULL) sont noires.</li> <li>Si un n\u0153ud est rouge, alors ses deux enfants sont noirs. (Pas de deux rouges cons\u00e9cutifs sur un chemin vers une feuille)</li> <li>Tout chemin simple d'un n\u0153ud donn\u00e9 \u00e0 ses feuilles descendantes contient le m\u00eame nombre de n\u0153uds noirs.</li> </ol> <p>De la m\u00eame mani\u00e8re que l'arbre AVL, il y a des op\u00e9rations de rotation pour r\u00e9\u00e9quilibrer l'arbre rouge-noir. Les rotations sont plus simples que dans un arbre AVL car il n'y a que deux types de rotations\u2009: la rotation gauche et la rotation droite.</p>"}, {"location": "course-c/25-data-structures/containers/trees/#trie", "title": "Trie", "text": "<p>Un trie est une structure de donn\u00e9es qui stocke un ensemble de cha\u00eenes de caract\u00e8res. Il est souvent utilis\u00e9 pour stocker des mots dans un dictionnaire ou pour rechercher des mots dans un texte. Un trie est donc un arbre o\u00f9 chaque n\u0153ud est associ\u00e9 \u00e0 une lettre et un marqueur de fin de mot. Un noeud peut avoir de 1 \u00e0 26 enfants, un pour chaque lettre de l'alphabet (si on se limite \u00e0 l'alphabet latin minuscule).</p> <p>Prenons l'exemple des mots suivants\u2009:</p> <pre><code>char *words[] = {\n    \"cadeaux\", \"le\", \"car\", \"cette\", \"cadre\", \"cause\",\n    \"carte\", \"comme\", \"car\", \"ce\", \"caduc\", \"cadet\",\n    \"la\", \"la\", \"les\"};\n</code></pre> <p>On peut construire le trie suivant\u2009:</p> <p> Trie</p> <p>En vert, les n\u0153uds qui marquent la fin d'un mot. En orange la racine de l'arbre. La structure de donn\u00e9es de chaque noeud pourrait \u00eatre la suivante\u2009:</p> <pre><code>typedef struct Node {\n    int occurences;  // Number of occurences of the word\n    struct Node *children[26];  // Children nodes\n} Node;\n</code></pre> <p>Exercise\u2009: Impl\u00e9mentation</p> <p>Vous avez un texte connu et vous voulez permettre de compter les occurences de chaque mot. Une fois que le trie est construit, il est en lecture seule. Comment allez-vous impl\u00e9menter le trie\u2009?</p> <ul> <li>     Comme une liste cha\u00een\u00e9e, chaque noeud est allou\u00e9 dynamiquement sur le heap. </li> <li>     Un tableau statique sur la pile ou chaque \u00e9l\u00e9ment est un noeud. </li> <li>     Un tableau dynamique sur le heap, l'allocation est amortie et chaque noeud contient un tableau de pointeurs sur ses enfants. </li> <li>     Un tableau dynamique sur le heap, l'allocation est amortie et chaque noeud contient non pas un pointeur des enfants mais l'indice de l'enfant dans le tableau. </li> <li>     Par chunks d'\u00e9l\u00e9ments, chaque chunk est allou\u00e9 dynamiquement sur le heap. </li> </ul> <p>Discutons de plusieurs impl\u00e9mentations possibles d'un noeud d'un trie\u2009:</p> <ul> <li> <p>Liste cha\u00een\u00e9e : Chaque noeud est allou\u00e9 dynamiquement sur le heap. C'est une solution simple mais qui peut \u00eatre co\u00fbteuse en m\u00e9moire et en temps d'allocation. N\u00e9anmoins le noeud peut prendre un tableau flexible pour les enfants. Ce qui permet de ne pas allouer de m\u00e9moire inutile.</p> <pre><code>typedef struct Node {\n    int occurences;  // Number of occurences of the word\n    struct Node *children[];  // Children nodes, variable size\n} Node;\n</code></pre> </li> <li> <p>Tableau dynamique : En stoquant tous les \u00e9l\u00e9ments dans le tableau dynamique, on ne peut plus utiliser de pointeurs car si le tableau est r\u00e9allou\u00e9, les pointeurs ne sont plus valides. On utilise donc des indices pour acc\u00e9der aux enfants, car ces derniers sont relatifs \u00e0 l'adresse de d\u00e9but du tableau. En revanche, on ne peut plus utiliser de tableau flexible pour les enfants car la taille de la structure doit \u00eatre connue \u00e0 la compilation. Ceci implique une utilisation de m\u00e9moire plus importante.</p> <pre><code>typedef struct Node {\n    int occurences;  // Number of occurences of the word\n    size_t children_id[26];  // Children nodes\n} Node;\n</code></pre> </li> <li> <p>Chunks : Chaque chunk contient un certain nombre de noeuds. Un chaunk d'une taille donn\u00e9e est r\u00e9serv\u00e9e. Lorsque le chunk est plein, un nouveau chunk est allou\u00e9. Cela permet de r\u00e9duire le nombre d'appels \u00e0 <code>malloc</code> et de r\u00e9duire la fragmentation de la m\u00e9moire. Cette m\u00e9thode permet de r\u00e9duire le nombre d'appels \u00e0 <code>malloc</code> et de r\u00e9duire la fragmentation de la m\u00e9moire. Elle r\u00e9soud aussi le probl\u00e8me de la taille fixe du tableau des enfants en autorisant \u00e0 nouveau un tableau flexible.</p> <pre><code>typedef struct Node {\n    int occurences;  // Number of occurences of the word\n    struct Node *children[];  // Children nodes\n} Node;\n\ntypedef struct Chunk {\n    char *data[1024];\n    size_t used_bytes;\n    struct Chunk *next;\n} Chunk;\n</code></pre> </li> </ul> <p>Exemple d'impl\u00e9mentation\u2009:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n\n#define ALPHABET_SIZE 26\n\ntypedef struct Node {\n    int occurrences;\n    struct Node *children[ALPHABET_SIZE];\n} Node;\n\nNode* createNode() {\n    Node *node = (Node *)malloc(sizeof(Node));\n    if (node) {\n        node-&gt;occurrences = 0;\n        for (int i = 0; i &lt; ALPHABET_SIZE; i++) {\n            node-&gt;children[i] = NULL;\n        }\n    }\n    return node;\n}\n\nvoid insert(Node *root, const char *word) {\n    Node *current = root;\n    while (*word) {\n        if (!current-&gt;children[*word - 'a']) {\n            current-&gt;children[*word - 'a'] = createNode();\n        }\n        current = current-&gt;children[*word - 'a'];\n        word++;\n    }\n    current-&gt;occurrences++;\n}\n\nint search(Node *root, const char *word) {\n    Node *current = root;\n    while (*word) {\n        if (!current-&gt;children[*word - 'a']) {\n            return 0;\n        }\n        current = current-&gt;children[*word - 'a'];\n        word++;\n    }\n    return current-&gt;occurrences;\n}\n\nvoid freeTrie(Node *root) {\n    for (int i = 0; i &lt; ALPHABET_SIZE; i++) {\n        if (root-&gt;children[i]) {\n            freeTrie(root-&gt;children[i]);\n        }\n    }\n    free(root);\n}\n\nint main() {\n    Node *root = createNode();\n\n    insert(root, \"frodo\");\n    insert(root, \"sam\");\n    insert(root, \"gandalf\");\n    // Add more words as needed\n\n    printf(\"Occurrences of 'frodo': %d\\n\", search(root, \"frodo\"));\n    printf(\"Occurrences of 'sam': %d\\n\", search(root, \"sam\"));\n    printf(\"Occurrences of 'gandalf': %d\\n\", search(root, \"gandalf\"));\n\n    freeTrie(root);\n}\n</code></pre> <p>Exercise\u2009: Regroupement\u2009?</p> <p>Demandons-nous s'il ne serait pas pr\u00e9f\u00e9rable de regrouper les noeuds communs ensemble comme le montre la figure suivante\u2009:</p> <p> Trie\u2009: arbre avec noeuds communs</p> <p>D'apr\u00e8s vous est-ce une bonne id\u00e9e\u2009? Pourquoi\u2009?</p> Solution <p>Non, ce n'est pas une bonne id\u00e9e. D'une part la figure n'est plus un arbre mais un graphe. Un graph peut avoir des cycles et donc des boucles infinies. Ensuite, regrouper les \u00e9l\u00e9ments communs ne peut \u00eatre fait qu'\u00e0 la fin de la construction du trie, lorsqu'elle est d\u00e9j\u00e0 allou\u00e9e en m\u00e9moire. La complexit\u00e9 de l'optimisation n'est pas \u00e0 n\u00e9gliger. Si la contrainte est l'utilisation de la m\u00e9moire, il est pr\u00e9f\u00e9rable d'utiliser une autre structure de donn\u00e9e comme un radix trie.</p>"}, {"location": "course-c/25-data-structures/containers/trees/#radix-trie", "title": "Radix Trie", "text": "<p>On l'a vu l'impl\u00e9mentation d'un trie est simple mais elle peut conduire \u00e0 une utilisation excessive de la m\u00e9moire. En effet, chaque noeud contient un tableau de 26 \u00e9l\u00e9ments, m\u00eame si un mot ne contient que quelques lettres. Pour r\u00e9duire la consommation de m\u00e9moire, on peut utiliser un radix trie. Cet arbre est \u00e9galement nomm\u00e9 PATRICIA trie pour Practical Algorithm to Retrieve Information Coded in Alphanumeric.</p> <p>Plut\u00f4t que de stocker une seule lettre par noeud, on stocke un pr\u00e9fixe commun \u00e0 plusieurs mots. On peut alors r\u00e9duire le nombre de noeuds et donc la consommation de m\u00e9moire.</p>"}, {"location": "course-c/25-data-structures/containers/trees/#navigation-dans-un-arbre", "title": "Navigation dans un arbre", "text": "<p>La navigation dans un arbre binaire est une op\u00e9ration courante. Il existe plusieurs fa\u00e7ons de parcourir un arbre binaire\u2009:</p> <ul> <li>Parcours en profondeur (DFS pour Depth First Search) On commence par la racine, puis on visite le sous-arbre gauche, puis le sous-arbre droit. On peut faire un parcours en profondeur en pr\u00e9-ordre, en in-ordre ou en post-ordre.</li> <li>Parcours en largeur (BFS pour Breadth First Search) On visite les n\u0153uds de l'arbre de haut en bas et de gauche \u00e0 droite. On utilise une file pour stocker les n\u0153uds \u00e0 visiter.</li> </ul>"}, {"location": "course-c/25-data-structures/containers/trees/#parcours-en-profondeur", "title": "Parcours en profondeur", "text": "<p>Le parcours en profondeur est une m\u00e9thode de parcours d'un arbre binaire qui commence par la racine, puis visite le sous-arbre gauche, puis le sous-arbre droit. Il existe trois fa\u00e7ons de parcourir un arbre en profondeur\u2009:</p> <ul> <li>Pr\u00e9-ordre : On visite d'abord la racine, puis le sous-arbre gauche, puis le sous-arbre droit.</li> <li>In-ordre : On visite d'abord le sous-arbre gauche, puis la racine, puis le sous-arbre droit.</li> <li>Post-ordre : On visite d'abord le sous-arbre gauche, puis le sous-arbre droit, puis la racine.</li> </ul> <p>L'impl\u00e9mentation peut se faire de mani\u00e8re r\u00e9cursive ou it\u00e9rative. Voici un exemple d'impl\u00e9mentation r\u00e9cursive en C\u2009:</p> <pre><code>int dfs(Node* node, (void)(*visit)(Node*))\n{\n    if (node == NULL)\n        return;\n\n    visit(node);\n    dfs(node-&gt;left, visit);\n    dfs(node-&gt;right, visit);\n}\n</code></pre> <p>L'impl\u00e9mentation it\u00e9rative utilise une pile pour stocker les n\u0153uds \u00e0 visiter. Voici un exemple d'impl\u00e9mentation it\u00e9rative en C\u2009:</p> <pre><code>int dfs(Node* node, (void)(*visit)(Node*))\n{\n    Stack stack;\n    stack_init(stack);\n    stack_push(stack, node);\n\n    while (!stack_empty(stack)) {\n        Node* current = stack_pop(stack);\n        visit(current);\n\n        if (current-&gt;right != NULL)\n            stack_push(stack, current-&gt;right);\n\n        if (current-&gt;left != NULL)\n            stack_push(stack, current-&gt;left);\n    }\n}\n</code></pre>"}, {"location": "course-c/30-modular-programming/", "title": "Introduction", "text": "<p>La programmation modulaire est une m\u00e9thode de conception de logiciels qui consiste \u00e0 diviser un programme en modules ind\u00e9pendants. Chaque module est une unit\u00e9 de code qui peut \u00eatre compil\u00e9e s\u00e9par\u00e9ment et r\u00e9utilis\u00e9e dans d'autres programmes. La programmation modulaire permet de simplifier la conception, la maintenance et l'\u00e9volution des logiciels en les divisant en petites parties coh\u00e9rentes et r\u00e9utilisables.</p>"}, {"location": "course-c/30-modular-programming/libraries/", "title": "Biblioth\u00e8ques logicielles", "text": ""}, {"location": "course-c/30-modular-programming/libraries/#statiques", "title": "Statiques", "text": ""}, {"location": "course-c/30-modular-programming/libraries/#dynamiques", "title": "Dynamiques", "text": ""}, {"location": "course-c/30-modular-programming/translation-units/", "title": "Compilation s\u00e9par\u00e9e", "text": ""}, {"location": "course-c/30-modular-programming/translation-units/#unite-de-traduction", "title": "Unit\u00e9 de traduction", "text": "<p>En programmation, on appelle translation unit (unit\u00e9 de traduction), un code qui peut \u00eatre compil\u00e9 en un objet sans autre d\u00e9pendance externe. Le plus souvent, une unit\u00e9 de traduction correspond \u00e0 un fichier C.</p>"}, {"location": "course-c/30-modular-programming/translation-units/#diviser-pour-mieux-regner", "title": "Diviser pour mieux r\u00e9gner", "text": "<p>De m\u00eame qu'un magazine illustr\u00e9 est divis\u00e9 en sections pour accro\u00eetre la lisibilit\u00e9 (sport, news, annonces, m\u00e9t\u00e9o) de m\u00eame un code source est organis\u00e9 en \u00e9l\u00e9ments fonctionnels le plus souvent s\u00e9par\u00e9s en plusieurs fichiers et ces derniers parfois maintenus par diff\u00e9rents d\u00e9veloppeurs.</p> <p>Rappelons-le (et c'est tr\u00e8s important) :</p> <ul> <li>une fonction ne devrait pas d\u00e9passer un \u00e9cran de haut (~50 lignes) ;</li> <li>un fichier ne devrait pas d\u00e9passer 1000 lignes\u2009;</li> <li>une ligne ne devrait pas d\u00e9passer 80 caract\u00e8res.</li> </ul> <p>Donc \u00e0 un moment, il est essentiel de diviser son travail en cr\u00e9ant plusieurs fichiers.</p> <p>Ainsi, lorsque le programme commence \u00e0 \u00eatre volumineux, sa lecture, sa compr\u00e9hension et sa mise au point deviennent d\u00e9licates m\u00eame pour le plus aguerri des d\u00e9veloppeurs. Il est alors essentiel de scinder le code source en plusieurs fichiers. Prenons l'exemple d'un programme qui effectue des calculs sur les nombres complexes. Notre projet est donc constitu\u00e9 de trois fichiers\u2009:</p> <pre><code>$ tree\n.\n\u251c\u2500\u2500 complex.c\n\u251c\u2500\u2500 complex.h\n\u2514\u2500\u2500 main.c\n</code></pre> <p>Le programme principal et la fonction <code>main</code> est contenu dans <code>main.c</code> quant au module complex il est compos\u00e9 de deux fichiers\u2009: <code>complex.h</code> l'en-t\u00eate et <code>complex.c</code>, l'impl\u00e9mentation du module.</p> <p>Le fichier <code>main.c</code> devra inclure le fichier <code>complex.h</code> afin de pouvoir utiliser correctement les fonctions du module de gestion des nombres complexes. Exemple\u2009:</p> <pre><code>// fichier main.c\n#include \"complex.h\"\n\nint main() {\n    Complex c1 = { .real = 1., .imag = -3. };\n    complex_fprint(stdout, c1);\n}\n</code></pre> <pre><code>// fichier complex.h\n#ifndef COMPLEX_H\n#define COMPLEX_H\n\n#include &lt;stdio.h&gt;\n\ntypedef struct Complex {\n    double real;\n    double imag;\n} Complex, *pComplex;\n\nvoid complex_fprint(FILE *fp, const Complex c);\n\n#endif // COMPLEX_H\n</code></pre> <pre><code>// fichier complex.c\n#include \"complex.h\"\n\nvoid complex_fprint(FILE* fp, const Complex c) {\n    fprintf(fp, \"%+.3lf + %+.3lf\\n\", c.real, c.imag);\n}\n</code></pre> <p>Un des avantages majeurs \u00e0 la cr\u00e9ation de modules est qu'un module logiciel peut \u00eatre r\u00e9utilis\u00e9 pour d'autres applications. Plus besoin de r\u00e9inventer la roue \u00e0 chaque application\u2009!</p> <p>Cet exemple sera compil\u00e9 dans un environnement POSIX de la fa\u00e7on suivante\u2009:</p> <pre><code>gcc -c complex.c -o complex.o\ngcc -c main.c -o main.o\ngcc complex.o main.o -oprogram -lm\n</code></pre> <p>Nous verrons plus bas les \u00e9l\u00e9ments th\u00e9oriques vous permettant de mieux comprendre ces lignes.</p>"}, {"location": "course-c/30-modular-programming/translation-units/#module-logiciel", "title": "Module logiciel", "text": "<p>Les applications modernes d\u00e9pendent souvent de nombreux modules logiciels externes aussi utilis\u00e9s dans d'autres projets. C'est avantageux \u00e0 plus d'un titre\u2009:</p> <ul> <li>les modules externes sont sous la responsabilit\u00e9 d'autres d\u00e9veloppeurs et le programme a d\u00e9velopper comporte moins de code\u2009;</li> <li>les modules externes sont souvent bien document\u00e9s et test\u00e9s et il est facile de les utiliser\u2009;</li> <li>la lisibilit\u00e9 du programme est accrue, car il est bien d\u00e9coup\u00e9 en des ensembles fonctionnels\u2009;</li> <li>les modules externes sont r\u00e9utilisables et ind\u00e9pendants, ils peuvent donc \u00eatre r\u00e9utilis\u00e9s sur plusieurs projets.</li> </ul> <p>Lorsque vous utilisez la fonction <code>printf</code>, vous d\u00e9pendez d'un module externe nomm\u00e9 <code>stdio</code>. En r\u00e9alit\u00e9 l'ensemble des modules <code>stdio</code>, <code>stdlib</code>, <code>stdint</code>, <code>ctype</code>... sont tous group\u00e9s dans une seule biblioth\u00e8que logicielle nomm\u00e9e <code>libc</code> disponible sur tous les syst\u00e8mes compatibles POSIX. Sous Linux, le pendant libre <code>glibc</code> est utilis\u00e9. Il s'agit de la biblioth\u00e8que GNU C Library.</p> <p>Un module logiciel peut se composer de fichiers sources, c'est-\u00e0-dire un ensemble de fichiers <code>.c</code> et <code>.h</code> ainsi qu'une documentation et un script de compilation (<code>Makefile</code>). Alternativement, un module logiciel peut se composer de biblioth\u00e8ques d\u00e9j\u00e0 compil\u00e9es sous la forme de fichiers <code>.h</code>, <code>.a</code> et <code>.so</code>. Sous Windows on rencontre fr\u00e9quemment l'extension <code>.dll</code>. Ces fichiers compil\u00e9s ne donnent pas acc\u00e8s au code source, mais permettent d'utiliser les fonctionnalit\u00e9s quelles offrent dans des programmes C en mettant \u00e0 disposition un ensemble de fonctions document\u00e9es.</p>"}, {"location": "course-c/30-modular-programming/translation-units/#compilation-avec-assemblage-differe", "title": "Compilation avec assemblage diff\u00e9r\u00e9", "text": "<p>Lorsque nous avions compil\u00e9 notre premier exemple Hello World nous avions simplement appel\u00e9 <code>gcc</code> avec le fichier source <code>hello.c</code> qui nous avait cr\u00e9\u00e9 un ex\u00e9cutable <code>a.out</code>. En r\u00e9alit\u00e9, GCC est pass\u00e9 par plusieurs sous-\u00e9tapes de compilation\u2009:</p> <ol> <li>Pr\u00e9processing : les commentaires sont retir\u00e9s, les directives pr\u00e9processeur sont remplac\u00e9es par leur \u00e9quivalent C.</li> <li>Compilation : le code C d'une seule translation unit est converti en langage machine en un fichier objet <code>.o</code>.</li> <li>\u00c9dition des liens : aussi nomm\u00e9s link, les diff\u00e9rents fichiers objets sont r\u00e9unis en un seul ex\u00e9cutable.</li> </ol> <p>Lorsqu'un seul fichier est fourni \u00e0 GCC, les trois op\u00e9rations sont effectu\u00e9es en m\u00eame temps, mais ce n'est plus possible aussit\u00f4t que le programme est compos\u00e9 de plusieurs unit\u00e9s de translation (plusieurs fichiers C). Il est alors n\u00e9cessaire de compiler manuellement chaque fichier source et d'en cr\u00e9er.</p> <p>La figure suivante r\u00e9sume les diff\u00e9rentes \u00e9tapes de GCC. Les pointill\u00e9s indiquent \u00e0 quel niveau les op\u00e9rations peuvent s'arr\u00eater. Il est d\u00e8s lors possible de passer par des fichiers interm\u00e9diaires assembleur (<code>.s</code>) ou objets (<code>.o</code>) en utilisant la bonne commande.</p> <p> \u00c9tapes interm\u00e9diaires de compilation avec GCC</p> <p>Notons que ces \u00e9tapes existent, quel que soit le compilateur ou le syst\u00e8me d'exploitation. Nous retrouverons ces exactes m\u00eames \u00e9tapes avec Microsoft Visual Studio, mais le nom des commandes et les extensions des fichiers peuvent varier s'ils ne respectent pas la norme POSIX (et GNU).</p> <p>Notons que g\u00e9n\u00e9ralement, seul deux \u00e9tapes de GCC sont utilis\u00e9es\u2009:</p> <ol> <li>Compilation avec <code>gcc -c &lt;fichier.c&gt;</code>, ceci g\u00e9n\u00e8re automatiquement un fichier <code>.o</code> du m\u00eame nom que le fichier d'entr\u00e9e.</li> <li>\u00c9dition des liens avec <code>gcc &lt;fichier1.o&gt; &lt;fichier2.o&gt; ...</code>, ceci g\u00e9n\u00e8re automatiquement un fichier ex\u00e9cutable <code>a.out</code>.</li> </ol>"}, {"location": "course-c/30-modular-programming/translation-units/#fichiers-den-tete-header", "title": "Fichiers d'en-t\u00eate (header)", "text": "<p>Les fichiers d'en-t\u00eate (<code>.h</code>) sont des fichiers \u00e9crits en langage C, mais qui ne contiennent pas d'impl\u00e9mentation de fonctions. Un tel fichier ne contient donc pas de <code>while</code>, de <code>for</code> ou m\u00eame de <code>if</code>. Par convention, ces fichiers ne contiennent que\u2009:</p> <ul> <li>Des prototypes de fonctions (ou de variables).</li> <li>Des d\u00e9clarations de types (<code>typedef</code>, <code>struct</code>).</li> <li>Des d\u00e9finitions pr\u00e9processeur (<code>#include</code>, <code>#define</code>).</li> </ul> <p>Nous l'avons vu dans le chapitre sur le pr\u00e9processeur, la directive <code>#include</code> ne fais qu'inclure le contenu du fichier cible \u00e0 l'emplacement de la directive. Il est donc possible (mais fort d\u00e9conseill\u00e9), d'avoir la situation suivante\u2009:</p> main.c<pre><code>int main() {\n   #include \"foobar.def\"\n}\n</code></pre> <p>Et le fichier <code>foobar.def</code> pourrait contenir\u2009:</p> foobar.def<pre><code>#ifdef FOO\nprintf(\"hello foo!\\n\");\n#else\nprintf(\"hello bar!\\n\");\n#endif\n</code></pre> <p>Vous noterez que l'extension de <code>foobar</code> n'est pas <code>.h</code> puisque le contenu n'est pas un fichier d'en-t\u00eate. <code>.def</code> ou n'importe quelle autre extension pourrait donc faire l'affaire ici.</p> <p>Dans cet exemple, le pr\u00e9processeur ne fait qu'inclure le contenu du fichier <code>foobar.def</code> \u00e0 l'emplacement de la d\u00e9finition <code>#include \"foobar.def\"</code>. Voyons-le en d\u00e9tail\u2009:</p> <pre><code>$ cat &lt;&lt; EOF &gt; main.c\nint main() {\n    #include \"foobar.def\"\n    #include \"foobar.def\"\n}\nEOF\n\n$ cat &lt;&lt; EOF &gt; foobar.def\n#ifdef FOO\nprintf(\"hello foo!\\n\");\n#else\nprintf(\"hello bar!\\n\");\n#endif\nEOF\n\n$ gcc -E main.c | sed '/^#/ d'\nint main() {\nprintf(\"hello bar\\n\");\nprintf(\"hello bar\\n\");\n}\n</code></pre> <p>Lorsque l'on observe le r\u00e9sultat du pr\u00e9processeur, on s'aper\u00e7oit que toutes les directives pr\u00e9processeur ont disparues et que la directive <code>#include</code> a \u00e9t\u00e9 remplac\u00e9e par de contenu de <code>foobar.def</code>. Remarquons que le fichier est inclus deux fois, nous verrons plus loin comme \u00e9viter cela.</p> <p>Nous avons vu au chapitre sur les prototypes de fonctions qu'il est possible de ne d\u00e9clarer que la premi\u00e8re ligne d'une fonction. Ce prototype permet au compilateur de savoir combien d'arguments est compos\u00e9 une fonction sans n\u00e9cessairement disposer de l'impl\u00e9mentation de cette fonction. Aussi on trouve dans tous les fichiers d'en-t\u00eate des d\u00e9clarations en amont (forward declaration). Dans le fichier d'en-t\u00eate <code>stdio.h</code> on trouvera la ligne\u2009: <code>int printf( const char *restrict format, ... );</code>.</p> <pre><code>$ cat &lt;&lt; EOF &gt; main.c\n\u2192 #include &lt;stdio.h&gt;\n\u2192 int main() { }\n\u2192 EOF\n$ gcc -E main.c | grep -P '\\bprintf\\b'\nextern int printf (const char *__restrict __format, ...);\n</code></pre> <p>Notons qu'ici le prototype est pr\u00e9c\u00e9d\u00e9 par le mot cl\u00e9 <code>extern</code>. Il s'agit d'un mot cl\u00e9 optionnel permettant de renforcer l'intention du d\u00e9veloppeur que la fonction d\u00e9clar\u00e9e n'est pas inclue dans fichier courant, mais qu'elle est impl\u00e9ment\u00e9e ailleurs, dans un autre fichier. Et c'est le cas, car <code>printf</code> est d\u00e9j\u00e0 compil\u00e9e quelque part dans la biblioth\u00e8que <code>libc</code> inclue par d\u00e9faut lorsqu'un programme C est compil\u00e9 dans un environnement POSIX.</p> <p>Un fichier d'en-t\u00eate contiendra donc tout le n\u00e9cessaire utile \u00e0 pouvoir utiliser une biblioth\u00e8que externe.</p>"}, {"location": "course-c/30-modular-programming/translation-units/#protection-de-reentrance", "title": "Protection de r\u00e9entrance", "text": "<p>La protection de r\u00e9entrence aussi nomm\u00e9e header guards est une solution au probl\u00e8me d'inclusion multiple. Si par exemple on d\u00e9finit dans un fichier d'en-t\u00eate un nouveau type et que l'on inclut ce fichier, mais que ce dernier est d\u00e9j\u00e0 inclus par une autre biblioth\u00e8que, une erreur de compilation appara\u00eetra\u2009:</p> <pre><code>$ cat &lt;&lt; EOF &gt; main.c\n\u2192 #include \"foo.h\"\n\u2192 #include \"bar.h\"\n\u2192 int main() {\n\u2192    Bar bar = {0};\n\u2192    foo(bar);\n\u2192 }\n\u2192 EOF\n\n$ cat &lt;&lt; EOF &gt; foo.h\n\u2192 #include \"bar.h\"\n\u2192\n\u2192 extern void foo(Bar);\n\u2192 EOF\n\n$ cat &lt;&lt; EOF &gt; bar.h\n\u2192 typedef struct Bar {\n\u2192    int b, a, r;\n\u2192 } Bar;\n\u2192 EOF\n\n$ gcc main.c\nIn file included from main.c:2:0 :\nbar.h:1:16: error: redefinition of \u2018struct Bar\u2019\ntypedef struct Bar {\n                ^~~\nIn file included from foo.h:1:0,\n                from main.c:1 :\nbar.h:1:16: note: originally defined here\ntypedef struct Bar {\n                ^~~\nIn file included from main.c:2:0 :\nbar.h:3:3: error: conflicting types for \u2018Bar\u2019\n} Bar;\n^~~\n...\n</code></pre> <p>Dans cet exemple l'utilisateur ne sait pas forc\u00e9ment que <code>bar.h</code> est d\u00e9j\u00e0 inclus avec <code>foo.h</code> et le r\u00e9sultat apr\u00e8s pr\u00e9-processing est le suivant\u2009:</p> <pre><code>$ gcc -E main.c | sed '/^#/ d'\ntypedef struct Bar {\nint b, a, r;\n} Bar;\n\nextern void foo(Bar);\ntypedef struct Bar {\nint b, a, r;\n} Bar;\nint main() {\nBar bar = {0};\nfoo(bar);\n}\n</code></pre> <p>On y retrouve la d\u00e9finition de <code>Bar</code> deux fois et donc, le compilateur g\u00e9n\u00e8re une erreur.</p> <p>Une solution \u00e0 ce probl\u00e8me est d'ajouter des gardes d'inclusion multiple par exemple avec ceci\u2009:</p> <pre><code>#ifndef BAR_H\n#define BAR_H\n\ntypedef struct Bar {\nint b, a, r;\n} Bar;\n\n#endif // BAR_H\n</code></pre> <p>Si aucune d\u00e9finition du type <code>#define BAR_H</code> n'existe, alors le fichier <code>bar.h</code> n'a jamais \u00e9t\u00e9 inclus auparavant et le contenu de la directive <code>#ifndef BAR_H</code> dans lequel on commence par d\u00e9finir <code>BAR_H</code> est ex\u00e9cut\u00e9. Lors d'une future inclusion de <code>bar.h</code>, la valeur de <code>BAR_H</code> aura d\u00e9j\u00e0 \u00e9t\u00e9 d\u00e9finie et le contenu de la directive <code>#ifndef BAR_H</code> ne sera jamais ex\u00e9cut\u00e9.</p> <p>Alternativement, il existe une solution non standard, mais support\u00e9e par la plupart des compilateurs. Elle fait intervenir un pragma\u2009:</p> <pre><code>#pragma once\n\ntypedef struct Bar {\nint b, a, r;\n} Bar;\n</code></pre> <p>Cette solution est \u00e9quivalente \u00e0 la m\u00e9thode traditionnelle et pr\u00e9sente plusieurs avantages. C'est tout d'abord une solution atomique qui ne n\u00e9cessite pas un <code>#endif</code> \u00e0 la fin du fichier. Il n'y a ensuite pas de conflit avec la r\u00e8gle SSOT, car le nom du fichier <code>bar.h</code> n'appara\u00eet pas dans le fichier <code>BAR_H</code>.</p>"}, {"location": "course-c/30-modular-programming/translation-units/#en-profondeur", "title": "En profondeur", "text": "<p>Pour mieux comprendre la compilation s\u00e9par\u00e9e, tentons d'observer le code assembleur g\u00e9n\u00e9r\u00e9. Consid\u00e9rons le fichier <code>foo.c</code> :</p> <pre><code>int bar(int);\n\nint foo(int a) {\n    return bar(a) + 42;\n}\n</code></pre> <p>Puisqu'il ne contient pas de fonction main, il n'est pas possible de compiler ce fichier en un ex\u00e9cutable car il manque un point d'entr\u00e9e\u2009:</p> <pre><code>gcc foo.c\n/usr/bin/ld: /usr/lib/x86_64-linux-gnu/Scrt1.o: in function '_start':\n(.text+0x24): undefined reference to 'main'\ncollect2: error: ld returned 1 exit status\n</code></pre> <p>Le linker se termine avec une erreur\u2009: r\u00e9f\u00e9rence \u00e0 'main' inexistante.</p> <p>En revanche, il est possible de compiler un objet, c'est \u00e0 dire g\u00e9n\u00e9rer les instructions assembleur. La fonction <code>bar</code> \u00e9tant manquante, le compilateur suppose qu'elle existe quelque part en m\u00e9moire et se contentera de dire moi j'appelle cette fonction ou qu'elle se trouve.</p> <pre><code>$objdump -d foo.o\n\nfoo.o:     file format elf64-x86-64\n\nDisassembly of section .text:\n\n0000000000000000 &lt;foo&gt;:\n 0:   f3 0f 1e fa       endbr64\n 4:   55                push   %rbp\n 5:   48 89 e5          mov    %rsp,%rbp\n 8:   48 83 ec 10       sub    $0x10,%rsp\n c:   89 7d fc          mov    %edi,-0x4(%rbp)\n f:   8b 45 fc          mov    -0x4(%rbp),%eax\n12:   89 c7             mov    %eax,%edi\n14:   e8 00 00 00 00    callq  19 &lt;foo+0x19&gt;\n19:   83 c0 2a          add    $0x2a,%eax\n1c:   c9                leaveq\n1d:   c3                retq\n</code></pre> <p>On constate \u00e0 la ligne <code>19</code> que l'addition \u00e0 bien lieu <code>eax + 42</code>, et que l'appel de la fonction <code>bar</code> se produit \u00e0 la ligne <code>14</code>.</p> <p>Maintenant, consid\u00e9rons le programme principal\u2009:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint foo(int);\n\nint bar(int a) {\n    return a * 2;\n}\n\nint main() {\n    printf(\"%d\", foo(42));\n}\n</code></pre> <p>En g\u00e9n\u00e9rant l'objet <code>gcc -c main.c</code>, on peut \u00e9galement afficher l'assembleur g\u00e9n\u00e9r\u00e9 avec <code>objdump</code> :</p> <pre><code>$objdump -d main.o\n\nmain.o:     file format elf64-x86-64\n\nDisassembly of section .text:\n\n0000000000000000 &lt;bar&gt;:\n 0:   f3 0f 1e fa             endbr64\n 4:   55                      push   %rbp\n 5:   48 89 e5                mov    %rsp,%rbp\n 8:   89 7d fc                mov    %edi,-0x4(%rbp)\n b:   8b 45 fc                mov    -0x4(%rbp),%eax\n e:   01 c0                   add    %eax,%eax\n10:   5d                      pop    %rbp\n11:   c3                      retq\n\n0000000000000012 &lt;main&gt;:\n12:   f3 0f 1e fa             endbr64\n16:   55                      push   %rbp\n17:   48 89 e5                mov    %rsp,%rbp\n1a:   bf 2a 00 00 00          mov    $0x2a,%edi\n1f:   e8 00 00 00 00          callq  24 &lt;main+0x12&gt;\n24:   89 c6                   mov    %eax,%esi\n26:   48 8d 3d 00 00 00 00    lea    0x0(%rip),%rdi\n2d:   b8 00 00 00 00          mov    $0x0,%eax\n32:   e8 00 00 00 00          callq  37 &lt;main+0x25&gt;\n37:   b8 00 00 00 00          mov    $0x0,%eax\n3c:   5d                      pop    %rbp\n3d:   c3                      retq\n</code></pre> <p>On observe l'appel de la fonction <code>foo</code> \u00e0 la ligne <code>1f</code> et l'appel de <code>printf</code> \u00e0 la ligne <code>32</code>.</p> <p>L'assemblage de ces deux fichiers en un ex\u00e9cutable r\u00e9sout les liens en modifiant les adresses d'appel des fonctions puisqu'elles sont maintenant connues (notons que certaines lignes ont \u00e9t\u00e9 retir\u00e9es pour plus de lisibilit\u00e9) :</p> <pre><code>$ gcc foo.o main.o\n$ objdump -d a.out\n\na.out:     file format elf64-x86-64\n\nDisassembly of section .text:\n\n0000000000001149 &lt;foo&gt;:\n    1149:       f3 0f 1e fa             endbr64\n    114d:       55                      push   %rbp\n    114e:       48 89 e5                mov    %rsp,%rbp\n    1151:       48 83 ec 10             sub    $0x10,%rsp\n    1155:       89 7d fc                mov    %edi,-0x4(%rbp)\n    1158:       8b 45 fc                mov    -0x4(%rbp),%eax\n    115b:       89 c7                   mov    %eax,%edi\n    115d:       e8 05 00 00 00          callq  1167 &lt;bar&gt;\n    1162:       83 c0 2a                add    $0x2a,%eax\n    1165:       c9                      leaveq\n    1166:       c3                      retq\n\n0000000000001167 &lt;bar&gt;:\n    1167:       f3 0f 1e fa             endbr64\n    116b:       55                      push   %rbp\n    116c:       48 89 e5                mov    %rsp,%rbp\n    116f:       89 7d fc                mov    %edi,-0x4(%rbp)\n    1172:       8b 45 fc                mov    -0x4(%rbp),%eax\n    1175:       01 c0                   add    %eax,%eax\n    1177:       5d                      pop    %rbp\n    1178:       c3                      retq\n\n0000000000001179 &lt;main&gt;:\n    1179:       f3 0f 1e fa             endbr64\n    117d:       55                      push   %rbp\n    117e:       48 89 e5                mov    %rsp,%rbp\n    1181:       bf 2a 00 00 00          mov    $0x2a,%edi\n    1186:       e8 be ff ff ff          callq  1149 &lt;foo&gt;\n    118b:       89 c6                   mov    %eax,%esi\n    118d:       48 8d 3d 70 0e 00 00    lea    0xe70(%rip),%rdi\n    1194:       b8 00 00 00 00          mov    $0x0,%eax\n    1199:       e8 b2 fe ff ff          callq  1050 &lt;printf@plt&gt;\n    119e:       b8 00 00 00 00          mov    $0x0,%eax\n    11a3:       5d                      pop    %rbp\n    11a4:       c3                      retq\n    11a5:       66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)\n    11ac:       00 00 00\n    11af:       90                      nop\n</code></pre> <p>On constate que les appels de fonctions ont \u00e9t\u00e9 bien remplac\u00e9s par les bons noms\u2009:</p> <ul> <li><code>115d</code> Appel de <code>bar</code></li> <li><code>1186</code> Appel de <code>foo</code></li> <li><code>1199</code> Appel de <code>printf</code></li> </ul>"}, {"location": "course-c/35-libraries/introduction/", "title": "Biblioth\u00e8ques", "text": "<p> Biblioth\u00e8que du Trinity College de Dublin</p> <p>Une biblioth\u00e8que informatique est une collection de fichiers comportant des fonctionnalit\u00e9s logicielles pr\u00eates \u00e0 l'emploi. La <code>printf</code> est une de ces fonctionnalit\u00e9s et offerte par le header <code>&lt;stdio.h&gt;</code> faisant partie de la biblioth\u00e8que <code>libc6</code>.</p> <p>L'anglicisme library, plus court \u00e0 prononcer et \u00e0 \u00e9crire est souvent utilis\u00e9 en lieu et place de biblioth\u00e8que tant il est omnipr\u00e9sent dans le monde logiciel. Le terme <code>&lt;stdlib.h&gt;</code> \u00e9tant la concat\u00e9nation de standard library par exemple. Notez que librairie n'est pas la traduction correcte de library qui est un faux ami.</p> <p>Une library, \u00e0 l'instar d'une biblioth\u00e8que, contient du contenu (livre \u00e9crit dans une langue donn\u00e9e) et un index (registre). En informatique il s'agit d'un fichier binaire compil\u00e9 pour une architecture donn\u00e9e ainsi qu'un ou plusieurs fichiers d'en-t\u00eate (header) contenant les d\u00e9finitions de cette biblioth\u00e8que.</p> <p>Dans ce chapitre on donnera plusieurs exemples sur un environnement POSIX. Sous Windows, les proc\u00e9dures choses sont plus compliqu\u00e9es, mais les concepts restent les m\u00eames.</p>"}, {"location": "course-c/35-libraries/introduction/#exemple-libgmp", "title": "Exemple\u2009: libgmp", "text": "<p>Voyons ensemble le cas de libgmp. Il s'agit d'une biblioth\u00e8que de fonctionnalit\u00e9s tr\u00e8s utilis\u00e9e et permettant le calcul arithm\u00e9tique multipr\u00e9cision en C. En observant le d\u00e9tail du paquet logiciel Debian on peut lire que <code>libgmp</code> est disponible pour diff\u00e9rentes architectures <code>amd64</code>, <code>arm64</code>, <code>s390x</code>, <code>i386</code>, ... Un d\u00e9veloppement sur un Raspberry-PI n\u00e9cessitera <code>arm64</code> alors qu'un d\u00e9veloppement sur un PC utilisera <code>amd64</code>. En cliquant sur l'architecture d\u00e9sir\u00e9e on peut voir que ce paquet se compose des fichiers suivants (list r\u00e9duite aux fichiers concernant C):</p> <pre><code># Fichier d'en-t\u00eate C\n/usr/include/x86_64-linux-gnu/gmp.h\n\n# Biblioth\u00e8que compil\u00e9e pour l'architecture vis\u00e9e (ici amd64)\n/usr/lib/x86_64-linux-gnu/libgmp.a\n/usr/lib/x86_64-linux-gnu/libgmp.so\n\n# Documentation de la libgmp\n/usr/share/doc/libgmp-dev/AUTHORS\n/usr/share/doc/libgmp-dev/README\n/usr/share/doc/libgmp-dev/changelog.gz\n/usr/share/doc/libgmp-dev/copyright\n</code></pre> <p>On a donc\u2009:</p> <code>gmp.h</code> <p>Fichier d'en-t\u00eate \u00e0 include dans un fichier source pour utiliser les fonctionnalit\u00e9s</p> <code>libgmp.a</code> <p>Biblioth\u00e8que statique qui contient l'impl\u00e9mentation en langage machine des fonctionnalit\u00e9s \u00e0 r\u00e9f\u00e9rer au linker lors de la compilation</p> <code>libgmp.so</code> <p>Biblioth\u00e8que dynamique qui contient aussi l'impl\u00e9mentation en langage machine des fonctionnalit\u00e9s</p> <p>Imaginons que l'on souhaite b\u00e9n\u00e9ficier des fonctionnalit\u00e9s de cette biblioth\u00e8que pour le calcul d'orbites pour un satellite d'observation de Jupyter. Pour prendre en main cet libary on \u00e9crit ceci\u2009:</p> <pre><code>#include &lt;gmp.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void)\n{\n    unsigned int radix = 10;\n    char a[] = \"19810983098510928501928599999999999990\";\n\n    mpz_t n;\n\n    mpz_init(n);\n    mpz_set_ui(n, 0);\n\n    mpz_set_str(n, a, radix);\n\n    mpz_out_str(stdout, radix, n);\n    putchar('\\n');\n\n    mpz_add_ui(n, n, 12); // Addition\n\n    mpz_out_str(stdout, radix, n);\n    putchar('\\n');\n\n    mpz_mul(n, n, n); // Square\n\n    mpz_out_str(stdout, radix, n);\n    putchar('\\n');\n\n    mpz_clear(n);\n}\n</code></pre> <p>Puis on compile\u2009:</p> <pre><code>$ gcc gmp.c\ngmp.c:1:10: fatal error: gmp.h: No such file or directory\n#include &lt;gmp.h&gt;\n        ^~~~~~~\ncompilation terminated.\n</code></pre> <p>A\u00efe\u2009! La biblioth\u00e8que n'est pas install\u00e9e...</p> <p>Pour l'installer, cela d\u00e9pend de votre syst\u00e8me d'exploitation\u2009:</p> UbuntumacOS <pre><code>$ sudo apt-get install libgmp-dev\n</code></pre> <pre><code>$ brew install gmp\n</code></pre> <p>Deuxi\u00e8me tentative\u2009:</p> <pre><code>$ gcc gmp.c\n/tmp/cc2FxDSy.o: In function `main':\ngmp.c:(.text+0x6f): undefined reference to `__gmpz_init'\ngmp.c:(.text+0x80): undefined reference to `__gmpz_set_ui'\ngmp.c:(.text+0x96): undefined reference to `__gmpz_set_str'\ngmp.c:(.text+0xb3): undefined reference to `__gmpz_out_str'\ngmp.c:(.text+0xd5): undefined reference to `__gmpz_add_ui'\ngmp.c:(.text+0xf2): undefined reference to `__gmpz_out_str'\ngmp.c:(.text+0x113): undefined reference to `__gmpz_mul'\ngmp.c:(.text+0x130): undefined reference to `__gmpz_out_str'\ngmp.c:(.text+0x146): undefined reference to `__gmpz_clear'\ncollect2: error: ld returned 1 exit status\n</code></pre> <p>Cette fois-ci on peut lire que le compilateur \u00e0 fait sont travail, mais ne parvient pas \u00e0 trouver les symboles des fonctions que l'on utilise p.ex. <code>__gmpz_add_ui</code>. C'est normal parce que l'on n'a pas renseign\u00e9 la biblioth\u00e8que \u00e0 utiliser.</p> <pre><code>$ gcc gmp.c -lgmp\n\n$ ./a.out\n19810983098510928501928599999999999990\n19810983098510928501928600000000000002\n392475051329485669436248957939688603493163430354043714007714400000000000004\n</code></pre> <p>Cette mani\u00e8re de faire utilise le fichier <code>libgmp.so</code> qui est la biblioth\u00e8que dynamique, c'est-\u00e0-dire que ce fichier est n\u00e9cessaire pour que le programme puisse fonctionner. Si je donne mon ex\u00e9cutable \u00e0 un ami qui n'as pas install libgmp sur son ordinateur, il ne sera pas capable de l'ex\u00e9cuter.</p> <p>Alternativement on peut compiler le m\u00eame programme en utilisant la librairie statique</p> <pre><code>$ gcc gmp.c /usr/lib/x86_64-linux-gnu/libgmp.a\n</code></pre> <p>C'est-\u00e0-dire qu'\u00e0 la compilation toutes les fonctionnalit\u00e9s ont \u00e9t\u00e9 int\u00e9gr\u00e9es \u00e0 l'ex\u00e9cutable et il ne d\u00e9pend de plus rien d'autre que le syst\u00e8me d'exploitation. Je peux prendre ce fichier le donner \u00e0 quelqu'un qui utilise la m\u00eame architecture et il pourra l'ex\u00e9cuter. En revanche, la taille du programme est plus grosse\u2009:</p> <pre><code># ~167 KiB\n$ gcc gmp.c -l:libgmp.a\n$ size a.out\ntext    data     bss     dec     hex filename\n155494     808      56  156358   262c6 ./a.out\n\n# ~8.5 KiB\n$ gcc gmp.c -lgmp\n$ size a.out\ntext    data     bss     dec     hex filename\n2752     680      16    3448     d78 ./a.out\n</code></pre>"}, {"location": "course-c/35-libraries/introduction/#exemple-ncurses", "title": "Exemple\u2009: ncurses", "text": "<p>La biblioth\u00e8que ncurses traduction de nouvelles mal\u00e9dictions est une \u00e9volution de curses d\u00e9velopp\u00e9 originellement par Ken Arnold . Il s'agit d'une biblioth\u00e8que pour la cr\u00e9ation d'interfaces graphique en ligne de commande, toujours tr\u00e8s utilis\u00e9e.</p> <p>La biblioth\u00e8que permet le positionnement arbitraire dans la fen\u00eatre de commande, le dessin de fen\u00eatres, de menus, d'ombrage sous les fen\u00eatres, de couleurs ...</p> <p> Exemple d'interface graphique \u00e9crite avec <code>ncurses</code>. Ici la configuration du noyau Linux.</p> <p>L'\u00e9criture d'un programme Hello World avec cette biblioth\u00e8que pourrait \u00eatre\u2009:</p> <pre><code>#include &lt;ncurses.h&gt;\n\nint main()\n{\n    initscr();              // Start curses mode\n    printw(\"hello, world\"); // Print Hello World\n    refresh();              // Print it on to the real screen\n    getch();                    // Wait for user input\n    endwin();               // End curses mode\n\n    return 0;\n}\n</code></pre> <p>La compilation n'est possible que si\u2009:</p> <ol> <li>La biblioth\u00e8que est install\u00e9e sur l'ordinateur</li> <li>Le lien vers la biblioth\u00e8que dynamique est mentionn\u00e9 \u00e0 la compilation</li> </ol> <pre><code>$ gcc ncurses-hello.c -ohello -lncurses\n</code></pre>"}, {"location": "course-c/35-libraries/introduction/#bibliotheques-statiques", "title": "Biblioth\u00e8ques statiques", "text": "<p>Une static library est un fichier binaire compil\u00e9 pour une architecture donn\u00e9e et portant les extensions\u2009:</p> <ul> <li><code>.a</code> sur un syst\u00e8me POSIX (Android, Mac OS, Linux, Unix)</li> <li><code>.lib</code> sous Windows</li> </ul> <p>Une biblioth\u00e8que statique n'est rien d'autre qu'une archive d\u2019un ou plusieurs objets. Rappelons-le un objet est le r\u00e9sultat d'une compilation.</p> <p>Par exemple si l'on souhaite \u00e9crire une biblioth\u00e8que statique pour le code de C\u00e9sar on \u00e9crira un fichier source <code>caesar.c</code>:</p> caesar.c<pre><code>void caesar(char str[], unsigned key)\n{\n    key %= 26;\n\n    for (int i = 0; str[i]; i++)\n    {\n        char c = str[i];\n\n        if (c &gt;= 'a' &amp;&amp; c &lt;= 'z')\n        {\n            str[i] = ((c + key &gt; 'z') ? c - 'z' + 'a' - 1 : c) + key;\n        }\n        else if (c &gt;= 'A' &amp;&amp; c &lt;= 'Z')\n        {\n            str[i] = ((c + key &gt; 'Z') ? c - 'Z' + 'A' - 1 : c) + key;\n        }\n    }\n}\n</code></pre> <p>Ainsi qu'un fichier d'en-t\u00eate <code>caesar.h</code>:</p> caesar.h<pre><code>/**\n * Function that compute the Caesar cipher\n * @param str input string\n * @param key offset to add to each character\n */\nvoid caesar(char str[], unsigned key);\n</code></pre> <p>Pour cr\u00e9er une biblioth\u00e8que statique rien de plus facile. Le compilateur cr\u00e9e l'objet, l'archiver cr\u00e9e l'amalgame\u2009:</p> <pre><code>$ gcc -c -o caesar.o caesar.c\n$ ar rcs caesar.a caesar.o\n</code></pre> <p>Puis il suffit d'\u00e9crire un programme pour utiliser cette biblioth\u00e8que\u2009:</p> encrypt.c<pre><code>#include &lt;caesar.h&gt;\n#include &lt;stdio.h&gt;\n\n#define KEY 13\n\nint main(int argc, char *argv[])\n{\n    for (int i = 1; i &lt; argc; i++)\n    {\n        caesar(argv[i], KEY);\n        printf(\"%s\\n\", argv[i]);\n    }\n}\n</code></pre> <p>Et de compiler le tout. Ici on utilise <code>-I.</code> et <code>-L.</code> pour dire au compilateur de chercher le fichier d'en-t\u00eate et la biblioth\u00e8que dans le r\u00e9pertoire courant.</p> <pre><code>$ gcc encrypt.c -I. -L. -l:caesar.a\n</code></pre> <p>La proc\u00e9dure sous Windows est plus compliqu\u00e9e et ne sera pas d\u00e9crite ici.</p>"}, {"location": "course-c/35-libraries/introduction/#bibliotheques-dynamiques", "title": "Biblioth\u00e8ques dynamiques", "text": "<p>Une dynamic library est un fichier binaire compil\u00e9 pour une architecture donn\u00e9e et portant les extensions\u2009:</p> <ul> <li><code>.so</code> sur un syst\u00e8me POSIX (Android, Mac OS, Linux, Unix)</li> <li><code>.dll</code> sous Windows</li> </ul> <p>L'avantage principal est de ne pas charger pour rien chaque ex\u00e9cutable compil\u00e9 de fonctionnalit\u00e9s qui pourraient tr\u00e8s bien \u00eatre partag\u00e9es. L'inconv\u00e9nient est que l'utilisateur du programme doit imp\u00e9rativement avoir install\u00e9 la biblioth\u00e8que. Dans un environnement POSIX les biblioth\u00e8ques dynamiques disposent d'un emplacement sp\u00e9cifique ou elles sont toute stock\u00e9es. Malheureusement sous Windows le consensus est plus partag\u00e9 et il n'est pas rare de voir plusieurs applications diff\u00e9rentes h\u00e9berger une copie des dll localement si bien que l'avantage de la biblioth\u00e8que dynamique est an\u00e9anti par un d\u00e9faut de coh\u00e9rence.</p> <p>Reprenant l'exemple de C\u00e9sar vu plus haut, on peut cr\u00e9er une biblioth\u00e8que dynamique\u2009:</p> <pre><code>$ gcc -shared -o libcaesar.so caesar.o\n</code></pre> <p>Puis compiler notre programme pour utiliser cette biblioth\u00e8que. Avec une biblioth\u00e8que dynamique, il faut sp\u00e9cifier au compilateur quels sont les chemins vers lesquels il pourra trouver les biblioth\u00e8ques install\u00e9es. Comme ici on ne souhaite pas installer la biblioth\u00e8que et la rendre disponible pour tous les programmes, il faut ajouter aux chemins par d\u00e9faut, le chemin local <code>$(pwd .)</code>, en cr\u00e9ant une variable d'environnement nomm\u00e9e <code>LIBRARY_PATH</code>.</p> <pre><code>$ LIBRARY_PATH=$(pwd .) gcc encrypt.c -I. -lcaesar\n</code></pre> <p>Le probl\u00e8me est identique \u00e0 l'ex\u00e9cution, car il faut sp\u00e9cifier (ici avec <code>LD_LIBRARY_PATH</code>) le chemin ou le syst\u00e8me d'exploitation s'attendra \u00e0 trouver la biblioth\u00e8que.</p> <pre><code>$ LD_LIBRARY_PATH=$(pwd .) ./a.out ferrugineux\nsreehtvarhk\n</code></pre> <p>Car sinon c'est l'erreur\u2009:</p> <pre><code>$ LIBRARY_PATH=$(pwd .) ./a.out Hey?\n./a.out: error while loading shared libraries: libcaesar.so :\ncannot open shared object file: No such file or directory\n</code></pre>"}, {"location": "course-c/35-libraries/standard-library/", "title": "Standard library", "text": ""}, {"location": "course-c/35-libraries/standard-library/#bibliotheques-standard", "title": "Biblioth\u00e8ques standard", "text": "<p>Les biblioth\u00e8ques standard (C standard library) sont une collection normalis\u00e9e d'en-t\u00eates portables. C'est \u00e0 dire que quelque soit le compilateur et l'architecture cible, cette collection sera accessible.</p> <p>Le standard C99 d\u00e9finit un certain nombre d'en-t\u00eates dont les plus utilis\u00e9s (et ceux utilis\u00e9s dans ce cours) sont\u2009:</p> <code>&lt;assert.h&gt;</code> <p>Contient la macro <code>assert</code> pour valider certains pr\u00e9requis.</p> <code>&lt;complex.h&gt;</code> <p>Pour manipuler les nombres complexes</p> <code>&lt;float.h&gt;</code> <p>Contient les constantes qui d\u00e9finissent la pr\u00e9cision des types flottants sur l'architecture cible. <code>float</code> et <code>double</code> n'ont pas besoin de cet en-t\u00eate pour \u00eatre utilis\u00e9s.</p> <code>&lt;limits.h&gt;</code> <p>Contient les constantes qui d\u00e9finissent les limites des types entiers.</p> <code>&lt;math.h&gt;</code> <p>Fonctions math\u00e9matiques <code>sin</code>, <code>cos</code>, ...</p> <code>&lt;stdbool.h&gt;</code> <p>D\u00e9fini le type bool\u00e9en et les constantes <code>true</code> et <code>false</code>.</p> <code>&lt;stddef.h&gt;</code> <p>D\u00e9fini certaines macros comme <code>NULL</code></p> <code>&lt;stdint.h&gt;</code> <p>D\u00e9fini les types standard d'entiers (<code>int32_t</code>, <code>int_fast64_t</code>, ...).</p> <code>&lt;stdio.h&gt;</code> <p>Permet l'acc\u00e8s aux entr\u00e9es sorties standard (<code>stdin</code>, <code>stdout</code>, <code>stderr</code>). D\u00e9finis entre autres la fonction <code>printf</code>.</p> <code>&lt;stdlib.h&gt;</code> <p>Permet l'allocation dynamique et d\u00e9fini <code>malloc</code></p> <code>&lt;string.h&gt;</code> <p>Manipulation des cha\u00eenes de caract\u00e8res</p> <code>&lt;time.h&gt;</code> <p>Acc\u00e8s au fonctions lecture et de conversion de date et d'heure.</p> <p>Exercise\u2009: Arc-cosinus</p> <p>La fonction Arc-Cosinus <code>acos</code> est-elle d\u00e9finie par le standard et dans quel fichier d'en-t\u00eate est-elle d\u00e9clar\u00e9e\u2009? Un fichier d'en-t\u00eate se termine avec l'extension <code>.h</code>.</p> Solution <p>En cherchant <code>man acos header</code> dans Google, on trouve que la fonction <code>acos</code> est d\u00e9finie dans le header <code>&lt;math.h&gt;</code>.</p> <p>Une autre solution est d'utiliser sous Linux la commande <code>apropos</code>:</p> <pre><code>$ apropos acos\nacos (3)     - arc cosine function\nacosf (3)    - arc cosine function\nacosh (3)    - inverse hyperbolic cosine function\nacoshf (3)   - inverse hyperbolic cosine function\nacoshl (3)   - inverse hyperbolic cosine function\nacosl (3)    - arc cosine function\ncacos (3)    - complex arc cosine\ncacosf (3)   - complex arc cosine\ncacosh (3)   - complex arc hyperbolic cosine\ncacoshf (3)  - complex arc hyperbolic cosine\ncacoshl (3)  - complex arc hyperbolic cosine\ncacosl (3)   - complex arc cosine\n</code></pre> <p>Le premier r\u00e9sultat permet ensuite de voir\u2009:</p> <pre><code>$ man acos | head -10\nACOS(3)    Linux Programmer's Manual         ACOS(3)\n\nNAME\n    acos, acosf, acosl - arc cosine function\n\nSYNOPSIS\n    #include &lt;math.h&gt;\n\n    double acos(double x);\n    float acosf(float x);\n</code></pre> <p>La r\u00e9ponse est donc <code>&lt;math.h&gt;</code>.</p> <p>Sous Windows avec Visual Studio, il suffit d'\u00e9crire <code>acos</code> dans un fichier source et d'appuyer sur <code>F1</code>. L'IDE redirige l'utilisateur sur l'aide Microsoft acos-acosf-acosl qui indique que le header source est <code>&lt;math.h&gt;</code>.</p> <p>Exercise\u2009: Date</p> <p>Lors du formatage d'une date, on y peut y lire <code>%w</code>, par quoi sera remplac\u00e9 ce token ?</p>"}, {"location": "course-c/35-libraries/standard-library/#fonctions-dinteret", "title": "Fonctions d'int\u00e9r\u00eat", "text": "<p>Il serait inutile ici de lister toutes les fonctions, les biblioth\u00e8ques standard \u00e9tant largement document\u00e9es sur internet. Il ne fait aucun doute que le d\u00e9veloppeur sera trouver comment calculer un sinus avec la fonction <code>sin</code>. N\u00e9anmoins l'existence de certaines fonctions peut passer inaper\u00e7ues et c'est de celles-ci don't j'aimerais parler.</p>"}, {"location": "course-c/35-libraries/standard-library/#math", "title": "Math", "text": "Constantes math\u00e9matiques Constantes Description <code>M_PI</code> Valeur de :math\u2009:<code>\\pi</code> <code>M_E</code> Valeur de :math\u2009:<code>e</code> <code>M_SQRT1_2</code> Valeur de :math\u2009:<code>1/\\sqrt(2)</code>  Fonctions math\u00e9matiques Fonction Description <code>exp(x)</code> Exponentielle :math\u2009:<code>e^x</code> <code>ldexp(x,n)</code> Exposant d'un nombre flottant :math\u2009:<code>x\\cdot2^n</code> <code>log(x)</code> Logarithme binaire :math\u2009:<code>\\log_{2}(x)</code> <code>log10(x)</code> Logarithme d\u00e9cimal :math\u2009:<code>\\log_{10}(x)</code> <code>pow(x,y)</code> Puissance :math\u2009:<code>x^y</code> <code>sqrt(x)</code> Racine carr\u00e9e :math\u2009:<code>\\sqrt(x)</code> <code>cbrt(x)</code> Racine cubique :math\u2009:<code>\\sqrt[3](x)</code> <code>hypot(x,y)</code> Hypot\u00e9nuse optimis\u00e9 :math\u2009:<code>\\sqrt(x^2 + y^2)</code> <code>ceil</code> Arrondi \u00e0 l'entier sup\u00e9rieur <code>floor</code> Arrondi \u00e0 l'entier inf\u00e9rieur <p>Notons par exemple que la fonction <code>hypot</code> peut tr\u00e8s bien \u00eatre \u00e9mul\u00e9e facilement en utilisant la fonction <code>sqrt</code>. N\u00e9anmoins elle existe pour deux raisons \u00e9l\u00e9mentaires\u2009:</p> <ol> <li>\u00c9viter les d\u00e9passements (overflow).</li> <li>Une meilleure optimisation du code.</li> </ol> <p>Souvent, les processeurs sont \u00e9quip\u00e9s de coprocesseurs arithm\u00e9tiques capables de calculer certaines fonctions plus rapidement.</p>"}, {"location": "course-c/35-libraries/standard-library/#chaines-de-caracteres", "title": "Cha\u00eenes de caract\u00e8res", "text": "<code>strcopy(dst, src)</code> <p>Identique \u00e0 <code>memcpy</code> mais sans n\u00e9cessit\u00e9 de donner   la taille de la cha\u00eene puisqu'elle se termine par <code>\\0</code></p> <code>memmove(dst, src, n)</code> <p>Identique \u00e0 <code>memcpy</code> mais traite les cas particuliers lorsque   les deux r\u00e9gions m\u00e9moire se superposent.</p>"}, {"location": "course-c/35-libraries/standard-library/#types-de-donnees", "title": "Types de donn\u00e9es", "text": "<p>Test d'une propri\u00e9t\u00e9 d'un caract\u00e8re pass\u00e9 en param\u00e8tre</p>  Fonctions de test de caract\u00e8res Fonction Description <code>isalnum</code> une lettre ou un chiffre <code>isalpha</code> une lettre <code>iscntrl</code> un caract\u00e8re de commande <code>isdigit</code> un chiffre d\u00e9cimal <code>isgraph</code> un caract\u00e8re imprimable ou le blanc <code>islower</code> une lettre minuscule <code>isprint</code> un caract\u00e8re imprimable (pas le blanc) <code>ispunct</code> un caract\u00e8re imprimable pas isalnum <code>isspace</code> un caract\u00e8re d'espace blanc <code>isupper</code> une lettre majuscule <code>isxdigit</code> un chiffre hexad\u00e9cimal"}, {"location": "course-c/35-libraries/standard-library/#limites", "title": "Limites", "text": "Valeurs limites pour les entiers sign\u00e9s et non sign\u00e9s Constante Valeur <code>SCHAR_MIN</code> -128 <code>SCHAR_MAX</code> +127 <code>CHAR_MIN</code> 0 <code>CHAR_MAX</code> 255 <code>SHRT_MIN</code> -32768 <code>SHRT_MAX</code> +32767 <code>USHRT_MAX</code> 65535 <code>LONG_MIN</code> -2147483648 <code>LONG_MAX</code> +2147483647 <code>ULONG_MAX</code> +4294967295 <code>DBL_MAX</code> 1E+37 ou plus <code>DBL_EPSILON</code> 1E-9 ou moins"}, {"location": "course-c/35-libraries/third-party-libraries/", "title": "Third party libraries", "text": ""}, {"location": "course-c/35-libraries/third-party-libraries/#autres-bibliotheques", "title": "Autres biblioth\u00e8ques", "text": "<ul> <li>GNU C Library (glibc)</li> <li>C11</li> <li>POSIX.1-2008</li> <li>IEEE 754-2008</li> </ul>"}, {"location": "course-c/35-libraries/third-party-libraries/#posix-c-library", "title": "POSIX C Library", "text": "<p>Le standard C ne d\u00e9finit que le minimum vital et qui est valable sur toutes les architectures pour autant que la toolchain soit compatible C99. Il existe n\u00e9anmoins toute une collection d'autres fonctions manquantes\u2009:</p> <ul> <li> <p>La communication entre les processus (deux programmes qui souhaitent communiquer entre eux)</p> </li> <li> <p><code>&lt;sys/socket.h&gt;</code></p> </li> <li> <p><code>&lt;sharedmemory.h&gt;</code></p> </li> <li> <p>La communication sur le r\u00e9seau e.g. internet</p> </li> <li> <p><code>&lt;sys/socket.h&gt;</code></p> </li> <li><code>&lt;arpa/inet.h&gt;</code></li> <li> <p><code>&lt;net/if.h&gt;</code></p> </li> <li> <p>Les t\u00e2ches</p> </li> <li> <p><code>&lt;thread.h&gt;</code></p> </li> <li> <p>Les traductions de cha\u00eenes p.ex. fran\u00e7ais vers anglais</p> </li> <li> <p><code>&lt;iconv.h&gt;</code></p> </li> <li> <p>Les fonctions avanc\u00e9es de recherche de texte</p> </li> <li> <p><code>&lt;regex.h&gt;</code></p> </li> <li> <p>Le log centralis\u00e9 des messages (d'erreur)</p> </li> <li> <p><code>&lt;syslog.h&gt;</code></p> </li> </ul> <p>Toutes ces biblioth\u00e8ques additionnelles ne sont pas n\u00e9cessairement disponibles sur votre ordinateur ou pour le syst\u00e8me cible, surtout si vous convoitez une application bare-metal. Elles d\u00e9pendent grandement du syst\u00e8me d'exploitation utilis\u00e9, mais une tentative de normalisation existe et se nomme POSIX (ISO/IEC 9945).</p> <p>G\u00e9n\u00e9ralement la vaste majorit\u00e9 des distributions Linux et Unix sont compatibles avec le standard POSIX et les biblioth\u00e8ques ci-dessus seront disponibles \u00e0 moins que vous ne visiez une architecture diff\u00e9rente de celle sur laquelle s'ex\u00e9cute votre compilateur.</p> <p>Le support POSIX sous Windows (Win32) n'est malheureusement que partiel et il n'est pas standardis\u00e9.</p> <p>Un point d'entr\u00e9e de l'API POSIX est la biblioth\u00e8que <code>&lt;unistd.h&gt;</code>.</p>"}, {"location": "course-c/35-libraries/third-party-libraries/#gnu-glibc", "title": "GNU GLIBC", "text": "<p>La biblioth\u00e8que portable GNULIB est la biblioth\u00e8que standard r\u00e9f\u00e9renc\u00e9e sous Linux par <code>libc6</code>.</p>"}, {"location": "course-c/35-libraries/third-party-libraries/#windows-c-library", "title": "Windows C library", "text": "<p>La biblioth\u00e8que Windows Windoes API offre une interface au syst\u00e8me de fichier, au registre Windows, aux imprimantes, \u00e0 l'interface de fen\u00eatrage, \u00e0 la console et au r\u00e9seau.</p> <p>L'acc\u00e8s \u00e0 cet API est offert par un unique point d'entr\u00e9e windows.h qui regroupe certains en-t\u00eates standards (<code>&lt;stdarg.h&gt;</code>, <code>&lt;string.h&gt;</code>, ...), mais pas tous (\ud83d\ude14) ainsi que les en-t\u00eates sp\u00e9cifiques \u00e0 Windows tels que\u2009:</p> <code>&lt;winreg.h&gt;</code> <p>Pour l'acc\u00e8s au registre Windows</p> <code>&lt;wincon.h&gt;</code> <p>L'acc\u00e8s \u00e0 la console</p> <p>La documentation est disponible en ligne depuis le site de Microsoft, mais n'est malheureusement pas compl\u00e8te et souvent il est difficile de savoir sur quel site trouver la bonne version de la bonne documentation. Par exemple, il n'y a aucune documentation claire de <code>LSTATUS</code> pour la fonction RegCreateKeyExW permettant de cr\u00e9er une entr\u00e9e dans la base de registre.</p> <p>Un bon point d'entr\u00e9e est le Microsoft API and reference catalog.</p> <p>Quelques observations\u2009:</p> <ul> <li>Officiellement Windows est compatible avec C89 (ANSI C) (c.f. C Language Reference)</li> <li>L'API Windows n'est pas officiellement compatible avec C99, mais elle s'en approche, il n'y pas ou peu de documents expliquant les diff\u00e9rences.</li> <li>Microsoft n'a aucune priorit\u00e9 pour d\u00e9velopper son support C, il se focalise davantage sur C++ et C#, c'est pourquoi certains \u00e9l\u00e9ments du langage ne sont pas ou peu document\u00e9s.</li> <li>Les types standards Windows diff\u00e9rent de ceux propos\u00e9s par C99. Par exemple, <code>LONG32</code> remplace <code>int32_t</code>.</li> </ul>"}, {"location": "course-c/40-algorithms/introduction/", "title": "Introduction", "text": ""}, {"location": "course-c/40-algorithms/introduction/#introduction", "title": "Introduction", "text": "... conduire par ordre mes pens\u00e9es, en commen\u00e7ant par les objets les plus simples et les plus ais\u00e9s \u00e0 conna\u00eetre, pour monter peu \u00e0 peu, comme par degr\u00e9s, jusques \u00e0 la connaissance des plus compos\u00e9s; et supposant m\u00eame de l'ordre entre ceux qui ne se pr\u00e9c\u00e8dent point naturellement les uns les autres.Ren\u00e9 Descartes, Discours de la m\u00e9thode <p>L'algorithmique est le domaine scientifique qui \u00e9tudie les algorithmes, une suite finie et non ambigu\u00eb d'op\u00e9rations ou d'instructions permettant de r\u00e9soudre un probl\u00e8me ou de traiter des donn\u00e9es.</p> <p>Un algorithme peut \u00eatre \u00e9galement consid\u00e9r\u00e9 comme \u00e9tant n'importe quelle s\u00e9quence d'op\u00e9rations pouvant \u00eatre simul\u00e9es par un syst\u00e8me Turing-complet. Un syst\u00e8me est d\u00e9clar\u00e9 Turing-complet s'il peut simuler n'importe quelle machine de Turing. For heureusement, le langage C est Turing-complet puisqu'il poss\u00e8de tous les ingr\u00e9dients n\u00e9cessaires \u00e0 la simulation de ces machines, soit compter, comparer, lire, \u00e9crire...</p> <p>Dans le cas qui concerne cet ouvrage, un algorithme est une recette exprim\u00e9e en une liste d'instructions et permettant de r\u00e9soudre un probl\u00e8me informatique. Cette recette contient \u00e0 peu de choses pr\u00e8s les \u00e9l\u00e9ments programmatiques que nous avons d\u00e9j\u00e0 entre aper\u00e7us\u2009: des structures de contr\u00f4le, des variables, etc.</p> <p>G\u00e9n\u00e9ralement un algorithme peut \u00eatre exprim\u00e9 graphiquement en utilisant un organigramme (flowchart) ou un structogramme (Nassi-Shneiderman diagram) afin de s'affranchir du langage de programmation cible.</p> <p>La conception aussi appel\u00e9e Architecture logicielle est l'art de penser un programme avant son impl\u00e9mentation. La phase de conception fait bien souvent appel \u00e0 des algorithmes.</p> <p>Pour \u00eatre qualifi\u00e9es d'algorithmes, certaines propri\u00e9t\u00e9s doivent \u00eatre respect\u00e9es\u2009:</p> <ol> <li>Entr\u00e9es, un algorithme doit poss\u00e9der 0 ou plus d'entr\u00e9es en provenance de l'ext\u00e9rieur de l'algorithme.</li> <li>Sorties, un algorithme doit poss\u00e9der au moins une sortie.</li> <li>Rigueur, chaque \u00e9tape d'un algorithme doit \u00eatre claire et bien d\u00e9finie.</li> <li>Finitude, un algorithme doit comporter un nombre fini d'\u00e9tapes.</li> <li>R\u00e9p\u00e9table, un algorithme doit fournir un r\u00e9sultat r\u00e9p\u00e9table.</li> </ol>"}, {"location": "course-c/40-algorithms/introduction/#complexite-dun-algorithme", "title": "Complexit\u00e9 d'un algorithme", "text": "<p>Il est souvent utile de savoir quelle est la performance d'un algorithme afin de le comparer \u00e0 un autre algorithme \u00e9quivalent. Il existe deux indicateurs\u2009:</p> <ul> <li>La complexit\u00e9 en temps\u2009: combien de temps CPU consomme un algorithme pour s'ex\u00e9cuter.</li> <li>La complexit\u00e9 en m\u00e9moire\u2009: combien de m\u00e9moire tampon consomme un algorithme pour s'ex\u00e9cuter.</li> </ul> <p>Bien \u00e9videmment, la complexit\u00e9 d'un algorithme d\u00e9pend des donn\u00e9es en entr\u00e9e. Par exemple si on vous donne \u00e0 corriger un examen de 100 copies, et le protocol de correction associ\u00e9, votre temps de travail d\u00e9pendra du nombre de copies \u00e0 corriger, je sais de quoi je parle...</p> <p>La complexit\u00e9 en temps et en m\u00e9moire d'un algorithme est souvent exprim\u00e9e en utilisant la notation en O (big O notation). Cette notation a \u00e9t\u00e9 ontroduite par le math\u00e9maticien et informaticien allemand Paul Bachmann en 1984 dans son ouvrage Analytische Zahlentheorie. Cependant, c'est le math\u00e9maticien austro-hongrois Edmund Landau qui a popularis\u00e9 cette notation dans le contexte de la th\u00e9orie des nombres.</p> <p>En substance, la complexit\u00e9 en temps d'un algorithme qui demanderait 10 \u00e9tapes pour \u00eatre r\u00e9solu s'\u00e9crirait\u2009:</p> \\[ O(10) \\] <p>Un algorithme qui ferait une recherche dichotomique sur un tableau de \\(n\\) \u00e9l\u00e9ments \u00e0 une complexit\u00e9 \\(O(log(n))\\). La recherche dichotomique c'est comme chercher un mot dans un dictionnaire. Vous ouvrez le dictionnaire \u00e0 la moiti\u00e9, si le mot est avant, vous r\u00e9p\u00e9tez l'op\u00e9ration sur la premi\u00e8re moiti\u00e9, sinon sur la seconde. Vous r\u00e9p\u00e9tez l'op\u00e9ration jusqu'\u00e0 trouver le mot. \u00c0 chaque \u00e9tape vous \u00e9liminez la moiti\u00e9 restante des mots du dictionnaire. Si le dictionnaire contient 100'000 mots, vous aurez trouv\u00e9 le mot en\u2009:</p> \\[ \\log_2(100'000) = 16.6 \\] <p>\u00e9tapes. C'est bien plus rapide que de parcourir le dictionnaire de mani\u00e8re lin\u00e9aire, en tournant les pages une \u00e0 une.</p> <p>Prenons un algoritme qui prend un certain temps pour s'ex\u00e9cuter. L'algorithme \\(A\\) prend \\(f(n)\\) unit\u00e9s de temps pour une entr\u00e9e de taille \\(n\\). On peut dire que \\(A\\) est en \\(O(g(n))\\) si \\(f(n) \\leq c \\cdot g(n)\\) pour tout \\(n \\geq n_0\\), o\u00f9 \\(c\\) est une constante et \\(n_0\\) est un entier.</p> <p>Il existe diff\u00e9rents indicateurs de Landau\u2009:</p> Notation Big O (O) : <p>Utilis\u00e9e pour d\u00e9crire une borne sup\u00e9rieure asymptotique. Cela signifie qu'une fonction \\( f(n) \\) est en \\( O(g(n)) \\) s'il existe des constantes \\( c &gt; 0 \\) et \\( n_0 \\) telles que \\( f(n) \\leq c \\cdot g(n) \\) pour tout \\( n \\geq n_0 \\). En d'autres termes, \\( g(n) \\) est une limite sup\u00e9rieure sur le comportement de \\( f(n) \\) pour de grandes valeurs de \\( n \\).</p> <p>Big O est souvent utilis\u00e9e pour d\u00e9crire le pire cas.</p> Notation Big Omega (\u03a9) : <p>Utilis\u00e9e pour d\u00e9crire une borne inf\u00e9rieure asymptotique. Cela signifie qu'une fonction \\( f(n) \\) est en \\( \\Omega(g(n)) \\) s'il existe des constantes \\( c &gt; 0 \\) et \\( n_0 \\) telles que \\( f(n) \\geq c \\cdot g(n) \\) pour tout \\( n \\geq n_0 \\). En d'autres termes, \\( g(n) \\) est une limite inf\u00e9rieure sur le comportement de \\( f(n) \\) pour de grandes valeurs de \\( n \\).</p> <p>Big Omega est souvent utilis\u00e9e pour d\u00e9crire le meilleur cas.</p> Notation Big Theta (\u0398) : <p>Utilis\u00e9e pour d\u00e9crire une borne asymptotique stricte. Cela signifie qu'une fonction \\( f(n) \\) est en \\( \\Theta(g(n)) \\) s'il existe des constantes \\( c_1, c_2 &gt; 0 \\) et \\( n_0 \\) telles que \\( c_1 \\cdot g(n) \\leq f(n) \\leq c_2 \\cdot g(n) \\) pour tout \\( n \\geq n_0 \\). En d'autres termes, \\( g(n) \\) est une approximation asymptotique exacte de \\( f(n) \\).</p> <p>Big Theta est utilis\u00e9e pour d\u00e9crire un comportement asymptotique pr\u00e9cis, souvent interpr\u00e9t\u00e9 comme le cas moyen.</p> <p>Identifier les valeurs paires et impaires</p> <p>\u00c0 titre d'exemple, le programme suivant qui se charge de remplacer les valeurs paires d'un tableau par un \\(0\\) et les valeurs impaires par un \\(1\\) \u00e0 une complexit\u00e9 en temps de \\(O(n)\\) o\u00f9 <code>n</code> est le nombre d'\u00e9l\u00e9ments du tableau.</p> <pre><code>void discriminate(int* array, size_t length)\n{\n    for (size_t i = 0; i &lt; length; i++)\n    {\n        array[i] %= 2;\n    }\n}\n</code></pre> <p>Somme des entiers</p> <p>Si on vous demande d'\u00e9crire un algorithme permettant de conna\u00eetre la somme des entiers de \\(1\\) \u00e0 \\(n\\), vous pourriez \u00e9crire un algorithme en \\(O(n)\\) :</p> CPython <pre><code>int sum(int n) {\n    int sum = 0;\n    for (int i = 1; i &lt;= n; i++) {\n        sum += i;\n    }\n    return sum;\n}\n</code></pre> <pre><code>def sum(n):\n    return [i for i in range(1, n + 1)]\n</code></pre> <p>Ensuite vous vous posez la question de savoir si vous pouvez faire mieux. En effet, il existe une formule math\u00e9matique permettant de calculer la somme des entiers de \\(1\\) \u00e0 \\(n\\) :</p> \\[ \\sum_{i=1}^{n} i = \\frac{n \\cdot (n + 1)}{2} \\] <p>Cette formule est en \\(O(1)\\).</p> CPython <pre><code>int sum(int n) {\n    return n * (n + 1) / 2;\n}\n</code></pre> <pre><code>def sum(n):\n    return n * (n + 1) // 2\n</code></pre> <p>D'une mani\u00e8re g\u00e9n\u00e9rale, la plupart des algorithmes que l'ing\u00e9nieur \u00e9crira appartiendront \u00e0 ces cat\u00e9gories exprim\u00e9es du meilleur au plus mauvais\u2009:</p>  Temps pour diff\u00e9rentes complexit\u00e9s d'algorithmes Complexit\u00e9 \\(n = 100000\\) i7 (100'000 MIPS) \\(O(log(n))\\) 11 0.11 ns \\(O(n)\\) 100'000 1 us \\(O(n log(n))\\) 1'100'000 11 us \\(O(n^2)\\) 10'000'000'000 100 ms (un battement de cil) \\(O(2^n)\\) tr\u00e8s tr\u00e8s grand Le soleil devenu g\u00e9ante rouge aura ingurgit\u00e9 la terre $O(n\u2009!)` trop trop grand La galaxie ne sera plus que poussi\u00e8re <p>Les diff\u00e9rentes complexit\u00e9s peuvent \u00eatre r\u00e9sum\u00e9es sur la figure suivante\u2009:</p> <p> Diff\u00e9rentes complexit\u00e9s d'algorithmes</p> <p>Un algorithme en \\(O(n^2)\\), doit \u00e9veiller chez le d\u00e9veloppeur la volont\u00e9 de voir s'il n'y a pas moyen d'optimiser l'algorithme en r\u00e9duisant sa complexit\u00e9, souvent on s'aper\u00e7oit qu'un algorithme peut \u00eatre optimis\u00e9 et s'int\u00e9resser \u00e0 sa complexit\u00e9 est un excellent point d'entr\u00e9e.</p> <p>Attention toutefois \u00e0 ne pas mal \u00e9valuer la complexit\u00e9 d'un algorithme. Voyons par exemple les deux algorithmes suivants\u2009:</p> <pre><code>int min = MAX_INT;\nint max = MIN_INT;\n\nfor (size_t i = 0; i &lt; sizeof(array) / sizeof(array[0]); i++) {\n    if (array[i] &lt; min) {\n        min = array[i];\n    }\n    if (array[i] &gt; min) {\n        max = array[i];\n    }\n}\n</code></pre> <pre><code>int min = MAX_INT;\nint max = MIN_INT;\n\nfor (size_t i = 0; i &lt; sizeof(array) / sizeof(array[0]); i++)\n{\n    if (array[i] &lt; min) {\n        min = array[i];\n    }\n}\n\nfor (size_t i = 0; i &lt; sizeof(array) / sizeof(array[0]); i++)\n{\n    if (array[i] &gt; min) {\n        max = array[i];\n    }\n}\n</code></pre> <p>Exercise\u2009: Triangle \u00e9vanescent</p> <p>Quel serait l'algorithme permettant d'afficher\u2009:</p> <pre><code>*****\n****\n***\n**\n*\n</code></pre> <p>et dont la taille peut varier\u2009?</p> <p>Exercise\u2009: L'entier manquant</p> <p>On vous donne un gros fichier de 3'000'000'000 entiers positifs 32-bits, il vous faut g\u00e9n\u00e9rer un entier qui n'est pas dans la liste. Le hic, c'est que vous n'avez que 500 MiB de m\u00e9moire de travail. Quel algorithme proposez-vous\u2009?</p> <p>Une fois le travail termin\u00e9, votre manager vient vous voir pour vous annoncer que le cahier des charges a \u00e9t\u00e9 modifi\u00e9. Le client dit qu'il n'a que 10 MiB. Pensez-vous pouvoir r\u00e9soudre le probl\u00e8me quand m\u00eame\u2009?</p>"}, {"location": "course-c/40-algorithms/introduction/#machines-detats", "title": "Machines d'\u00e9tats", "text": ""}, {"location": "course-c/40-algorithms/introduction/#diagrammes-visuels", "title": "Diagrammes visuels", "text": "<ul> <li>Diagrammes en flux</li> <li>Structogrammes</li> <li>Diagramme d'activit\u00e9s</li> <li>Machines d'\u00e9tats (UML state machine)</li> <li>BPMN (Business Process Model and Notation)</li> </ul>"}, {"location": "course-c/40-algorithms/introduction/#type-dalgorithmes", "title": "Type d'algorithmes", "text": ""}, {"location": "course-c/40-algorithms/introduction/#algorithmes-en-ligne-incremental", "title": "Algorithmes en ligne (incr\u00e9mental)", "text": "<p>Un algorithme incr\u00e9mental ou online est un algorithme qui peut s'ex\u00e9cuter sur un flux de donn\u00e9es continu en entr\u00e9e. C'est-\u00e0-dire qu'il est en mesure de prendre des d\u00e9cisions sans avoir besoin d'une visibilit\u00e9 compl\u00e8te sur le set de donn\u00e9es.</p> <p>Un exemple typique est le probl\u00e8me de la secr\u00e9taire. On souhaite recruter une nouvelle secr\u00e9taire et le recruteur voit d\u00e9filer les candidats. Il doit d\u00e9cider \u00e0 chaque entretien s'il engage ou non le candidat et ne peut pas attendre la fin du processus d'entretiens pour obtenir le score attribu\u00e9 \u00e0 chaque candidat. Il ne peut comparer la performance de l'un qu'\u00e0 celle de deux d\u00e9j\u00e0 entrevus. L'objectif est de trouver la meilleure strat\u00e9gie.</p> <p>La solution \u00e0 ce probl\u00e8me est de laisser passer 37% des candidats sans les engager. Ceci correspond \u00e0 une proportion de \\(1/e\\). Ensuite il suffit d'attendre un ou une candidate meilleure que tous ceux/celles du premier \u00e9chantillon.</p>"}, {"location": "course-c/40-algorithms/introduction/#methodes-de-resolution", "title": "M\u00e9thodes de r\u00e9solution", "text": "<p>Il existe deux m\u00e9thodes quasiment infaillibles pour r\u00e9soudre un probl\u00e8me complexe\u2009:</p> <ol> <li>La r\u00e9duction du probl\u00e8me en sous-probl\u00e8mes plus simples.</li> <li>Le raisonnement par l'inverse.</li> </ol> <p>La r\u00e9diction aussi appel\u00e9e Divide and Conquer consiste \u00e0 diviser un probl\u00e8me en sous-probl\u00e8mes plus simples, les r\u00e9soudre et combiner les solutions pour obtenir la solution du probl\u00e8me initial. C'est une m\u00e9thode tr\u00e8s utilis\u00e9e en informatique pour r\u00e9soudre des probl\u00e8mes complexes. Par exemple, le tri fusion, le tri rapide, la recherche dichotomique sont des m\u00e9thodes de r\u00e9solution de probl\u00e8mes bas\u00e9es sur la r\u00e9duction.</p> <p>Le raisonnement par l'inverse consiste \u00e0 partir de la solution pour remonter au probl\u00e8me en posant des hypoth\u00e8ses. Par exemple, si vous avez un probl\u00e8me de recherche de chemin, vous pouvez partir de la destination pour remonter au point de d\u00e9part. C'est une m\u00e9thode tr\u00e8s utilis\u00e9e en math\u00e9matiques pour r\u00e9soudre des probl\u00e8mes complexes. Par exemple, la m\u00e9thode de Newton pour trouver les racines d'une fonction est bas\u00e9e sur le raisonnement par l'inverse.</p>"}, {"location": "course-c/40-algorithms/introduction/#exercices-de-revision", "title": "Exercices de r\u00e9vision", "text": "<p>Exercise\u2009: Int\u00e9grateur de Kahan</p> <p>L'int\u00e9grateur de Kahan (Kahan summation algorithm) est une solution \u00e9l\u00e9gante pour pallier \u00e0 la limite de r\u00e9solution des types de donn\u00e9es.</p> <p>L'algorithme pseudo-code peut \u00eatre exprim\u00e9 comme\u2009:</p> <pre><code>function kahan_sum(input)\n    var sum = 0.0\n    var c = 0.0\n    for i = 1 to input.length do\n        var y = input[i] - c\n        var t = sum + y\n        c = (t - sum) - y\n        sum = t\n    next i\n    return sum\n</code></pre> <ol> <li> <p>Impl\u00e9menter cet algorithme en C compte tenu du prototype\u2009:</p> <pre><code>float kahan_sum(float value, float sum, float c);\n</code></pre> </li> <li> <p>Expliquer comment fonctionne cet algorithme.</p> </li> <li>Donner un exemple montrant l'avantage de cet algorithme sur une simple somme.</li> </ol> <p>Exercise\u2009: Robot aspirateur affam\u00e9</p> <p>Un robot aspirateur souhaite se rassasier et cherche le frigo, le probl\u00e8me c'est qu'il ne sait pas o\u00f9 il est. Elle serait la strat\u00e9gie de recherche du robot pour se rendre \u00e0 la cuisine\u2009?</p> <p>Le robot dispose de plusieurs fonctionnalit\u00e9s\u2009:</p> <ul> <li>Avancer</li> <li>Tourner \u00e0 droite de 90\u00b0</li> <li>D\u00e9tection de sa position absolue p. ex. <code>P5</code></li> </ul> <p>\u00c9laborer un algorithme de recherche.</p> <pre><code>    \u2502 A \u2502 B \u2502 C \u2502 D \u2502 E \u2502 F \u2502 G \u2502 H \u2502 I \u2502 J \u2502 K \u2502 L \u2502 M \u2502 O \u2502 P \u2502 Q \u2502\n\u2500\u2500\u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n1 \u2503                     x \u2503       \u2503               \u2503               \u2503\n\u2500\u2500\u2503             F1: Frigo \u2503       \u2503               \u2503               \u2503\n2 \u2503       \u2503               \u2503       \u2503               \u2503               \u2503\n\u2500\u2500\u2503       \u2503               \u2503       \u2503               \u2503               \u2503\n3 \u2503       \u2503               \u2503       \u2503               \u2503               \u2503\n\u2500\u2500\u2503       \u2503               \u2503       \u2503               \u2503               \u2503\n4 \u2503       \u2503               \u2503       \u2503               \u2503               \u2503\n\u2500\u2500\u2503       \u2503               \u2503       \u2503               \u2503               \u2503\n5 \u2503       \u2503               \u2503       \u2503               \u2503      &lt;--o     \u2503\n\u2500\u2500\u2503       \u2523\u2501\u2501\u2501\u2501\u2501\u2501\u2501   \u2501\u2501\u2501\u2501\u2501\u252b       \u2503               \u2503     P5: Robot \u2503\n6 \u2503       \u2503               \u2503       \u2503               \u2503               \u2503\n\u2500\u2500\u2503       \u2503               \u2503       \u2503               \u2503               \u2503\n7 \u2503                       \u2503       \u2503               \u2503               \u2503\n\u2500\u2500\u2503                       \u2503       \u2503               \u2503               \u2503\n8 \u2503       \u2503               \u2503       \u2503               \u2503               \u2503\n\u2500\u2500\u2523\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253b\u2501\u2501\u2501\u2501\u2501\u2501\u2501    \u2501\u2501\u2501\u2501\u251b   \u2501\u2501\u2501\u2501\u251b   \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b   \u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u252b\n9 \u2503                                                       \u2503       \u2503\n\u2500\u2500\u2503                                                       \u2503       \u2503\n10\u2503                                                               \u2503\n\u2500\u2500\u2503                                                               \u2503\n11\u2503                                                       \u2503       \u2503\n\u2500\u2500\u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253b\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b\n</code></pre>"}, {"location": "course-c/40-algorithms/recursion/", "title": "R\u00e9cursivit\u00e9", "text": "<p>La r\u00e9cursivit\u00e9 est une technique de programmation dans laquelle une fonction s'appelle elle-m\u00eame pour r\u00e9soudre un probl\u00e8me. Cela signifie que la fonction r\u00e9sout une partie du probl\u00e8me et appelle ensuite la fonction elle-m\u00eame pour r\u00e9soudre le reste du probl\u00e8me.</p> <p>La r\u00e9cursivit\u00e9 est utilis\u00e9e pour r\u00e9soudre des probl\u00e8mes qui peuvent \u00eatre d\u00e9compos\u00e9s en probl\u00e8mes plus petits de la m\u00eame nature. Par exemple, la factorielle d'un nombre est le produit de tous les entiers positifs inf\u00e9rieurs ou \u00e9gaux \u00e0 ce nombre. La factorielle d'un nombre <code>n</code> est <code>n! = n * (n-1)!</code>.</p> <p>Au chapitre sur les fonctions, nous avions donn\u00e9 l'exemple du calcul de la somme de la suite de Fibonacci jusqu'\u00e0 <code>n</code> :</p> <pre><code>int fib(int n)\n{\n    int sum = 0;\n    int t1 = 0, t2 = 1;\n    int next_term;\n    for (int i = 1; i &lt;= n; i++)\n    {\n        sum += t1;\n        next_term = t1 + t2;\n        t1 = t2;\n        t2 = next_term;\n    }\n    return sum;\n}\n</code></pre> <p>Il peut sembler plus logique de raisonner de fa\u00e7on r\u00e9cursive. Quelle que soit l'it\u00e9ration \u00e0 laquelle l'on soit, l'assertion suivante est valable\u2009:</p> \\[fib(n) == fib(n - 1) + fib(n - 2)\\] <p>Donc pourquoi ne pas r\u00e9\u00e9crire cette fonction en employant ce caract\u00e8re r\u00e9cursif\u2009?</p> <pre><code>int fib(int n)\n{\n    if (n &lt; 2) return 1;\n    return fib(n - 1) + fib(n - 2);\n}\n</code></pre> <p>Le code est beaucoup plus simple \u00e0 \u00e9crire, et m\u00eame \u00e0 lire. N\u00e9anmoins cet algorithme est notoirement connu pour \u00eatre tr\u00e8s mauvais en termes de performance. Calculer <code>fib(5)</code> revient \u00e0 la cha\u00eene d'appel suivant.</p> <p>Cette cha\u00eene d'appel repr\u00e9sente le nombre de fois que <code>fib</code> est appel\u00e9 et \u00e0 quel niveau elle est appel\u00e9e. Par exemple <code>fib(4)</code> est appel\u00e9 dans <code>fib(5)</code> :</p> <pre><code>%% Arbre d'appel de Fibonacci\ngraph TD\n\n5((\"fib(5)\")) --&gt; 41((\"fib(4)\"))\n5 --&gt; 31((\"fib(3)\"))\n\n41((\"fib(4)\")) --&gt; 32((\"fib(3)\"))\n41 --&gt; 21((\"fib(2)\"))\n\n21 --&gt; 11((\"fib(1)\"))\n\n31 --&gt; 22((\"fib(2)\"))\n31 --&gt; 12((\"fib(1)\"))\n\n22 --&gt; 13((\"fib(1)\"))\n32((\"fib(3)\")) --&gt; 23((\"fib(2)\"))\n32 --&gt; 14((\"fib(1)\"))\n\n23 --&gt; 15((\"fib(1)\"))</code></pre> <p>Au final, <code>fib(1)</code> est appel\u00e9 5 fois, <code>fib(2)</code> 3 fois, <code>fib(3)</code> 2 fois, <code>fib(4)</code> et <code>fib(5)</code> 1 fois. Ce sont donc 12 appels \u00e0 la fonction <code>fib</code> pour calculer <code>fib(5)</code>.</p> Calcul Appels fib(1) 1 fib(2) 2 fib(3) 4 fib(4) 7 fib(5) 12 fib(6) 20 fib(7) 33 fib(8) 54 fib(9) 88 fib(10) 143 ... ... fib(30) 2'178'308 fib(40) 267'914'295 fib(50) 32'951'280'098 fib(100) 927'372'692'193'078'999'175 <p>Il s'agit de la suite A000071 de l'OEIS. On constate que le nombre d'appels est exponentiel. Pour <code>fib(100)</code> il faudra neuf cent vingt-sept quintillions trois cent soixante-douze quadrillions six cent quatre-vingt-douze trillions cent quatre-vingt-treize milliards soixante-dix-huit millions neuf cent quatre-vingt-dix-neuf mille cent soixante-quinze appels \u00e0 la fonction <code>fib</code>. Pour un processeur capable de calculer 100 GFLOPS (milliards d'op\u00e9rations par seconde), il faudra tout de m\u00eame 294 ans. C'est un peu long...</p> <p>La complexit\u00e9 algorithmique de cette fonction est dite \\(O(2^n)\\). C'est-\u00e0-dire que le nombre d'appels suit une relation exponentielle. La r\u00e9elle complexit\u00e9 est donn\u00e9e par la relation\u2009:</p> <p>En revanche, dans l'approche it\u00e9rative, on constate qu'une seule boucle <code>for</code>. C'est-\u00e0-dire qu'il faudra seulement 100 it\u00e9rations pour calculer la somme.</p> <p>G\u00e9n\u00e9ralement les algorithmes r\u00e9cursifs (s'appelant eux-m\u00eames) sont moins performants que les algorithmes it\u00e9ratifs (utilisant des boucles). N\u00e9anmoins il est parfois plus facile d'\u00e9crire un algorithme r\u00e9cursif.</p> <p>Notons que tout algorithme r\u00e9cursif peut \u00eatre \u00e9crit en un algorithme it\u00e9ratif, mais ce n'est pas toujours facile.</p>"}, {"location": "course-c/40-algorithms/recursion/#les-tours-de-hanoi", "title": "Les tours de Hano\u00ef", "text": "<p>Les tours de Hano\u00ef est un jeu de r\u00e9flexion invent\u00e9 par le math\u00e9maticien fran\u00e7ais \u00c9douard Lucas en 1889 et publi\u00e9 dans le tome 3 de ses R\u00e9cr\u00e9ations math\u00e9matiques. Le jeu est compos\u00e9 de trois tiges et d'un certain nombre de disques de diam\u00e8tres diff\u00e9rents qui peuvent \u00eatre empil\u00e9s sur une tige. Le but du jeu est de d\u00e9placer tous les disques d'une tige \u00e0 une autre, en respectant les r\u00e8gles suivantes\u2009:</p> <ol> <li>On ne peut d\u00e9placer qu'un seul disque \u00e0 la fois.</li> <li>Un disque ne peut \u00eatre plac\u00e9 que sur un disque plus grand que lui ou sur une tige vide.</li> </ol> <p> Tours de Hano\u00ef</p> <p>Ce probl\u00e8me se pr\u00eate tr\u00e8s bien \u00e0 une r\u00e9solution r\u00e9cursive. En effet, pour d\u00e9placer <code>n</code> disques de la tige <code>A</code> \u00e0 la tige <code>C</code>, il suffit de d\u00e9placer <code>n-1</code> disques de la tige <code>A</code> \u00e0 la tige <code>B</code>, puis de d\u00e9placer le disque restant de la tige <code>A</code> \u00e0 la tige <code>C</code>, et enfin de d\u00e9placer les <code>n-1</code> disques de la tige <code>B</code> \u00e0 la tige <code>C</code>.</p> Algorithme R\u00e9cursifAlgorithme It\u00e9ratif <pre><code>#include &lt;stdio.h&gt;\n\nvoid hanoi(int n, char from, char to, char aux) {\n    if (n == 1) {\n        printf(\"D\u00e9placer le disque 1 de %c \u00e0 %c\\n\", from, to);\n        return;\n    }\n    hanoi(n - 1, from, aux, to);\n    printf(\"D\u00e9placer le disque %d de %c \u00e0 %c\\n\", n, from, to);\n    hanoi(n - 1, aux, to, from);\n}\n\nint main() {\n    int n = 3;\n    hanoi(n, 'A', 'C', 'B');\n}\n</code></pre> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\ntypedef struct {\n    int n;\n    char from;\n    char to;\n    char aux;\n    int stage;\n} Frame;\n\ntypedef struct {\n    Frame *frames;\n    int top;\n    int max_size;\n} Stack;\n\nvoid init_stack(Stack *stack, int max_size) {\n    stack-&gt;frames = (Frame *)malloc(max_size * sizeof(Frame));\n    stack-&gt;top = -1;\n    stack-&gt;max_size = max_size;\n}\n\nvoid push(Stack *stack, Frame frame) {\n    if (stack-&gt;top &lt; stack-&gt;max_size - 1) {\n        stack-&gt;frames[++stack-&gt;top] = frame;\n    }\n}\n\nFrame pop(Stack *stack) {\n    if (stack-&gt;top &gt;= 0) {\n        return stack-&gt;frames[stack-&gt;top--];\n    } else {\n        Frame empty = {0, '\\0', '\\0', '\\0', 0};\n        return empty;\n    }\n}\n\nint is_empty(Stack *stack) {\n    return stack-&gt;top == -1;\n}\n\nvoid hanoi_iterative(int n, char from, char to, char aux) {\n    Stack stack;\n    init_stack(&amp;stack, 100);  // Assuming the stack size to be 100, adjust if needed\n\n    Frame initial_frame = {n, from, to, aux, 0};\n    push(&amp;stack, initial_frame);\n\n    while (!is_empty(&amp;stack)) {\n        Frame current_frame = pop(&amp;stack);\n\n        switch (current_frame.stage) {\n            case 0:\n                if (current_frame.n == 1) {\n                    printf(\"D\u00e9placer le disque 1 de %c \u00e0 %c\\n\", current_frame.from, current_frame.to);\n                } else {\n                    current_frame.stage = 1;\n                    push(&amp;stack, current_frame);\n\n                    Frame new_frame = {current_frame.n - 1, current_frame.from, current_frame.aux, current_frame.to, 0};\n                    push(&amp;stack, new_frame);\n                }\n                break;\n\n            case 1:\n                printf(\"D\u00e9placer le disque %d de %c \u00e0 %c\\n\", current_frame.n, current_frame.from, current_frame.to);\n\n                current_frame.stage = 2;\n                push(&amp;stack, current_frame);\n\n                Frame new_frame = {current_frame.n - 1, current_frame.aux, current_frame.to, current_frame.from, 0};\n                push(&amp;stack, new_frame);\n                break;\n        }\n    }\n    free(stack.frames);\n}\n\nint main() {\n    int n = 3;\n    hanoi_iterative(n, 'A', 'C', 'B');\n}\n</code></pre> <p>Ce qui donne le r\u00e9sultat suivant\u2009:</p> <pre><code>D\u00e9placer le disque 1 de A \u00e0 C\nD\u00e9placer le disque 2 de A \u00e0 B\nD\u00e9placer le disque 1 de C \u00e0 B\nD\u00e9placer le disque 3 de A \u00e0 C\nD\u00e9placer le disque 1 de B \u00e0 A\nD\u00e9placer le disque 2 de B \u00e0 C\nD\u00e9placer le disque 1 de A \u00e0 C\n</code></pre> <p>On voit que l'impl\u00e9mentation it\u00e9rative est bien plus complexe que l'impl\u00e9mentation r\u00e9cursive. C'est pourquoi il est souvent plus simple d'\u00e9crire un algorithme r\u00e9cursif, mais pas n\u00e9cessairement plus performant.</p>"}, {"location": "course-c/40-algorithms/recursion/#utilisation-du-stack", "title": "Utilisation du stack", "text": "<p>En C, la r\u00e9cursivit\u00e9 est g\u00e9r\u00e9e par le stack. Chaque appel de fonction est empil\u00e9 sur le stack. Lorsque la fonction retourne, elle est d\u00e9pil\u00e9e du stack. Il est important de noter que le stack a une taille limit\u00e9e. Par d\u00e9faut, sous Linux la taille du stack est de 8 Mio (donn\u00e9 par la commande <code>ulimit -s</code>), sous Windows c'est 1 Mio. Si la r\u00e9cursivit\u00e9 est trop profonde, il y a un risque de stack overflow.</p> <p>D'autre part, une fonction r\u00e9cursive qui utilise beaucoup de variables locales et beaucoup de param\u00e8tres seront tous empil\u00e9s sur le stack. Cela peut rapidement saturer la m\u00e9moire.</p> <p>Prenons l'exemple suivant d'une fonction r\u00e9cursive qui d\u00e9clare un tableau de 1Mio de caract\u00e8res\u2009:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint recurse(int n, int stack_size)\n{\n    char array[1024*1024] = {0};\n    printf(\"used stack: %d kiB\\n\", stack_size / 1024);\n    if (n == 0) return 0;\n    return recurse(n - 1, stack_size + sizeof(array));\n}\n\nint main(int argc, char* argv[])\n{\n    recurse(atoi(argv[1]), 0);\n}\n</code></pre> <p>\u00c0 l'ex\u00e9cution, on obtient\u2009:</p> <pre><code>used stack: 0 kiB\nused stack: 1024 kiB\nused stack: 2048 kiB\nused stack: 3072 kiB\nused stack: 4096 kiB\nused stack: 5120 kiB\nused stack: 6144 kiB\nSegmentation fault (stack overflow)\n</code></pre> <p>Avertissement</p> <p>Avant d'impl\u00e9menter une fonction r\u00e9cursive, il est important de v\u00e9rifier que la profondeur de la r\u00e9cursivit\u00e9 ne d\u00e9passe pas la taille du stack.</p> <p>Limitez l'utilisation du stack en utilisant soit des variables globales, soit des variables statiques, soit des allocations dynamiques.</p>"}, {"location": "course-c/40-algorithms/recursion/#memoisation", "title": "M\u00e9mo\u00efsation", "text": "<p>En informatique la m\u00e9mo\u00efsation est une technique d'optimisation du code souvent utilis\u00e9e conjointement avec des algorithmes r\u00e9cursifs. Cette technique est largement utilis\u00e9e en programmation dynamique.</p> <p>Nous l'avons vu pr\u00e9c\u00e9demment, l'algorithme r\u00e9cursif du calcul de la somme de la suite de Fibonacci n'est pas efficace du fait que les m\u00eames appels sont r\u00e9p\u00e9t\u00e9s un nombre inutile de fois. La parade est de m\u00e9moriser pour chaque appel de <code>fib</code>, la sortie correspondante \u00e0 l'entr\u00e9e.</p> <p>Dans cet exemple nous utiliserons un m\u00e9canisme compos\u00e9 de trois fonctions\u2009:</p> <ul> <li><code>int memoize(Cache *cache, int input, int output)</code></li> <li><code>bool memoize_has(Cache *cache, int input)</code></li> <li><code>int memoize_get(Cache *cache, int input)</code></li> </ul> <p>La premi\u00e8re fonction m\u00e9morise la valeur de sortie <code>output</code> li\u00e9e \u00e0 la valeur d'entr\u00e9e <code>input</code>. Pour des raisons de simplicit\u00e9 d'utilisation, la fonction retourne la valeur de sortie <code>output</code>.</p> <p>La seconde fonction <code>memoize_has</code> v\u00e9rifie si une valeur de correspondance existe pour l'entr\u00e9e <code>input</code>. Elle retourne <code>true</code> en cas de correspondance et <code>false</code> sinon.</p> <p>La troisi\u00e8me fonction <code>memoize_get</code> retourne la valeur de sortie correspondante \u00e0 la valeur d'entr\u00e9e <code>input</code>.</p> <p>Notre fonction r\u00e9cursive sera ainsi modifi\u00e9e comme suit\u2009:</p> <pre><code>int fib(int n)\n{\n    if (memoize_has(n)) return memoize_get(n);\n    if (n &lt; 2) return 1;\n    return memoize(n, fib(n - 1) + fib(n - 2));\n}\n</code></pre> <p>Quant aux trois fonctions utilitaires, voici une proposition d'impl\u00e9mentation. Notons que cette impl\u00e9mentation est tr\u00e8s \u00e9l\u00e9mentaire et n'est valable que pour des entr\u00e9es inf\u00e9rieures \u00e0 1000. Il sera possible ult\u00e9rieurement de perfectionner ces fonctions, mais nous aurons pour cela besoin de concepts qui n'ont pas encore \u00e9t\u00e9 abord\u00e9s, tels que les structures de donn\u00e9es complexes.</p> <pre><code>#define SIZE 1000\n\nbool cache_input[SIZE] = { false };\nint cache_output[SIZE];\n\nint memoize(int input, int output) {\n    cache_input[input % SIZE] = true;\n    cache_output[input % SIZE] = output;\n    return output;\n}\n\nbool memoize_has(int input) {\n    return cache_input[input % SIZE];\n}\n\nint memoize_get(int input) {\n    return cache_output[input % SIZE];\n}\n</code></pre> <p>Exercise\u2009: La plus petite diff\u00e9rence</p> <p>Soit deux tableaux d'entiers, trouver la paire de valeurs (une dans chaque tableau) ayant la plus petite diff\u00e9rence (positive).</p> <p>Exemple\u2009:</p> <pre><code>int a[] = {5, 3, 14, 11, 2};\nint b[] = {24, 128, 236, 20, 8};\n\nint diff = 3 // pair 11, 8\n</code></pre> <ol> <li>Proposer une impl\u00e9mentation</li> <li>Quelle est la complexit\u00e9 de votre algorithme\u2009?</li> </ol>"}, {"location": "course-c/40-algorithms/recursion/#programmation-dynamique", "title": "Programmation dynamique", "text": "<p>La programmation dynamique est une m\u00e9thode algorithmique datant des ann\u00e9es 1950, mais devenue populaire ces derni\u00e8res ann\u00e9es. Elle permet de coupler des algorithmes r\u00e9cursifs avec le concept de m\u00e9mo\u00efsation.</p> <p>Prenons par exemple l'algorithme de Fibonacci r\u00e9cursif\u2009:</p> <pre><code>int fibonacci(int n) {\n    if (n &lt;= 1) return n;\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n</code></pre> <p>Le probl\u00e8me de cet algorithme est sa performance. Appeler <code>fibonacci(50)</code> demandera de calculer <code>fibonacci(49)</code> et <code>fibonacci(48)</code> mais pour calculer <code>fibonacci(49)</code> il faudra recalculer <code>fibonacci(48)</code>. On voit qu'on effectue du travail \u00e0 double. En r\u00e9alit\u00e9 c'est bien pire que \u00e7a. La complexit\u00e9 est de \\(O(2^n)\\). Donc pour calculer la valeur <code>50</code> il faudra effectuer \\(1 125 899 906 842 624\\) op\u00e9rations. Avec un ordinateur capable de calculer 1 milliard d'op\u00e9rations par seconde, il faudra tout de m\u00eame plus d'un million de secondes. Cet algorithme est donc tr\u00e8s mauvais\u2009!</p> <p>En revanche, si l'on est capable de m\u00e9moriser dans une table les r\u00e9sultats pr\u00e9c\u00e9dents des appels de Fibonacci, les performances seront bien meilleures.</p> <p>Voici l'algorithme modifi\u00e9\u2009:</p> <pre><code>int fibonacci(int n) {\n    static int memo[1000] = {0};\n    if (memo[n]) return memo[n];\n    if (n &lt;= 1) return n;\n    return memo[n] = fibonacci(n - 1) + fibonacci(n - 2);\n}\n</code></pre> <p>Sa complexit\u00e9 est ainsi r\u00e9duite \u00e0 \\(O(2\\cdot n)\\) et donc \\(O(n)\\). En revanche, l'approche dynamique demande un espace m\u00e9moire suppl\u00e9mentaire. On n'a rien sans rien et l'\u00e9ternel dilemme m\u00e9moire versus performance s'applique toujours.</p>"}, {"location": "course-c/40-algorithms/utilities/", "title": "Algorithmes utilitaires", "text": ""}, {"location": "course-c/40-algorithms/utilities/#slurp", "title": "Slurp", "text": "<p>Souvent on a besoin de lire l'entr\u00e9e standard en entier dans une cha\u00eene de caract\u00e8re. Il faut convertir le flux d'entr\u00e9e en une cha\u00eene de caract\u00e8re. Cependant, comme l'entr\u00e9e standard n'est pas seekable, il faut lire le flux caract\u00e8re par caract\u00e8re. Une impl\u00e9mentation possible se repose sur le concept des tableaux dynamiques.</p> slurp.h<pre><code>#pragma once\n\n#include &lt;stdio.h&gt;\nchar *slurp(FILE *file);\n</code></pre> slurp.c<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nchar *slurp(FILE *file) {\n    size_t size = 256;\n    size_t len = 0;\n    char *input = (char *)malloc(size);\n\n    if (input == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(1);\n    }\n\n    while (!feof(stdin)) {\n        if (len + 128 &gt;= size) {\n            size *= 2;\n            input = (char *)realloc(input, size);\n            if (input == NULL) {\n                fprintf(stderr, \"Memory reallocation failed\\n\");\n                exit(1);\n            }\n        }\n        len += fread(input + len, 1, size - len - 1, stdin);\n    }\n    input[len] = '\\0';\n    return input;\n}\n</code></pre>"}, {"location": "course-c/40-algorithms/utilities/#split", "title": "Split", "text": ""}, {"location": "course-c/40-algorithms/utilities/#join", "title": "Join", "text": ""}, {"location": "course-c/40-algorithms/utilities/#trim", "title": "Trim", "text": ""}, {"location": "course-c/40-algorithms/utilities/#reverse", "title": "Reverse", "text": ""}, {"location": "course-c/40-algorithms/utilities/#gestion-des-arguments", "title": "Gestion des arguments", "text": ""}, {"location": "course-c/40-algorithms/popular-algorithms/fast-exp/", "title": "Exponentiation rapide", "text": "<p>Cet algorithme permet de calculer rapidement des puissances enti\u00e8res (\\(a^n\\)). La m\u00e9thode na\u00efve consiste \u00e0 calculer les puissances avec une boucle\u2009:</p> <pre><code>long long pow(long long a, long long n) {\n    for (int i = 0; i &lt; n - 1; i++) {\n        a *= a;\n    }\n}\n</code></pre> <p>La complexit\u00e9 de cet algorithme est \\(O(n)\\). Il est possible de faire mieux en \\(O(n log n)\\).</p> <pre><code>long long bin_pow(long long a, long long b) {\n    if (b == 0) return 1;\n    long long res = bin_pow(a, b / 2);\n    return res * res * (b % 2 ? a : 1);\n}\n</code></pre> <p>Comme \u00e9voqu\u00e9 plus haut, un algorithme r\u00e9cursif est souvent moins performant que sa variante it\u00e9rative. Voici l'impl\u00e9mentation it\u00e9rative\u2009:</p> <pre><code>long long bin_pow(long long a, long long b) {\n    long long res = 1;\n    while (b &gt; 0) {\n        if (b &amp; 1) res = res * a;\n        a *= a;\n        b /= 2;\n    }\n    return res;\n}\n</code></pre>"}, {"location": "course-c/40-algorithms/popular-algorithms/fast-inverse-square-root/", "title": "Racine carr\u00e9e inverse rapide", "text": "<p> Quake III Arena</p> <p>Cet algorithme a \u00e9t\u00e9 d\u00e9velopp\u00e9 chez Silicon Graphics au d\u00e9but des ann\u00e9es 90. Il a \u00e9t\u00e9 utilis\u00e9 dans des jeux vid\u00e9os comme Quake III Arena pour am\u00e9liorer la performance du calcul des angles d'incidence dans la r\u00e9flexion des lumi\u00e8res et est attribu\u00e9 \u00e0 John Carmack, un des fondateurs de id Software, qui a publi\u00e9 le code source de Quake III Arena en 2005.</p> <p>Il est utilis\u00e9 pour les vecteurs normaux dans les calculs de r\u00e9flexion de la lumi\u00e8re.</p> <p> R\u00e9flexion de la lumi\u00e8re</p> <pre><code>float Q_rsqrt(float number)\n{\n    const float threehalfs = 1.5F;\n\n    float x2 = number * 0.5F;\n    float y = number;\n    long i = *(long *) &amp;y; // Evil floating point bit level hacking\n    i = 0x5f3759df - (i &gt;&gt; 1); // What the fuck?\n    y = *(float *) &amp;i;\n    y = y * (threehalfs - (x2 * y * y)); // 1st iteration\n#if BETTER\n    y = y * (threehalfs - (x2 * y * y)); // 2nd iteration\n#endif\n    return y;\n}\n</code></pre> <p>Cet algorithme de racine carr\u00e9e inverse rapide utilise une constante magique <code>0x5f3759df</code>. L'impl\u00e9mentation propos\u00e9e ci-dessus est extraite du code source du jeu Quake III arena (q_math.c) disponible sur GitHub.</p> <p>Ce n'est pas un algorithme tr\u00e8s acad\u00e9mique, il s'agit d'un kludge, une solution irrespectueuse des r\u00e8gles de l'art de la programmation, car la valeur <code>y</code> est transtyp\u00e9e en un <code>long</code> (<code>i = *(long *)&amp;y</code>. C'est cette astuce qui permet de tirer avantage que les valeurs en virgule flottantes sont exprim\u00e9es en puissances de 2.</p>"}, {"location": "course-c/40-algorithms/popular-algorithms/fast-sin/", "title": "Fast sin", "text": ""}, {"location": "course-c/40-algorithms/popular-algorithms/fast-sin/#sinus-rapide", "title": "Sinus rapide", "text": "<p>Avec des architectures qui ne supportent pas les nombres r\u00e9els, il est possible de calculer une bonne approximation du sinus en utilisant une approximation avec une s\u00e9rie de Taylor. Les calculs sont effecut\u00e9s en virgule fixe. Voici un exemple d'impl\u00e9mentation\u2009:</p> <pre><code>/**\n* A 5-order polynomial approximation to sin(x).\n* @param i   angle (with 2^15 units/circle)\n* @return    16 bit fixed point Sine value (4.12) (ie: +4096 = +1 &amp; -4096 = -1)\n*\n* The result is accurate to within +- 1 count. ie: +/-2.44e-4.\n*/\nint16_t fpsin(int16_t i)\n{\n    // Convert (signed) input to a value between 0 and 8192.\n    // (8192 is pi/2, which is the region of the curve fit).\n    i &lt;&lt;= 1;\n    uint8_t c = i&lt;0; // set carry for output pos/neg\n\n    if(i == (i|0x4000)) // flip input value to corresponding value in range [0..8192)\n        i = (1&lt;&lt;15) - i;\n    i = (i &amp; 0x7FFF) &gt;&gt; 1;\n\n    /**\n        * The following section implements the formula:\n        *  = y * 2^-n * ( A1 - 2^(q-p)* y * 2^-n * y * 2^-n *\n        *  [B1 - 2^-r * y * 2^-n * C1 * y]) * 2^(a-q)\n        * Where the constants are defined as follows:\n        */\n    enum {A1=3370945099UL, B1=2746362156UL, C1=292421UL};\n    enum {n=13, p=32, q=31, r=3, a=12};\n\n    uint32_t y = (C1*((uint32_t)i))&gt;&gt;n;\n    y = B1 - (((uint32_t)i*y)&gt;&gt;r);\n    y = (uint32_t)i * (y&gt;&gt;n);\n    y = (uint32_t)i * (y&gt;&gt;n);\n    y = A1 - (y&gt;&gt;(p-q));\n    y = (uint32_t)i * (y&gt;&gt;n);\n    y = (y+(1UL&lt;&lt;(q-a-1)))&gt;&gt;(q-a); // Rounding\n\n    return c ? -y : y;\n}\n</code></pre> <p>Source\u2009: 5<sup>th</sup> Order Polynomial Fixed-Point Sine Approximation</p>"}, {"location": "course-c/40-algorithms/popular-algorithms/huffman/", "title": "Codage de Huffman", "text": "<p>Le codage de Huffman est un algorithme de compression sans perte qui permet de r\u00e9duire la taille des fichiers en utilisant des codes de longueur variable pour repr\u00e9senter les caract\u00e8res. L'algorithme repose sur l'id\u00e9e que les caract\u00e8res les plus fr\u00e9quents dans un texte peuvent \u00eatre repr\u00e9sent\u00e9s par des codes plus courts, tandis que les caract\u00e8res les moins fr\u00e9quents sont repr\u00e9sent\u00e9s par des codes plus longs.</p> <p>Il est utilis\u00e9 dans de nombreux formats de fichiers comme le format PNG, JPEG et MP3.</p> <p>Prenons le texte <code>ABRACADABRA</code>. Il y a des lettres qui reviennent plus souvent que d'autres et des lettres de l'alphabet qui sont absentes. Pourquoi donc repr\u00e9senter chaque caract\u00e8re sur 1 octet\u2009? On pourrait utiliser un code de longueur variable. Par exemple, la lettre <code>A</code> pourrait \u00eatre repr\u00e9sent\u00e9e par <code>0</code>, la lettre <code>B</code> par <code>10</code> et la lettre <code>R</code> par <code>11</code>. Il faudrait \u00e9galement d\u00e9finir une table de correspondance pour d\u00e9coder le texte. C'est le principe de l'abre de Huffman.</p>"}, {"location": "course-c/40-algorithms/popular-algorithms/huffman/#comment-ca-marche", "title": "Comment \u00e7a marche\u2009?", "text": "<p>Pour notre entr\u00e9e <code>ABRACADABRA</code>, nous allons suivre les \u00e9tapes suivantes\u2009:</p>"}, {"location": "course-c/40-algorithms/popular-algorithms/huffman/#nombre-doccurences", "title": "Nombre d'occurences", "text": "<p>On commence par compter la fr\u00e9quence de chaque caract\u00e8re. On obtient\u2009:</p>  Fr\u00e9quence de Huffman Caract\u00e8re Fr\u00e9quence A 5 B 2 R 2 C 1 D 1 <p>Chaque \u00e9l\u00e9ment est un noeuf qui est plac\u00e9 dans une file de priorit\u00e9 (min-heap) o\u00f9 la priorit\u00e9 est la fr\u00e9quence du caract\u00e8re. Voici le pseudo code du tas minimum\u2009:</p> <pre><code>Min-Heap : [(1, 'C'), (1, 'D'), (2, 'B'), (2, 'R'), (5, 'A')]\n</code></pre>"}, {"location": "course-c/40-algorithms/popular-algorithms/huffman/#fusion", "title": "Fusion", "text": "<p>On va fusionner les deux noeuds de plus faible fr\u00e9quence, c'est facile parce qu'un min-heap nous permet de r\u00e9cup\u00e9rer les deux \u00e9l\u00e9ments de plus faible fr\u00e9quence en temps constant. Apr\u00e8s fusion, on obtient une cha\u00eene de caract\u00e8re qui repr\u00e9sente les deux noeuds fusionn\u00e9s. On ajoute ce nouveau noeud \u00e0 la file de priorit\u00e9 en prenant en compte la fr\u00e9quence totale des deux noeuds fusionn\u00e9s.</p> <p>Notons que qu'en cas de priorit\u00e9 \u00e9gale, on peut choisir arbitrairement l'ordre des noeuds.</p> <p>Les noeuds <code>C</code> et <code>D</code> sont les deux noeuds de plus faible fr\u00e9quence. On les fusionne pour obtenir <code>CD</code> qui a une priorit\u00e9 de <code>2</code>.</p> <pre><code>Min-Heap : [(2, 'CD'), (2, 'B'), (2, 'R'), (5, 'A')]\n</code></pre> <pre><code>graph TD\nCD(\"CD (2)\") --&gt; C(\"C (1)\")\nCD --&gt; D(\"D (1)\")</code></pre> <p>Il nous reste des noeuuds \u00e0 fusionner. On fusionne les noeuds <code>CD</code> et <code>B</code> pour obtenir <code>CDB</code> qui a une priorit\u00e9 de <code>4</code>.</p> <pre><code>Min-Heap : [(2, 'R'), (4, 'CDB'), (5, 'A')]\n</code></pre> <pre><code>graph TD\n    CDB(\"CDB (4)\") --&gt; CD(\"CD (2)\")\n    CDB --&gt; B(\"B (2)\")\n    CD --&gt; C(\"C (1)\")\n    CD --&gt; D(\"D (1)\")</code></pre> <p>On continue car il nous reste des noeuds \u00e0 fusionner. On fusionne les noeuds <code>CDB</code> et <code>R</code> pour obtenir <code>CDBR</code> qui a une priorit\u00e9 de <code>6</code>.</p> <pre><code>Min-Heap : [(5, 'A'), (6, 'RCDB')]\n</code></pre> <pre><code>graph TD\n    RCDB(\"RCDB (6)\") --&gt; R(\"R (2)\")\n    RCDB --&gt; CDB(\"CDB (4)\")\n    CDB --&gt; CD(\"CD (2)\")\n    CDB --&gt; B(\"B (2)\")\n    CD --&gt; C(\"C (1)\")\n    CD --&gt; D(\"D (1)\")</code></pre> <p>Enfin, on fusionne les noeuds <code>RCDB</code> et <code>A</code> pour obtenir <code>ACDBR</code> qui a une priorit\u00e9 de <code>11</code>.</p> <pre><code>Min-Heap : [(11, 'ARCDB')]\n</code></pre> <pre><code>graph TD\n    ARCDB(\"ARCDB (11)\") --&gt; A(\"A (5)\")\n    ARCDB --&gt; RCDB(\"RCDB (6)\")\n    RCDB --&gt; R(\"R (2)\")\n    RCDB --&gt; CDB(\"CDB (4)\")\n    CDB --&gt; CD(\"CD (2)\")\n    CDB --&gt; B(\"B (2)\")\n    CD --&gt; C(\"C (1)\")\n    CD --&gt; D(\"D (1)\")</code></pre>"}, {"location": "course-c/40-algorithms/popular-algorithms/huffman/#generation-des-codes", "title": "G\u00e9n\u00e9ration des codes", "text": "<p>Pour g\u00e9n\u00e9rer les codes, on parcourt l'arbre de Huffman en partant de la racine. On ajoute un <code>0</code> \u00e0 chaque fois qu'on descend \u00e0 gauche et un <code>1</code> \u00e0 chaque fois qu'on descend \u00e0 droite. Les noeuds fusionn\u00e9s sont des noeuds internes, on ne les prend pas en compte.</p> Caract\u00e8re Code A 0 R 10 B 111 C 1100 D 1101"}, {"location": "course-c/40-algorithms/popular-algorithms/huffman/#encodage-du-texte", "title": "Encodage du texte", "text": "<p>Une fois les codes g\u00e9n\u00e9r\u00e9s, on peut encoder le texte en rempla\u00e7ant chaque caract\u00e8re par son code.</p> <pre><code>A B   R  A C    A C    A B   R  A\n0 111 10 0 1100 0 1100 0 111 10 0\n</code></pre> <p>Comme les donn\u00e9es sont n\u00e9cessairement align\u00e9es sur des octets en m\u00e9moire, il est possible que le dernier octet contienne des bits inutilis\u00e9s, on les remplace par des z\u00e9ros.</p> <pre><code>01111001'10001100'01111000\n                         - Remplissage (padding)\n</code></pre> <p>Bien entendu il est n\u00e9cessaire d'encoder \u00e9galement la table de Huffmann pour pouvoir d\u00e9coder le texte. Une m\u00e9thode courante est d'encoder directement la table de Huffmann dans le fichier compress\u00e9.</p>"}, {"location": "course-c/40-algorithms/popular-algorithms/rabin-karp/", "title": "Algorithme de Rabin-Karp", "text": "<p>Cet algorithme Rabin-Karp permet la recherche d'une sous-cha\u00eene de caract\u00e8re dans une cha\u00eene plus grande. Sa complexit\u00e9 moyenne est \\(O(n + m)\\).</p> <p>L'algorithme se base sur le principe de la fonction de hachage. Il consiste \u00e0 calculer le hash de la cha\u00eene \u00e0 rechercher et de la cha\u00eene dans laquelle on recherche. Si les deux hash sont \u00e9gales, on compare les deux cha\u00eenes caract\u00e8re par caract\u00e8re.</p> <p>L'algorithme fait glisser une fen\u00eatre de la taille de la cha\u00eene \u00e0 rechercher sur la cha\u00eene dans laquelle on recherche. \u00c0 chaque it\u00e9ration, on calcule le hash de la fen\u00eatre et on le compare au hash de la cha\u00eene \u00e0 rechercher. Si les deux hash sont \u00e9gaux, on compare les deux cha\u00eenes caract\u00e8re par caract\u00e8re.</p> <p>La performance de l'algorithme d\u00e9pend de la fonction de hachage. Si la fonction de hachage est bien choisie, l'algorithme est tr\u00e8s performant. Si la fonction de hachage est mal choisie, l'algorithme peut \u00eatre lent.</p> <p>Ici la fonction de hachage est tr\u00e8s simple, on utilise un nombre premier.</p> rabin-karp.c<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n#include &lt;assert.h&gt;\n\n#define CHARS_IN_ALPHABET 256\n\n/**\n * Rabin-Karp algorithm\n * @param needle Motif \u00e0 rechercher\n * @param haystack Texte d'entr\u00e9e\n * @param matches La liste des occurences trouv\u00e9es\n * @param size La taille du tableau matches\n * @return Le nombre d'occurences trouv\u00e9es\n */\nint search(char needle[], char haystack[], int matches[], size_t size)\n{\n    const int q = 101; // A prime number\n    const int M = strlen(needle);\n    const int N = strlen(haystack);\n\n    int h = 1;\n    for (int i = 0; i &lt; M - 1; i++)\n        h = (h * CHARS_IN_ALPHABET) % q;\n\n    // Compute the hash value of pattern and first\n    // window of text\n    int p = 0; // Hash value for pattern\n    int t = 0; // Hash value for haystack\n    for (int i = 0; i &lt; M; i++) {\n        p = (CHARS_IN_ALPHABET * p + needle[i]) % q;\n        t = (CHARS_IN_ALPHABET * t + haystack[i]) % q;\n    }\n\n    // Slide the pattern over text one by one\n    size_t k = 0;\n    for (int i = 0; i &lt;= N - M; i++) {\n        // Check the hash values of current window of text\n        // and pattern. If the hash values match then only\n        // check for characters on by one\n        if (p == t) {\n            // Check for characters one by one\n            int j = 0;\n            while (haystack[i + j] == needle[j] &amp;&amp; j &lt; M)\n                j++;\n\n            // Save the position found\n            if (j == M)\n                if (k &lt; size)\n                    matches[k++] = i;\n                else\n                    return k;\n        }\n\n        // Calculate hash value for next window of text.\n        // Remove leading digit and add trailing digit.\n        if (i &lt; (N - M)) {\n            t = (CHARS_IN_ALPHABET *\n                (t - haystack[i] * h) + haystack[i + M]) % q;\n            t += t &lt; 0 ? q : 0;\n        }\n    }\n    return k;\n}\n\nint test_search()\n{\n    char text[] =\n        \"Le courage n'est pas l'absence de peur, \"\n        \"mais la capacit\u00e9 de vaincre ce qui fait peur.\"\n        \"On ne peut vaincre sa destin\u00e9e.\"\n        \"A vaincre sans barils, on triomphe sans boire.\";\n\n    int matches[10];\n    int k = search(\"vaincre\", text, matches, sizeof(matches)/sizeof(matches[0]));\n    assert(k == 3);\n    assert(matches[0] == 61);\n    assert(matches[1] == 97);\n    assert(matches[2] == 120);\n}\n\nint main() {\n    test_search();\n}\n</code></pre>"}, {"location": "course-c/40-algorithms/popular-algorithms/random/", "title": "G\u00e9n\u00e9rateur congruentiel lin\u00e9aire", "text": "<p>Le g\u00e9n\u00e9rateur congruentiel lin\u00e9aire (GCL) est un algorithme simple pour g\u00e9n\u00e9rer des nombres pseudo-al\u00e9atoires. Il est d\u00e9fini par la relation de r\u00e9currence suivante\u2009:</p> \\[ X_{n+1} = (a \\cdot X_n + c) \\mod m \\] <p>O\u00f9\u2009:</p> \\(X_n\\) <p>est la s\u00e9quence de nombres pseudo-al\u00e9atoires</p> \\(a\\) <p>est le multiplicateur</p> \\(c\\) <p>est l'incr\u00e9ment</p> \\(m\\) <p>est le modulo</p> <p>Les informaticiens ont remarqu\u00e9 que ce g\u00e9n\u00e9rateur fonctionne bien pour certaines valeurs de \\(a\\), \\(c\\) et \\(m\\). Par exemple, si \\(m = 2^k\\), le g\u00e9n\u00e9rateur est dit \u00e0 \u00ab\u2009congruence binaire\u2009\u00bb. Si \\(c = 0\\), le g\u00e9n\u00e9rateur est dit \u00ab\u2009multiplicatif\u2009\u00bb.</p> <p>En C c'est un g\u00e9n\u00e9rateur congruentiel lin\u00e9aire qui est utilis\u00e9 pour la fonction <code>rand()</code>. Voici une impl\u00e9mentation de ce g\u00e9n\u00e9rateur\u2009:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nstatic uint32_t seed = 0;\n\nvoid srand(uint32_t s) {\n    seed = s;\n}\n\nuint32_t rand() {\n    const uint32_t a = 1103515245;\n    const uint32_t c = 12345;\n    const uint32_t m = 1ULL &lt;&lt; 31;\n    seed = (a * seed + c) % m;\n    return seed;\n}\n</code></pre> <p>La valeur statique <code>seed</code> permet de conserver l'\u00e9tat du g\u00e9n\u00e9rateur entre les appels \u00e0 la fonction <code>rand()</code>. Si elle n'est pas initialis\u00e9e, le g\u00e9n\u00e9rateur retournera toujours la m\u00eame s\u00e9quence de nombres pseudo-al\u00e9atoires. La fonction <code>srand()</code> permet donc d'initialiser la graine du g\u00e9n\u00e9rateur.</p> <p>En pratique, on utilise <code>srand()</code> avec comme valeur d'initialisation le temps courant en secondes pour obtenir une s\u00e9quence de nombres pseudo-al\u00e9atoires diff\u00e9rente \u00e0 chaque ex\u00e9cution du programme\u2009:</p> <pre><code>#include &lt;time.h&gt;\n\nint main() {\n    srand(time(NULL));\n    for (int i = 0; i &lt; 10; ++i) {\n        printf(\"%d\\n\", rand());\n    }\n}\n</code></pre> <p>N\u00e9anmoins si vous rappelez votre programme durant la m\u00eame seconde, vous obtiendrez la m\u00eame s\u00e9quence de nombres pseudo-al\u00e9atoires. Pour obtenir une s\u00e9quence diff\u00e9rente \u00e0 chaque ex\u00e9cution, vous pouvez utiliser inclure le PID du processus\u2009:</p> <pre><code>#include &lt;unistd.h&gt;\n#include &lt;time.h&gt;\n\nint main() {\n    srand(time(NULL) ^ getpid());\n    for (int i = 0; i &lt; 10; ++i) {\n        printf(\"%d\\n\", rand());\n    }\n}\n</code></pre>"}, {"location": "course-c/40-algorithms/popular-algorithms/random/#valeurs-remarquables", "title": "Valeurs remarquables", "text": "<p>Voici quelques valeurs de \\(a\\), \\(c\\) et \\(m\\) qui donnent de bons r\u00e9sultats\u2009:</p> Source \\(m\\) \\(a\\) \\(c\\) ANSI C \\(2^{31}\\) \\(1103515245\\) \\(12345\\) Borland C \\(2^{32}\\) \\(22695477\\) \\(1\\) MMIX de Donald Knuth \\(2^{64}\\) \\(6364136223846793005\\) \\(1442695040888963407\\) Java \\(2^{48}\\) \\(25214903917\\) \\(11\\)"}, {"location": "course-c/40-algorithms/popular-algorithms/shunting-yard/", "title": "Algorithme de Shunting Yard", "text": "<p>L'algorithme de Shunting Yard est un algorithme de parsing d'expression math\u00e9matique. Il permet de transformer une expression math\u00e9matique en notation infix\u00e9e en une expression postfix\u00e9e. L'algorithme a \u00e9t\u00e9 invent\u00e9 par Edsger Dijkstra en 1961.</p> <p>Imaginez que vous ayez une expression math\u00e9matique sous forme d'une cha\u00eene de caract\u00e8res\u2009:</p> <pre><code>2 + 3 * 8 - 2 * ( 2 - 4 / ( 3 * 8 ) )\n</code></pre> <p>Comment calculer cette expression\u2009? Si vous proc\u00e9dez de gauche \u00e0 droite, vous allez rencontrer des parenth\u00e8ses et des priorit\u00e9s d'op\u00e9rations.</p> <p>L'algorithme se compose de deux files d'attente (FIFO) et d'une pile (LIFO). La file d'attente de sortie contiendra l'expression postfix\u00e9e. La pile contiendra les op\u00e9rateurs.</p> <p> Algorithme de shunting yard</p> <p>Commen\u00e7ons par quelques d\u00e9finitions\u2009:</p> TOKEN <p>Un token est un \u00e9l\u00e9ment de l'expression math\u00e9matique. Il peut s'agir d'un nombre, d'un op\u00e9rateur ou d'une parenth\u00e8se.</p> INPUT <p>Une file d'attente contenant les TOKENS de l'expression math\u00e9matique \u00e0 traiter.</p> OUTPUT <p>Une file d'attente qui contiendra les TOKENS de l'expression postfix\u00e9e.</p> STACK <p>Une pile qui contiendra les op\u00e9rateurs.</p> <p>Voici le pseudo code de l'algorithme\u2009:</p> <ul> <li>Tant qu'il y a des TOKEN \u00e0 lire\u2009:</li> <li>Lire le TOKEN Si le TOKEN est\u2009:<ul> <li>Un nombre\u2009:</li> <li>Le d\u00e9placer sur OUTPUT.</li> <li>Un op\u00e9rateur \\(O_1\\)</li> <li>Tant que:<ul> <li>Il y a un op\u00e9rateur \\(O_2\\) sur le dessus STACK,</li> <li>et que ce n'est pas une parenth\u00e8se gauche,</li> <li>et que \\(O_2\\) a une plus grande priorit\u00e9 que \\(O_1\\),</li> <li>ou que \\(O_2\\) a la m\u00eame priorit\u00e9 que \\(O_1\\),</li> <li>et que \\(O_1\\) est associatif \u00e0 gauche.</li> <li>Alors:</li> <li>D\u00e9placer \\(O_2\\) de STACK sur OUTPUT.</li> <li>D\u00e9placer \\(O_1\\) sur le STACK.</li> </ul> </li> <li>Une parenth\u00e8se gauche (<code>(</code>):</li> <li>D\u00e9placer sur le STACK.</li> <li>Une parenth\u00e8se droite (<code>)</code>):</li> <li>Tant que l'op\u00e9rateur sur le dessus du STACK n'est pas une parenth\u00e8se gauche.<ul> <li>Alors, d\u00e9placer le dernier op\u00e9rateur du STACK sur OUTPUT.</li> <li>Supprimer la parenth\u00e8se gauche du STACK.</li> </ul> </li> </ul> </li> <li>Tant qu'il y a des TOKEN sur le STACK:</li> <li>D\u00e9placer le TOKEN de STACK sur OUTPUT</li> </ul> <p>On observe que si on dispose de fonctions pour ajouter/supprimer des \u00e9l\u00e9ments d'une file d'attente et d'une pile, l'algorithme est relativement simple \u00e0 impl\u00e9menter. Voici l'impl\u00e9mentation en C\u2009:</p> main.cqueue.hstack.hqueue.cstack.c <pre><code>#include \"queue.h\"\n#include \"stack.h\"\n\n#include &lt;stdio.h&gt;\n#include &lt;ctype.h&gt;\n\nint main() {\n    Stack stack = stack_create();\n    Queue output = queue_create();\n    Queue input = queue_create();\n\n    // Load expression in input queue\n    while (!feof(stdin)) {\n        char token;\n        scanf(\"%c\", &amp;token);\n        if (isspace(token))\n            continue;\n        queue_push(&amp;input, token);\n    }\n\n    // Shunting yard algorithm\n    while (!queue_empty(&amp;input)) {\n        char token = queue_pop(&amp;input);\n        if (isdigit(token))\n            queue_push(&amp;output, token);\n        else if (token == '(')\n            stack_push(&amp;stack, token);\n        else if (token == ')') {\n            while (stack_top(&amp;stack) != '(')\n                queue_push(&amp;output, stack_pop(&amp;stack));\n            stack_pop(&amp;stack);\n        } else {\n            while (!stack_empty(&amp;stack) &amp;&amp; stack_top(&amp;stack) != '(')\n                queue_push(&amp;output, stack_pop(&amp;stack));\n            stack_push(&amp;stack, token);\n        }\n    }\n    while (!stack_empty(&amp;stack))\n        queue_push(&amp;output, stack_pop(&amp;stack));\n\n    // Display output queue\n    while (!queue_empty(&amp;output))\n        printf(\"%c\", queue_pop(&amp;output));\n}\n</code></pre> <pre><code>#pragma once\n\ntypedef struct QueueNode {\n    char data;\n    struct QueueNode *next;\n} QueueNode;\n\ntypedef struct {\n    QueueNode *front;\n    QueueNode *rear;\n} Queue;\n\nQueue queue_create();\nvoid queue_push(Queue *queue, char value);\nchar queue_pop(Queue *queue);\nint queue_empty(Queue *queue);\n</code></pre> <pre><code>#pragma once\n\ntypedef struct StackNode {\n    char data;\n    struct StackNode *next;\n} StackNode;\n\ntypedef struct {\n    StackNode *top;\n} Stack;\n\nStack stack_create();\nvoid stack_push(Stack *stack, char value);\nchar stack_pop(Stack *stack);\nchar stack_top(Stack *stack);\nint stack_empty(Stack *stack);\n</code></pre> <pre><code>#include \"queue.h\"\n\n#include &lt;stdlib.h&gt;\n\nQueue queue_create() {\n    Queue queue;\n    queue.front = NULL;\n    queue.rear = NULL;\n    return queue;\n}\n\nvoid queue_push(Queue *queue, char value) {\n    QueueNode *newNode = (QueueNode *)malloc(sizeof(QueueNode));\n    newNode-&gt;data = value;\n    newNode-&gt;next = NULL;\n    if (queue-&gt;rear)\n        queue-&gt;rear-&gt;next = newNode;\n    else\n        queue-&gt;front = newNode;\n    queue-&gt;rear = newNode;\n}\n\nchar queue_pop(Queue *queue) {\n    if (queue-&gt;front == NULL)\n        return '\\0';\n    QueueNode *node = queue-&gt;front;\n    char value = node-&gt;data;\n    queue-&gt;front = node-&gt;next;\n    if (queue-&gt;front == NULL)\n        queue-&gt;rear = NULL;\n    free(node);\n    return value;\n}\n\nint queue_empty(Queue *queue) {\n    return queue-&gt;front == NULL;\n}\n</code></pre> <pre><code>#include \"stack.h\"\n\n#include &lt;stdlib.h&gt;\n\nStack stack_create() {\n    Stack stack;\n    stack.top = NULL;\n    return stack;\n}\n\nvoid stack_push(Stack *stack, char value) {\n    StackNode *newNode = (StackNode *)malloc(sizeof(StackNode));\n    newNode-&gt;data = value;\n    newNode-&gt;next = stack-&gt;top;\n    stack-&gt;top = newNode;\n}\n\nchar stack_pop(Stack *stack) {\n    if (stack-&gt;top == NULL)\n        return '\\0';\n    StackNode *node = stack-&gt;top;\n    char value = node-&gt;data;\n    stack-&gt;top = node-&gt;next;\n    free(node);\n    return value;\n}\n\nchar stack_top(Stack *stack) {\n    if (stack-&gt;top == NULL)\n        return '\\0';\n    return stack-&gt;top-&gt;data;\n}\n\nint stack_empty(Stack *stack) {\n    return stack-&gt;top == NULL;\n}\n</code></pre> <p>Notation polonaise inverse</p> <p>La notation polonaise inverse (RPN) est une notation math\u00e9matique dans laquelle chaque op\u00e9rateur suit ses op\u00e9randes. Par exemple, l'expression <code>3 + 4</code> s'\u00e9crira <code>3 4 +</code>. Cette notation a \u00e9t\u00e9 invent\u00e9e par le math\u00e9maticien polonais Jan \u0141ukasiewicz.</p> <p>Elle a \u00e9t\u00e9 longtemps utilis\u00e9e par les calculatrices Hewlett-Packard et permet de s'affranchir des parenth\u00e8ses. En effet, l'expression <code>3 + 4 * 5</code> s'\u00e9crira <code>3 4 5 * +</code>.</p> <p>La calculatrice mythique HP-42s apparue en 1988 \u00e9tait utilis\u00e9e par beaucoup d'ing\u00e9nieurs et de scientifiques. On y remarque l'absence de touche \u00e9gale <code>=</code>. Pour calculer une expression, il suffisait de taper les op\u00e9randes et les op\u00e9rateurs dans l'ordre. La calculatrice se chargeait de calculer le r\u00e9sultat.</p> <p> HP-42s</p> <p>La notation polonaise inverse est \u00e9galement tr\u00e8s pratique pour les ordinateurs. En effet, il est plus facile de traiter une expression postfix\u00e9e qu'une expression infix\u00e9e. L'algorithme de Shunting Yard permet de transformer une expression infix\u00e9e en une expression postfix\u00e9e.</p>"}, {"location": "course-c/40-algorithms/searching/introduction/", "title": "Algorithmes de recherche", "text": ""}, {"location": "course-c/40-algorithms/sorting/count-sort/", "title": "Counting Sort", "text": "<p>Le tri par d\u00e9nombrement est un algorithme de tri particulier. Il est utilis\u00e9 pour trier des \u00e9l\u00e9ments dont la valeur est connue \u00e0 l'avance. Il est donc inutile pour trier des \u00e9l\u00e9ments dont la valeur est inconnue ou al\u00e9atoire.</p> <p>Nous l'avons vu pr\u00e9c\u00e9demment, il n'est pas possible de trier un tableau mieux qu'en O(n<sub>log</sub>n). En revanche cette assertion n'est pas tout \u00e0 fait juste dans le cas ou les donn\u00e9es brutes poss\u00e8dent des propri\u00e9t\u00e9s remarquables.</p> <p>Pour que cet algorithme soit utilisable, imaginons un contexte o\u00f9 les donn\u00e9es d'entr\u00e9es poss\u00e8dent des propri\u00e9t\u00e9s remarquables.</p> <p>Ici, les donn\u00e9es d'entr\u00e9es seront g\u00e9n\u00e9r\u00e9es entre 0 et 51\u2009; chaque valeur repr\u00e9sentera une carte \u00e0 jouer selon la r\u00e8gle suivante\u2009:</p> <p> cards</p> <p>Cette s\u00e9rie de valeurs dispose de plusieurs propri\u00e9t\u00e9s int\u00e9ressantes\u2009:</p> <ol> <li>La valeur d'une carte est identifi\u00e9e par <code>n % 13</code>.</li> <li>La couleur est identifi\u00e9e par <code>n / 13</code>.</li> <li>Il n'y a donc que 13 valeurs par couleur et 4 couleurs.</li> <li>Bien qu'un entier soit stock\u00e9 sur 4 bytes, il suffit en r\u00e9alit\u00e9 de 6 bits pour encoder la valeur d'une carte.</li> </ol> <p>L'algorithme <code>counting-sort</code> est int\u00e9ressant, car il ne fait pas appel \u00e0 des comparaisons de valeurs.</p> <p>L'algorithme it\u00e9ratif est le suivant\u2009:</p> <ol> <li>On cr\u00e9e un tableau statique de 13 positions correspondant au nombre de valeurs possibles dans notre set de donn\u00e9e. Ce tableau peut \u00eatre nomm\u00e9 <code>counts</code></li> <li>On parcourt le tableau \u00e0 trier lin\u00e9airement et on compte le nombre d'occurrences de chaque valeur dans <code>counts</code>. On aura donc \u00e0 la position <code>0</code> le nombre d'as contenus dans le tableau \u00e0 trier et \u00e0 la positon <code>10</code> le nombre de valets dans le jeu de cartes fourni.</li> <li>Une fois ces comptes termin\u00e9s, une op\u00e9ration de somme cumul\u00e9e est faite sur ce tableau (p.ex. le tableau <code>{1, 2, 2, 0, 8, 1}</code> sera somm\u00e9 comme suit <code>{1, 3, 5, 5, 13, 14}</code>).</li> <li>Le tableau \u00e0 trier est parcouru lin\u00e9airement de la fin vers le d\u00e9but et on copie la valeur \u00e0 la bonne position dans le tableau des valeurs tri\u00e9es. Si votre tableau d'entr\u00e9e non tri\u00e9 est nomm\u00e9 <code>a</code> et votre tableau de sortie tri\u00e9 <code>b</code> vous aurez pour chaque \u00e9l\u00e9ment <code>i</code> : <code>b[c[a[i]--] - 1] = a[i]</code></li> </ol> <p>\u00c0 l'issue de cet algorithme, vous aurez dans <code>b</code> un tableau tri\u00e9 par valeurs.</p> <p>Notez qu'ici les couleurs ne sont pas tri\u00e9es.</p> <p>Voici un exemple de tri sur des entiers entre 0 et 9\u2009:</p> <pre><code>1 0 9 3 8 1 4 8 7 5  Tableau d'entr\u00e9e `a` non tri\u00e9 et contenant que des chiffres\n                     Il y a 10 valeurs possibles par chiffre, donc le tableau\n                     `counts` aura 10 positions:\n\n1 2 0 1 1 1 0 1 2 1  Tableau `counts` calcul\u00e9, il faut lire : une occurrence\n                     de 0, deux occurrences de 2, zero occurrences de 3...\n\n1 3 3 4 5 6 6 1 9 B  Somme cumul\u00e9e (affich\u00e9 en hexad\u00e9cimal)\n\nPour trouver la position tri\u00e9e d'une valeur, par exemple le 3 :\n\n1 0 9 3 8 1 4 8 7 5  a[i] == 3 (on part du tableau a)\n      \u21a7\n1 3 3 4 5 6 6 1 9 B  counts[a[i]] == 4 (on consulte la somme cumul\u00e9e)\n      \u21a7\n_ _ _ 3 _ _ _ _ _ _  b[counts[a[i]]-- - 1] == 3 (on insert la valeur tri\u00e9e)\n\n0 1 1 3 4 5 7 8 8 9  Et ainsi de suite jusqu'\u00e0 tri complet du tableau\n</code></pre> <p>On constate en effet que <code>3</code> est \u00e0 la bonne position dans <code>b</code> et qu'il y aura <code>0 1 1</code> devant.</p> <p>Tel quel, cet algorithme ne permet pas de modifier directement le tableau d'origine puisqu'il ne fait pas intervenir de permutations (<code>swap</code>). Il requiert donc un buffer suppl\u00e9mentaire et donc \u00e0 une complexit\u00e9 en espace de O(n).</p> <p>Concernant les cartes \u00e0 jouer, voici un exemple de tri\u2009:</p> <pre><code>41 23 00 15 26 39 13 02 28  Tableau d'entr\u00e9e\n00 26 39 13 41 15 02 28 23  Tableau tri\u00e9\n\u00c0\u2663 \u00c0\u2665 A\u2660 A\u2666 3\u2660 3\u2666 3\u2663 3\u2665 V\u2666  Valeurs interpr\u00e9t\u00e9es des cartes\n</code></pre> <p>Un avantage de cet algorithme est qu'il est stable, c'est-\u00e0-dire que l'ordre des \u00e9l\u00e9ments \u00e9gaux est conserv\u00e9. Donc on peut ensuite retrier les cartes par couleur.</p>"}, {"location": "course-c/40-algorithms/sorting/heap-sort/", "title": "Heap Sort", "text": "<p>L'algorithme Heap Sort aussi appel\u00e9 \u00ab\u2009Tri par tas\u2009\u00bb est l'un des algorithmes de tri les plus performants offrant une complexit\u00e9 en temps de \\(O(n\\cdot log(n))\\) et une complexit\u00e9 en espace de \\(O(1)\\). Il s'appuie sur le concept d'arbre binaire.</p> <p>Prenons l'exemple du tableau ci-dessous et deux r\u00e8gles suivantes\u2009:</p> <ul> <li>l'enfant de gauche est donn\u00e9 par <code>2 * k + 1</code> ;</li> <li>l'enfant de droite est donn\u00e9 par <code>2 * k + 2</code>.</li> </ul> <pre><code>  1   2       3                  4\n\u251e\u2500\u2500\u2540\u2500\u2500\u252c\u2500\u2500\u2540\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2540\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2526\n\u250208\u250204\u250212\u250220\u250206\u250242\u250214\u250211\u250203\u250235\u250207\u250209\u250211\u250250\u250216\u2502\n\u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  (indice)\n</code></pre> <p>La premi\u00e8re valeur du tableau est appel\u00e9e la racine root. C'est le premier \u00e9l\u00e9ment de l'arbre. Puisqu'il s'agit d'un arbre binaire, chaque n\u0153ud peut comporter jusqu'\u00e0 2 enfants. L'enfant de gauche est calcul\u00e9 \u00e0 partir de l'indice <code>k</code> de l'\u00e9l\u00e9ment courant. Ainsi les deux enfants de l'\u00e9l\u00e9ment <code>4</code> seront <code>2 * 4 + 1 = 9</code> et <code>2 * 4 + 2 == a</code>.</p> <p>Ce tableau lin\u00e9aire en m\u00e9moire pourra \u00eatre repr\u00e9sent\u00e9 visuellement comme un arbre binaire\u2009:</p> <pre><code>             8\n             |\n         ----+----\n       /           \\\n      4            12\n   /    \\        /    \\\n  20     6      42    14\n / \\    / \\    / \\   /  \\\n11  3  35  7  9  11 50  16\n</code></pre> <p>Le c\u0153ur de cet algorithme est le sous-algorithme nomm\u00e9 heapify. Ce dernier \u00e0 pour objectif de satisfaire une exigence suppl\u00e9mentaire de notre arbre\u2009: chaque enfant doit \u00eatre plus petit que son parent. Le principe est donc simple. On part du dernier \u00e9l\u00e9ment de l'arbre qui poss\u00e8de au moins un enfant\u2009: la valeur <code>14</code> (indice <code>6</code>). Le plus grand des enfants est \u00e9chang\u00e9 avec la valeur du parent. Ici <code>50</code> sera \u00e9chang\u00e9 avec <code>14</code>. Ensuite on applique r\u00e9cursivement ce m\u00eame algorithme pour tous les enfants qui ont \u00e9t\u00e9 \u00e9chang\u00e9s. Comme <code>14</code> (anciennement <code>50</code>) n'a pas d'enfant, on s'arr\u00eate l\u00e0.</p> <p>L'algorithme continue en remontant jusqu'\u00e0 la racine de l'arbre. La valeur suivante analys\u00e9e est donc <code>42</code>, comme les deux enfants sont petits on continue avec la valeur <code>6</code>. Cette fois-ci <code>35</code> qui est plus grand est alors \u00e9chang\u00e9. Comme <code>6</code> n'a plus d'enfant, on continue avec <code>20</code>, puis <code>12</code>. \u00c0 cette \u00e9tape, notre arbre ressemble \u00e0 ceci\u2009:</p> <pre><code>             8\n             |\n         ----+----\n       /           \\\n      4            12\n   /    \\        /    \\\n  20    35      42    50\n / \\    / \\    / \\   /  \\\n11  3  6   7  9  11 14  16\n</code></pre> <p>La valeur <code>12</code> est plus petite que <code>50</code> et est donc \u00e9chang\u00e9e. Mais puisque <code>12</code> contient deux enfants (<code>14</code> et <code>16</code>), l'algorithme continue. <code>16</code> est \u00e9chang\u00e9 avec <code>12</code>. L'algorithme se poursuit avec <code>4</code> et se terminera avec la racine <code>8</code>. Finalement l'arbre ressemblera \u00e0 ceci\u2009:</p> <pre><code>            35\n             |\n         ----+----\n       /           \\\n     20            50\n   /    \\        /    \\\n  11     7      42    16\n / \\    / \\    / \\   /  \\\n8   3  6   4  9  11 14  12\n</code></pre> <p>On peut observer que chaque n\u0153ud de l'arbre satisfait \u00e0 l'exigence susmentionn\u00e9e\u2009: tous les enfants sont inf\u00e9rieurs \u00e0 leurs parents.</p> <p>Une fois que cette propri\u00e9t\u00e9 est respect\u00e9e, on a l'assurance que la racine de l'arbre est maintenant le plus grand \u00e9l\u00e9ment du tableau. Il est alors \u00e9chang\u00e9 avec le dernier \u00e9l\u00e9ment du tableau <code>12</code>, qui devient \u00e0 son tour la racine.</p> <p>Le dernier \u00e9l\u00e9ment est sorti du tableau et notre arbre ressemble maintenant \u00e0 ceci\u2009:</p> <pre><code>1   2       3                  4\n\u251e\u2500\u2500\u2540\u2500\u2500\u252c\u2500\u2500\u2540\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2540\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u252c\u2500\u2500\u2526\u2500\u2500\u2526\n\u250212\u250220\u250250\u250211\u2502 7\u250242\u250216\u2502 8\u2502 3\u2502 6\u2502 4\u2502 9\u250211\u250214\u250235\u2502\n\u2514\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2534\u2500\u2500\u2518\n  0  1  2  3  4  5  6  7  8  9  a  b  c  d     (indice)\n\n            12\n             |\n         ----+----\n       /           \\\n     20            50\n   /    \\        /    \\\n  11     7      42    16\n / \\    / \\    / \\   /\n8   3  6   4  9  11 14\n</code></pre> <p>\u00c0 ce moment on recommence\u2009:</p> <ol> <li><code>heapify</code></li> <li>\u00c9change du premier \u00e9l\u00e9ment avec le dernier.</li> <li>Sortie du dernier \u00e9l\u00e9ment de l'arbre.</li> <li>Retour \u00e0 (1) jusqu'\u00e0 ce que tous les \u00e9l\u00e9ments soient sortis de l'arbre.</li> </ol>"}, {"location": "course-c/40-algorithms/sorting/quick-sort/", "title": "Quick Sort", "text": "<p>Le tri rapide est l'algorithme de tri par r\u00e9f\u00e9rence dans la plupart des langage de programmation. Selon le compilateur C que vous utilisez, la fonction <code>qsort</code> impl\u00e9mente cette m\u00e9thode de tri en \\(O(n log n)\\).</p> <p>Quick sort est th\u00e9oriquement plus lent que le Heap sort avec dans le pire des cas en \\(O(n^2)\\). N\u00e9anmoins, en s'appuyant que cette r\u00e9ponse StackOverflow, quick sort reste meilleur pour de grands tableaux car les embranchements sont moins fr\u00e9quents, et le cache processeur est donc mieux utilis\u00e9.</p> <p>Cet algorithme utilise la notion de pivot. Le pivot est un \u00e9l\u00e9ment qui est choisi pour \u00eatre le point autour duquel sont agenc\u00e9 les \u00e9l\u00e9ments. La m\u00e9thode de tri est la suivante\u2009:</p> <ol> <li>Choix d'un pivot</li> <li>Paritionnement\u2009: tous les \u00e9l\u00e9ments plus petit que le pivot sont d\u00e9plac\u00e9 \u00e0 gauche et tous les \u00e9l\u00e9ments plus grands sont \u00e0 droite. L'\u00e9l\u00e9ment pivot est ainsi positionn\u00e9 \u00e0 sa bonne place dans le tableau.</li> <li>Appel r\u00e9cursif pour la partie gauche et droite.</li> </ol> <p>Consid\u00e9rons le tableau suivant. Les valeurs ne sont pas tri\u00e9es. La premi\u00e8re \u00e9tape consiste \u00e0 choisir un pivot. Il existe plusieurs technique\u2009:</p> <ul> <li>Choisir le premier \u00e9l\u00e9ment comme pivot</li> <li>Choisir le dernier \u00e9l\u00e9ment comme pivot</li> <li>Choisir l'\u00e9l\u00e9ment m\u00e9dian comme pivot</li> </ul> <p>Dans cet exemple, le dernier \u00e9l\u00e9ment <code>6</code> sera arbitrairement choisi comme pivot.</p> <p> Repr\u00e9sentation du tableau \u00e0 trier avec son pivot.</p> <p>L'\u00e9tape de paritionnement utilise l'algorithme suivant\u2009:</p> <pre><code>int partition (int a[], int low, int high, int pivot)\n{\n    int i = low;\n    for (int j = low; j &lt; high; j++)\n        if (a[j] &lt; a[pivot])\n            swap(&amp;a[i++], &amp;a[j]);\n    swap(&amp;a[i], &amp;a[pivot]);\n    return i;\n}\n</code></pre> <p>Voici comment <code>partition(a, 0, 10, 10)</code> modifie le tableau (voir code source) :</p> <pre><code>2 9 4 1 b 5 a 7 3 8 6\n2 4 9 1 b 5 a 7 3 8 6\n2 4 1 9 b 5 a 7 3 8 6\n2 4 1 5 b 9 a 7 3 8 6\n2 4 1 5 3 9 a 7 b 8 6\n2 4 1 5 3 6 a 7 b 8 9\n</code></pre> <p>On constate que la valeur <code>6</code> choisie comme pivot est maintenant \u00e0 sa bonne place. L'algorithme est donc appel\u00e9 r\u00e9cursivement pour les \u00e9l\u00e9ments <code>0</code> \u00e0 <code>4</code> et `` 6``  \u00e0 <code>a</code>.</p> <p> Tri rapide apr\u00e8s le premier partitionnement.</p> <p>Voici une autre repr\u00e9sentation (voir code source) :</p> <pre><code>1  9  5  2  b  4  a  7  3  8 [6]\n1  5  2  4  3 [6] a  7  b  8  9\n1  5  2  4 [3]\n1  2 [3] 4  5\n1 [2]\n1 [2]\n        4 [5]\n        4 [5]\n                a  7  b  8 [9]\n                7  8 [9] a  b\n                7 [8]\n                7 [8]\n                        a [b]\n                        a [b]\n</code></pre>"}, {"location": "course-c/45-project-management/software-project/", "title": "Organisation d'un projet", "text": ""}, {"location": "course-c/45-project-management/software-project/#introduction", "title": "Introduction", "text": "<p>Dans ce chapitre, nous allons voir comment organiser un projet logiciel. Nous allons voir comment structurer un projet, comment g\u00e9rer les d\u00e9pendances, comment g\u00e9rer les tests unitaires et comment g\u00e9rer les tests fonctionnels.</p>"}, {"location": "course-c/45-project-management/software-project/#structure-dun-projet", "title": "Structure d'un projet", "text": "<p>La structure d'un projet logiciel est un \u00e9l\u00e9ment important pour sa maintenabilit\u00e9. Une bonne structure permet de retrouver facilement les fichiers sources, les fichiers d'en-t\u00eate, les tests, etc.</p> <p>Si votre projet est accessible par d'autres d\u00e9veloppeurs, il y a certaines conventions \u00e0 respecter pour que tout le monde puisse s'y retrouver.</p> <p>Tout commence avec un dossier racine. Ce dossier racine contient tous les fichiers sources, les fichiers d'en-t\u00eate, les tests, les d\u00e9pendances, etc. Encore faut-il bien nommer ce projet. Un nom de projet doit \u00eatre court, explicite et unique. Il est recommand\u00e9 de ne pas utiliser d'espaces, de caract\u00e8res sp\u00e9ciaux ou de majuscules.</p> <p>Les Majuscules</p> <p>Les noms de fichiers et de dossiers sont sensibles \u00e0 la casse sur les syst\u00e8mes POSIX mais pas sous Windows. Cela cr\u00e9e certains probl\u00e8mes de compatibilit\u00e9 entre les syst\u00e8mes d'exploitation.</p> <p>D'autre part, l'usage des majuscules peut cr\u00e9er des ambigu\u00eft\u00e9s. Par exemple, <code>NomDuFichier</code> et <code>nomdufichier</code> sont deux noms diff\u00e9rents. Comment allez-vous expliquer par t\u00e9l\u00e9phone \u00e0 un coll\u00e8gue que le fichier s'\u00e9crit de cette mani\u00e8re\u2009? L'ennui c'est les acronymes. Par exemple, <code>XMLParser</code>, <code>XmlParser</code> ou <code>XMLparser</code> ? Vous aurez tendance \u00e0 choisir la troisi\u00e8me solution pour que <code>XML</code> ressort bien mais vous \u00eates incoh\u00e9rent puisque vous avez pas utilis\u00e9 de majuscul pour <code>Parser</code>.</p> <p>Le probl\u00e8me est bien r\u00e9solu avec l'utilisation d'underscores ou de tirets (notation kekbab-case ou snake_case). Par exemple, <code>xml_parser</code> est plus lisible et plus facile \u00e0 expliquer.</p> <p>Une convention en voque est de nommer les fichiers en minuscules et d'utiliser des tirets pour s\u00e9parer les mots. Par exemple, <code>xml-parser</code>. C'est la convention utilis\u00e9e sur GitHub pour le nom des d\u00e9p\u00f4ts.</p> <p>Voici une structure de projet classique\u2009:</p> <pre><code>projet/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 main.c\n\u2502   \u251c\u2500\u2500 foo.c\n\u2502   \u2514\u2500\u2500 bar.c\n\u251c\u2500\u2500 include/\n\u2502   \u251c\u2500\u2500 foo.h\n\u2502   \u2514\u2500\u2500 bar.h\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 test_foo.c\n\u2502   \u2514\u2500\u2500 test_bar.c\n\u251c\u2500\u2500 Makefile\n\u2514\u2500\u2500 README.md\n</code></pre> <p>Le point d'entr\u00e9e pour le d\u00e9veloppeur c'est le fichier <code>README.md</code>. Ce fichier contient une description du projet, des instructions pour l'installation, des instructions pour la compilation, des instructions pour les tests, etc.</p>"}, {"location": "course-c/45-project-management/software-project/#readmemd", "title": "README.md", "text": "<p>Jadis, le fichier <code>README</code> \u00e9tait un fichier texte simple. Aujourd'hui, c'est un fichier <code>Markdown</code>. Le <code>Markdown</code> est un langage de balisage l\u00e9ger cr\u00e9\u00e9 en 2004 par John Gruber et Aaron Swartz. Il est facile \u00e0 lire et \u00e0 \u00e9crire. Il est utilis\u00e9 sur de tr\u00e8s nombreux supports\u2009: GitHub, GitLab, Bitbucket, Reddit, Stack Overflow, etc. C'est d'ailleurs le format utilis\u00e9 pour r\u00e9diger cet ouvrage.</p> <p>Voici un exemple de fichier <code>README.md</code> :</p> <pre><code># Nom du Projet\n\nDescription du projet.\n\n## Installation\n\nComment installer le projet :\n\n```bash\ngit clone http://...\ncd projet\nmake\n</code></pre>"}, {"location": "course-c/45-project-management/software-project/#utilisation", "title": "Utilisation", "text": "<p>Comment utiliser le projet\u2009:</p> <pre><code>./projet\n</code></pre> <p>Le fichier <code>README.md</code> est un fichier important. Il doit \u00eatre \u00e0 jour et bien r\u00e9dig\u00e9 car c'est la premi\u00e8re chose que l'on voit lorsqu'on arrive sur le d\u00e9p\u00f4t du projet. Il doit permettre \u00e0 l'utilisateur rapidement\u2009:</p> <ol> <li>Que fait le projet et quelle est son utilit\u00e9\u2009?</li> <li>Est-ce que ce projet est fait pour moi\u2009?</li> <li>Comment l'installer\u2009?</li> <li>Comment l'utiliser\u2009?</li> <li>Comment contribuer\u2009?</li> </ol>"}, {"location": "course-c/45-project-management/software-project/#dotfiles", "title": "Dotfiles", "text": "<p>Dans un syst\u00e8me POSIX, les fichiers commen\u00e7ant par un point sont des fichiers cach\u00e9s. C'est une convention utilis\u00e9e pour les fichiers de configuration. Ces fichiers sont appel\u00e9s <code>dotfiles</code>.</p> <p>On va trouver toute une panoplie de fichiers de configuration dans un projet logiciel tel que\u2009:</p> <ul> <li><code>.gitignore</code> : liste des fichiers \u00e0 ignorer par Git.</li> <li><code>.editorconfig</code> : conventions de codage pour les \u00e9diteurs de texte.</li> <li><code>.github/</code> : dossier contenant l'int\u00e9gration continue, les actions GitHub, etc.</li> <li><code>.env</code> : variables d'environnement pour le projet.</li> </ul>"}, {"location": "course-c/45-project-management/software-project/#makefile", "title": "Makefile", "text": "<p>Le <code>Makefile</code> est un fichier de configuration pour le programme <code>make</code>. C'est g\u00e9n\u00e9ralement le point d'entr\u00e9e pour construire un projet. Si vous trouvez un <code>Makefile</code>, vous savez que vous pourrez tr\u00e8s probablement simplement utiliser la commande <code>make</code> pour construire le projet.</p> <p>N\u00e9anmoins, parfois le <code>Makefile</code> n'est pas suffisant car votre projet est plus complexe et d\u00e9pend de plusieurs biblioth\u00e8ques tierces qui peuvent \u00eatre fastidieuses \u00e0 installer. C'est l\u00e0 qu'interviennent les gestionnaires de d\u00e9pendances que nous verrons plus tard.</p> <p>Alternativement, on peut trouver simplement un script <code>build.sh</code> ou <code>build.bat</code> pour construire le projet que vous appelerer avec <code>./build.sh</code> ou <code>.\\build.bat</code>.</p>"}, {"location": "course-c/45-project-management/software-project/#organisation-des-fichiers-sources", "title": "Organisation des fichiers sources", "text": "<p>Lorsque le projet d\u00e9passe 5 \u00e0 10 fichiers, il est habituel de les d\u00e9placer dans un dossier pour ne pas encombrer la racine du projet. On cr\u00e9e un dossier <code>src</code> pour les fichiers sources qui va contenir tous les fichiers <code>.c</code>.</p> <p>Faut-il s\u00e9parer les fichiers sources des fichiers d'en-t\u00eate\u2009? C'est une question de go\u00fbt. Certains d\u00e9veloppeurs pr\u00e9f\u00e8rent tout mettre dans un seul dossier <code>src</code> pour simplifier la navigation. D'autres pr\u00e9f\u00e8rent s\u00e9parer les fichiers sources des fichiers d'en-t\u00eate. Cela permet de mieux organiser le projet et de mieux g\u00e9rer les d\u00e9pendances. Il n'y a pas de consensus \u00e9tabli mais on peut noter plusieurs points.</p> <p>Lorsqu'un projet est destin\u00e9 \u00e0 devenir une biblioth\u00e8que partag\u00e9e, vous devez fournir les fichiers d'en-t\u00eate pour que les autres d\u00e9veloppeurs puissent utiliser votre biblioth\u00e8que. S'ils sont s\u00e9par\u00e9s, c'est plus facile de les extraire et les distribuer.</p> <p>N\u00e9anmoins, s\u00e9placer les fichiers d'en-t\u00eate dans un dossier <code>include</code> n\u00e9cessite d'informer le compilateur de l'emplacement des fichiers d'en-t\u00eate. C'est g\u00e9n\u00e9ralement fait avec l'option <code>-I</code> de GCC\u2009:</p> <pre><code>gcc -Iinclude -c src/*.c\n</code></pre>"}, {"location": "course-c/45-project-management/software-project/#repertoire-de-construction", "title": "R\u00e9pertoire de construction", "text": "<p>Lorsque vous compilez un projet, vous allez g\u00e9n\u00e9rer des fichiers interm\u00e9diaires (fichiers objets) et des fichiers finaux (ex\u00e9cutables, biblioth\u00e8ques). Selon le projet il peut y avoir beaucoup de fichiers. Afin d'\u00e9viter de ne voir ces fichiers dans votre explorateur de fichiers, on cr\u00e9e un dossier <code>build</code> pour les stocker.</p> <p>Ceci est une convention. Vous pouvez choisir un autre nom pour ce dossier. Par exemple, <code>bin</code>, <code>out</code>, <code>dist</code>, etc.</p> <p>N\u00e9anmoins, il faut d'une part penser \u00e0 ajouter ce dossier dans le <code>.gitignore</code> pour ne pas le versionner, mais \u00e9galement modifier la configuration de votre compilateur pour qu'il place les fichiers objets dans ce dossier\u2009:</p> <pre><code>mkdir -p build\ngcc -Iinclude -c src/*.c -o build/*.o\n</code></pre>"}, {"location": "course-c/45-project-management/software-project/#en-tetes-de-fichiers", "title": "En-t\u00eates de fichiers", "text": "<p>Historiquement, les d\u00e9veloppeurs C utilisait l'outil Doxygen pour g\u00e9n\u00e9rer de la documentation \u00e0 partir des commentaires dans le code source. Cela a donn\u00e9 naissance \u00e0 une convention pour les commentaires de documentation qui est souvent utilis\u00e9e de mani\u00e8re abusive.</p> <p>Aujourd'hui, avec les \u00e9diteurs modernes, il est plus facile de naviguer dans le code source et de trouver des informations sur les fonctions et les structures. Les commentaires de documentation sont souvent redondants et inutiles, ils polluent plus qu'ils n'aident. N\u00e9anmoins, je peux vous donner un exemple de commentaires de documentation pour un fichier d'en-t\u00eate\u2009:</p> <pre><code>/**\n * @brief D\u00e9finition des fonctions pour manipuler des nombres\n * @file numbers.h\n * @date 2024-09-01\n * @author John Doe\n * @version 1.0\n * @copyright Copyright (c) 2021\n *\n * Description d\u00e9taill\u00e9e.\n */\n\n/*********************************************************/\n/*                       INCLUDES                        */\n/*********************************************************/\n#include &lt;stdio.h&gt;\n\n/*********************************************************/\n/*                       STRUCTURES                      */\n/*********************************************************/\ntypedef struct point {\n    int x; //!&lt; Abscisse du point.\n    int y; //!&lt; Ordonn\u00e9e du point.\n} Point; //!&lt; Structure point.\n\n/*********************************************************/\n/*                       FONCTIONS                       */\n/*********************************************************/\n\n/**\n * @brief Fonction d'addition de deux entiers.\n * @param a Premier entier.\n * @param b Deuxi\u00e8me entier.\n * @return La somme des deux entiers.\n *\n * Cette fonction permet d'additionner deux entiers.\n */\nint add(int a, int b) {\n    return a + b;\n}\n\n/*********************************************************/\n/*                       FIN                             */\n/*********************************************************/\n</code></pre> <p>Nous pouvons maintenant discuter de la pertinence de ces commentaires. Int\u00e9ressons-nous tout d'abord \u00e0 l'en-t\u00eate du fichier\u2009:</p> <code>@file</code> <p>Le nom du fichier est en redondance avec le vrai nom du fichier. Si vous renommez le fichier, vous devrez \u00e9galement changer ce commentaire. C'est d'une part une source d'erreur mais surtout pour Git, cela implique que le fichier n'est pas simplement renomm\u00e9 mais supprim\u00e9 et recr\u00e9\u00e9. Cela peut poser des probl\u00e8mes de fusion et d'acc\u00e8s \u00e0 l'historique. Aussi, si vous utilisez Git, cette information est parfaitement inutile.</p> <code>@date</code> <p>La date est inutile car si vous avez besoin de la date, vous pouvez utiliser Git pour voir la date de la derni\u00e8re modification du fichier. D'autre part, il est courant qu'un fichier soit modifi\u00e9 sans que la date soit mise \u00e0 jour. Cela peut \u00eatre une source de confusion.</p> <code>@author</code> <p>Si vous utilisez Git, vous poss\u00e9dez d\u00e9j\u00e0 cette information et de mani\u00e8re beaucoup plus fine. Vous pouvez voir qui a modifi\u00e9 chaque ligne du fichier. G\u00e9rer cette information dans le fichier c'est \u00e9galement s'astreindre \u00e0 ajouter son nom, m\u00eame si vous n'avez ajout\u00e9 qu'une ligne. Et puis, si vous aimez tant le fichier que vous venez tant \u00e0 le modifier que vous avez chang\u00e9 toutes les lignes, devez-vous supprimer le nom du vrai auteur pour mettre le v\u00f4tre\u2009? C'est une source de conflit, est c'est beaucoup plus simple de laisser Git g\u00e9rer cette information.</p> <code>@version</code> <p>M\u00eame rengaine et m\u00eame punition. Si vous utilisez Git, vous avez d\u00e9j\u00e0 cette information. Git g\u00e8re les version avec les tags et les branches. Vous pouvez voir l'historique des modifications et les diff\u00e9rences entre les versions. D'autre part, pour les m\u00eame raisons qu'\u00e9voqu\u00e9es, \u00e0 chaque nouvelle version de votre projet, vous devez modifier ce commentaire dans tous les fichiers. Cela implique que tous ces fichiers vont changer et vous allez vous perdre dans l'historique.</p> <code>@brief</code> <p>Enfin une information utile. C'est une excellente pratique que d'avoir une description courte du fichier. N\u00e9anmoins avec Doxygen il existe l'option <code>JAVADOC_AUTOBRIEF</code> qui permet de g\u00e9n\u00e9rer automatiquement le <code>@brief</code> \u00e0 partir de la premi\u00e8re phrase du commentaire si elle se termine par un point. C'est une option \u00e0 activer pour \u00e9viter de r\u00e9p\u00e9ter la m\u00eame chose.</p> <code>@copyright</code> <p>C'est une information importante. Elle permet de savoir comment le fichier peut \u00eatre utilis\u00e9. N\u00e9anmoins, il est rare que pour un projet donn\u00e9, le copyright et la licence changent d'un fichier \u00e0 l'autre, il est donc plus judicieux de mettre cette information dans le <code>README</code> ou mieux dans un fichier <code>LICENSE</code>.</p> <p>Maintenant que nous avons balay\u00e9 l'en-t\u00eate, concentrons-nous sur la fonction <code>add</code>. Cette fonction fait 3 lignes et le commentaire 8 lignes. Est-ce r\u00e9ellement n\u00e9cessaire de documenter une fonction que tout le monde peut comprendre\u2009?</p> <p>La r\u00e9ponse n'est pas si simple. Si vous publier le code source avec votre biblioth\u00e8que, la r\u00e9ponse est non car n'importe qui pourra la comprendre. N\u00e9anmoins votre biblioth\u00e8que est publi\u00e9e sans le code source, la seule chose que votre utlisateur aura c'est le fichier d'en-t\u00eate (<code>.h</code>) :</p> <pre><code>int add(int a, int a);\n</code></pre> <p>C'est peut-\u00eatre un peu court et un compl\u00e9ment d'information pourrait \u00eatre utile. Mais faut-il documenter tous les param\u00e8tres\u2009? Si le brief dit que la fonction additionne deux entiers, et que vous avez acc\u00e8s aux types des param\u00e8tres, est-ce vraiment n\u00e9cessaire de documenter les param\u00e8tres\u2009? La r\u00e9ponse est non. Je le r\u00e9p\u00e8te souvent, un commentaire est fait pour expliquer le pourquoi, pas le comment. Si vous avez besoin de documenter le comment, c'est que votre code n'est pas assez clair. On pourrait par exemple r\u00e9\u00e9crire la fonction de la mani\u00e8re suivante\u2009:</p> <pre><code>int add_two_integers_together(int first, int second) {\n    return first + second;\n}\n</code></pre> <p>Je vous l'accorde, c'est un peu long, mais \u00e7a \u00e0 le m\u00e9rire d'\u00eatre parfaitement clair.</p> <p>Questionnons maintenant les s\u00e9parateurs de contenu. Lorsque vous d\u00e9butez en programmation, vous avez tendance \u00e0 vous faire mousser un peu en \u00e9crivant plus que le n\u00e9cessaire, \u00e9crire des commentaires c'est sans risque et cela rallonge votre beau programme. Alors pour bien structurer votre code, vous avez mis des s\u00e9parateurs de contenu. N\u00e9anmoins ils n'apportent pas grand chose. En Python par exemple, la norme propose d'ajouter deux retour \u00e0 la ligne entre chaque fonction. C'est une convention qui est largement suffisante pour s\u00e9parer les diff\u00e9rents \u00e9l\u00e9ments du code.</p> <p>Enfin, la derni\u00e8re question est de savoir si le commentaire de la structure <code>Point</code> est utile. Pour cette structure qui est tr\u00e8s simple, on pourrait se passer de commentaires, mais dans le cas ou les \u00e9l\u00e9ments n\u00e9cessitent d'\u00eatre expliqu\u00e9s, c'est la notation Doxygen qui peut \u00eatre discut\u00e9e.</p> <p>Doxygen utilise la notation <code>//!</code> pour les commentaires de documentation. C'est une notation sp\u00e9ciale qui a la facheuse tendance s'afficher en rouge vif dans certains \u00e9diteurs de texte. Si vous n'utilisez pas Doxygen, il est pr\u00e9f\u00e9rable de ne pas utiliser cette notation. Il est pr\u00e9f\u00e9rable de rester sur la notation <code>//</code> qui est plus universelle.</p> <p>Apr\u00e8s ces longues explications, je vous propose de vous redonner l'exemple simplifi\u00e9\u2009:</p> <pre><code>/**\n * D\u00e9finition des fonctions pour manipuler des nombres\n *\n * Description d\u00e9taill\u00e9e.\n */\n#include &lt;stdio.h&gt;\n\ntypedef struct point {\n    int x; //!&lt; Abscisse du point.\n    int y; //!&lt; Ordonn\u00e9e du point.\n} Point; //!&lt; Structure point.\n\nint add_two_integers(int a, int b) {\n    return a + b;\n}\n</code></pre> <p>Le commentaire de trop</p> <pre><code>/*********************************************************/\n/*                    FIN DU FICHIER                     */\n/*********************************************************/\n</code></pre> <p>Diable\u2009! Pourquoi trouve-t-on toujours un commentaire <code>FIN</code> \u00e0 la fin des fichiers\u2009? C'est une pratique qui remonte \u00e0 l'\u00e9poque des cartes perfor\u00e9es. Les cartes perfor\u00e9es \u00e9taient utilis\u00e9es pour stocker les programmes. Chaque carte avait un num\u00e9ro de ligne et un num\u00e9ro de colonne. Pour \u00e9viter de m\u00e9langer les cartes, on mettait un commentaire <code>FIN</code> \u00e0 la fin de chaque carte. C'est une pratique ancestrale qui a perdur\u00e9 jusqu'\u00e0 aujourd'hui. Les d\u00e9veloppeurs r\u00e9p\u00e8tent inlassablement ces habitudes sans toutefois les remettre en question.</p> <p>Aujourd'hui, un fichier est fini au sens que lorsqu'on en atteint la fin, on le sait. Il n'est alors pas pertinent de le pr\u00e9ciser.</p> <p>C'est un peu la m\u00eame chose que ces pages dans les livres laiss\u00e9es blanches, ou presque, avec un commentaire \u00ab\u2009Cette page a \u00e9t\u00e9 intentionnellement laiss\u00e9e blanche\u2009\u00bb qui remontait \u00e0 l'\u00e9poque de l'impression en offset. Lorsqu'on imprimait un livre, on imprimait les pages par feuille de 16 pages. Si le livre faisait 200 pages, il fallait ajouter 4 pages blanches \u00e0 la fin pour que l'impression soit correcte. Aujourd'hui, les livres sont imprim\u00e9s en num\u00e9rique et il n'y a plus besoin de ces pages blanches.</p>"}, {"location": "course-c/45-project-management/software-project/#gestion-de-configuration", "title": "Gestion de configuration", "text": "<p>La gestion de configuration est un \u00e9l\u00e9ment important pour un projet logiciel. Elle permet de stocker des informations qui peuvent varier d'un environnement \u00e0 un autre. Par exemple, les informations de connexion \u00e0 une base de donn\u00e9es, les cl\u00e9s d'API, les adresses IP, etc.</p> <p>Il existe plusieurs solutions pour g\u00e9rer la configuration d'un projet\u2009:</p> <ul> <li>Les variables d'environnement.</li> <li>Les fichiers de configuration.</li> </ul>"}, {"location": "course-c/45-project-management/software-project/#variables-denvironnement", "title": "Variables d'environnement", "text": "<p>Les variables d'environnement sont des variables stock\u00e9es dans l'environnement d'ex\u00e9cution d'un programme. Elles sont accessibles par le programme et peuvent \u00eatre modifi\u00e9es par l'utilisateur. Ces variables sont propag\u00e9es \u00e0 tous les processus enfants pour autant qu'elles ait \u00e9t\u00e9 export\u00e9es. Elles peuvent \u00eatre utile dans un projet pour stocker des informations sensibles qui ne devraient pas \u00eatre versionn\u00e9es.</p> <p>Prenons l'exemple d'une cl\u00e9 d'API. Cette cl\u00e9 vous permet d'acc\u00e9der \u00e0 un service tiers depuis votre programme. Chaque utilisateur de votre programme doit avoir sa propre cl\u00e9 d'API. Si vous stockez cette cl\u00e9 dans le code source, vous risquez de la versionner et de la rendre publique. Si vous stockez cette cl\u00e9 dans un fichier de configuration, vous risquez de le versionner et de le rendre public \u00e9galement. Une bonne solution est de stocker cette cl\u00e9 dans une variable d'environnement.</p> <p>Il se peut d'ailleurs que votre projet n\u00e9cessite plusieurs variables d'environnement. On utilise couramment un fichier <code>.env.example</code> pour lister les variables d'environnement n\u00e9cessaires au projet. Ce fichier est versionn\u00e9 et contient des valeurs par d\u00e9faut. L'utilisateur doit copier ce fichier en <code>.env</code> et renseigner les valeurs.</p> .env.example<pre><code>API_KEY=your_api_key\nDATABASE_URL=your_database_url\n</code></pre> .env<pre><code>API_KEY=1234567890\nDATABASE_URL=postgres://user:password@localhost:5432/database\n</code></pre> <p>Pour d\u00e9ployer votre environnement de d\u00e9veloppement, vous devez exporter ces variables d'environnement. Vous pouvez le faire dans votre terminal ou dans un fichier de configuration de votre terminal (<code>.bashrc</code>, <code>.zshrc</code>, etc.).</p> <pre><code>export $(cat .env | xargs)\n</code></pre> <p>Sous Windows vous pouvez utiliser la commande <code>set</code> :</p> <pre><code>for /f \"delims== tokens=1,2\" %i in (.env) do set %i=%j\n</code></pre> <p>Ces commandes sont g\u00e9n\u00e9ralement int\u00e9gr\u00e9es dans un script <code>start.sh</code> ou <code>start.bat</code> pour d\u00e9marrer votre projet, ou alors directement dans le <code>Makefile</code>.</p>"}, {"location": "course-c/45-project-management/software-project/#fichier-den-tete", "title": "Fichier d'en-t\u00eate", "text": "<p>On trouve tr\u00e8s souvent dans un projet C un fichier d'en-t\u00eate <code>.h</code> qui contient des d\u00e9finitions de configuration. Par exemple, un fichier <code>config.h</code> qui contient des constantes, des macros, des structures, etc.</p> <pre><code>#ifndef CONFIG_H\n#define CONFIG_H\n\n#define VERSION \"1.0.0\"\n#define AUTHOR \"John Doe\"\n\n#define USE_FEATURE_A\n#define USE_FEATURE_B\n\n#define API_KEY \"your_api_key\"\n#define DATABASE_URL \"your_database_url\"\n</code></pre> <p>Ce fichier est inclus dans les fichiers sources qui ont besoin de ces informations. Il est versionn\u00e9 et donc ne devrait pas contenir d'informations sensibles. Si vous avez des informations sensibles, vous pouvez les stocker dans un fichier <code>.env</code> et les exporter dans les variables d'environnement. Ces variables peuvent \u00eatre utilis\u00e9e dans votre Makefile pour d\u00e9clarer des variables de compilation.</p> <pre><code>include .env\n\nCFLAGS += -DAPI_KEY=\\\"$(API_KEY)\\\"\nCFLAGS += -DDATABASE_URL=\\\"$(DATABASE_URL)\\\"\n</code></pre>"}, {"location": "course-c/45-project-management/teamwork/", "title": "Travail en \u00e9quipe", "text": ""}, {"location": "course-c/45-project-management/teamwork/#introduction", "title": "Introduction", "text": "<p>Lorsque vous travaillez dans une entreprise sur le d\u00e9veloppement d'un logiciel il est tr\u00e8s rare que vous soyez seul. Vous serez souvent en \u00e9quipe, et vous devrez collaborer avec d'autres d\u00e9veloppeurs, des testeurs, des chefs de projet, des graphistes, des commerciaux, etc. Il est donc important de savoir travailler en \u00e9quipe.</p>"}, {"location": "course-c/45-project-management/teamwork/#equipe-de-developpement", "title": "\u00c9quipe de d\u00e9veloppement", "text": "<p>Une \u00e9quipe de d\u00e9veloppement est compos\u00e9e de plusieurs personnes ayant des comp\u00e9tences diff\u00e9rentes. Voici quelques r\u00f4les que l'on peut retrouver dans une \u00e9quipe de d\u00e9veloppement\u2009:</p> Chef de projet <p>Il est responsable de la gestion du projet. Il doit s'assurer que le projet est livr\u00e9 dans les temps, dans le budget et avec la qualit\u00e9 attendue.</p> D\u00e9veloppeur <p>Il est charg\u00e9 de d\u00e9velopper le logiciel. Il doit \u00e9crire du code, le tester et le documenter.</p> Testeur <p>Il est charg\u00e9 de tester le logiciel. Il doit s'assurer que le logiciel fonctionne correctement et qu'il ne contient pas de bugs.</p> Devops <p>Il est charg\u00e9 de mettre en place et de maintenir l'infrastructure n\u00e9cessaire au d\u00e9veloppement du logiciel. Il doit s'assurer que le logiciel peut \u00eatre d\u00e9ploy\u00e9 facilement et rapidement.</p>"}, {"location": "course-c/45-project-management/testing/", "title": "Qualit\u00e9 et Testabilit\u00e9", "text": "<p> Bogue de l'an 2000</p> <p>Surveiller et assurer la qualit\u00e9 d'un code est primordial dans toute institution et quelques soit le produit. Dans l'industrie automobile par exemple, un bogue qui serait d\u00e9couvert plusieurs ann\u00e9es apr\u00e8s la commercialisation d'un mod\u00e8le d'automobile aurait des cons\u00e9quences catastrophiques.</p> <p>Voici quelques exemples c\u00e9l\u00e8bres de rat\u00e9s logiciels\u2009:</p> La sonde martienne Mariner <p>En 1962, un bogue logiciel a caus\u00e9 l'\u00e9chec de la mission avec la destruction de la fus\u00e9e apr\u00e8s qu'elle ait diverg\u00e9 de sa trajectoire. Une formule a mal \u00e9t\u00e9 retranscrite depuis le papier en code ex\u00e9cutable. Des tests suffisants auraient \u00e9vit\u00e9 cet \u00e9chec.</p> Un pipeline sovi\u00e9tique de gaz <p>En 1982, un bogue a \u00e9t\u00e9 introduit dans un ordinateur canadien achet\u00e9 pour le contr\u00f4le d'un pipeline de gaz transsib\u00e9rien. L'erreur est report\u00e9e comme la plus large explosion jamais enregistr\u00e9e d'origine non nucl\u00e9aire.</p> Le g\u00e9n\u00e9rateur de nombre pseudo-al\u00e9atoire Kerberos <p>Kerberos est un syst\u00e8me de s\u00e9curit\u00e9 utilis\u00e9 par Microsoft pour chiffrer les mots de passe des comptes Windows. Une erreur de code lors de la g\u00e9n\u00e9ration d'une graine al\u00e9atoire a permis de fa\u00e7on triviale pendant 8 ans de p\u00e9n\u00e9trer n'importe quel ordinateur utilisant une authentification Kerberos.</p> La division enti\u00e8re sur Pentium <p>En 1993, une erreur sur le silicium des processeurs Pentium, fleuron technologique de l'\u00e9poque, menait \u00e0 des erreurs de calcul en virgule flottante. Par exemple la division \\(4195835.0/3145727.0\\) menait \u00e0 \\(1.33374\\) au lieu de \\(1.33382\\)</p>"}, {"location": "course-c/45-project-management/testing/#square", "title": "SQuaRE", "text": "<p>La norme ISO/IEC 25010 (qui remplace ISO/IEC 9126-1) d\u00e9crit les caract\u00e9ristiques d\u00e9finissant la qualit\u00e9 d'un logiciel. L'acronyme SQuaRE (Software product Quality Requirements and Evaluation) d\u00e9finit le standard international. Voici quelques crit\u00e8res d'un code de qualit\u00e9\u2009:</p> <ul> <li>Maintenabili\u00e9</li> <li>Modifiabilit\u00e9</li> <li>Testabilit\u00e9</li> <li>Analisabilit\u00e9</li> <li>Stabilit\u00e9</li> <li>Changeabilit\u00e9</li> <li>R\u00e9utilisabilit\u00e9</li> <li>Compr\u00e9hensibilit\u00e9</li> </ul>"}, {"location": "course-c/45-project-management/testing/#hacking", "title": "Hacking", "text": ""}, {"location": "course-c/45-project-management/testing/#buffer-overflow", "title": "Buffer overflow", "text": "<p>L'attaque par buffer overflow est un type d'attaque typique permettant de modifier le comportement d'un programme en exploitant \u00ab\u2009le jardinage m\u00e9moire\u2009\u00bb. Lorsqu'un programme a mal \u00e9t\u00e9 con\u00e7u et que les tests de d\u00e9passement n'ont pas \u00e9t\u00e9 correctement impl\u00e9ment\u00e9s, il est souvent possible d'acc\u00e9der \u00e0 des comportements de programmes impr\u00e9vus.</p> <p>Consid\u00e9rons le programme suivant\u2009:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint check_password(char *str) {\n    if(strcmp(str, \"starwars\"))\n    {\n        printf (\"Wrong Password \\n\");\n        return 0;\n    }\n\n    printf (\"Correct Password \\n\");\n    return 1;\n}\n\nint main(void)\n{\n    char buffer[15];\n    int is_authorized = 0;\n\n    printf(\"Password: \");\n    gets(buffer);\n    is_authorized = check_password(buffer);\n\n    if(is_authorized)\n    {\n        printf (\"Now, you have the root access! \\n\");\n    }\n}\n</code></pre> <p>\u00c0 priori, c'est un programme tout \u00e0 fait correct. Si l'utilisateur entre le bon mot de passe, il se voit octroyer des privil\u00e8ges administrateurs. Testons ce programme\u2009:</p> <pre><code>$ gcc u.c -fno-stack-protector\n$ ./a.out\nPassword: starwars\nCorrect Password\nNow, you have the root access!\n</code></pre> <p>Tr\u00e8s bien, maintenant testons avec un mauvais mot de passe\u2009:</p> <pre><code>$ ./a.out\nPassword: startrek\nWrong Password\n</code></pre> <p>Et maintenant, essayons avec un mot de passe magique...</p>"}, {"location": "course-c/45-project-management/testing/#tests-unitaires", "title": "Tests unitaires", "text": "<p>Un test unitaire est une proc\u00e9dure permettant de v\u00e9rifier le bon fonctionnement d'une unit\u00e9 de code. Une unit\u00e9 de code est la plus petite partie d'un programme qui peut \u00eatre test\u00e9e de mani\u00e8re isol\u00e9e. En C, une unit\u00e9 de code est souvent une fonction.</p> <p>Lorsque l'on travaille selon la philosophie du TDD (Test Driven Development), on commence par \u00e9crire les tests unitaires avant d'\u00e9crire le code. Voici par exemple un test unitaire pour la r\u00e9solution d'une \u00e9quation du second degr\u00e9\u2009:</p> <pre><code>#include &lt;stdio.h&gt;\n\nbool quadratic_solver(double a, double b, double c, double *x1, double *x2)\n{\n    double delta = b * b - 4 * a * c;\n\n    if (delta &lt; 0)\n        return false;\n\n    *x1 = (-b + sqrt(delta)) / (2 * a);\n    *x2 = (-b - sqrt(delta)) / (2 * a);\n\n    return true;\n}\n\nvoid test_quadratic_solver(void)\n{\n    double x1, x2;\n\n    // Cas 1 : Deux racines r\u00e9elles et distinctes\n    assert(quadratic_solver(1, -3, 2, &amp;x1, &amp;x2) == true);\n    assert(fabs(x1 - 2.0) &lt; 1e-6);\n    assert(fabs(x2 - 1.0) &lt; 1e-6);\n\n    // Cas 2 : Deux racines r\u00e9elles et \u00e9gales\n    assert(quadratic_solver(1, -2, 1, &amp;x1, &amp;x2) == true);\n    assert(fabs(x1 - 1.0) &lt; 1e-6);\n    assert(fabs(x2 - 1.0) &lt; 1e-6);\n\n    // Cas 3 : Racines complexes (pas de solution r\u00e9elle)\n    assert(quadratic_solver(1, 0, 1, &amp;x1, &amp;x2) == false);\n\n    // Cas 4 : a = 0 (ce n'est pas une \u00e9quation quadratique)\n    assert(quadratic_solver(0, 2, 1, &amp;x1, &amp;x2) == false);\n\n    // Cas 5 : Equation triviale (b = 0 et c = 0)\n    assert(quadratic_solver(1, 0, 0, &amp;x1, &amp;x2) == true);\n    assert(fabs(x1 - 0.0) &lt; 1e-6);\n    assert(fabs(x2 - 0.0) &lt; 1e-6);\n}\n</code></pre> <p>En pratique on aimerait lancer les tests unitaires automatiquement \u00e0 chaque modification du code source. Pour cela, on utilisera des outils d'int\u00e9gration continue comme Travis CI ou GitHub Actions.</p> <p>Souvent on utilise des frameworks de tests unitaires pour automatiser les tests. En C, on peut citer Unity.</p> <p>Reprenons l'exemple pr\u00e9c\u00e9dent avec Unity\u2009:</p> <pre><code>#include \"unity.h\"\n#include \"quadratic_solver.h\"\n\n#include &lt;stdio.h&gt;\n\nvoid setUp(void) {}\n\nvoid tearDown(void) {}\n\nvoid test_quadratic_solver(void)\n{\n    double x1, x2;\n\n    // Cas 1 : Deux racines r\u00e9elles et distinctes\n    TEST_ASSERT_TRUE(quadratic_solver(1, -3, 2, &amp;x1, &amp;x2));\n    TEST_ASSERT_FLOAT_WITHIN(1e-6, x1, 2.0);\n    TEST_ASSERT_FLOAT_WITHIN(1e-6, x2, 1.0);\n\n    // Cas 2 : Deux racines r\u00e9elles et \u00e9gales\n    TEST_ASSERT_TRUE(quadratic_solver(1, -2, 1, &amp;x1, &amp;x2));\n    TEST_ASSERT_FLOAT_WITHIN(1e-6, x1, 1.0);\n    TEST_ASSERT_FLOAT_WITHIN(1e-6, x2, 1.0);\n\n    // Cas 3 : Racines complexes (pas de solution r\u00e9elle)\n    TEST_ASSERT_FALSE(quadratic_solver(1, 0, 1, &amp;x1, &amp;x2));\n\n    // Cas 4 : a = 0 (ce n'est pas une \u00e9quation quadratique)\n    TEST_ASSERT_FALSE(quadratic_solver(0, 2, 1, &amp;x1, &amp;x2));\n\n    // Cas 5 : Equation triviale (b = 0 et c = 0)\n    TEST_ASSERT_TRUE(quadratic_solver(1, 0, 0, &amp;x1, &amp;x2));\n    TEST_ASSERT_FLOAT_WITHIN(1e-6, x1, 0.0);\n    TEST_ASSERT_FLOAT_WITHIN(1e-6, x2, 0.0);\n}\n</code></pre>"}, {"location": "course-c/45-project-management/testing/#tests-fonctionnels", "title": "Tests fonctionnels", "text": "<p>Les tests fonctionnels permettent de v\u00e9rifier le bon fonctionnement d'une application dans son ensemble. Ils sont souvent utilis\u00e9s pour tester des applications web ou des applications mobiles. Les tests fonctionnels sont souvent automatis\u00e9s et peuvent \u00eatre lanc\u00e9s \u00e0 chaque modification du code source.</p> <p>Dans le cadre de ce cours on utilise le framework Baygon pour r\u00e9aliser des tests fonctionnels.</p> <p>Pour l'utiliser il suffit de cr\u00e9er un fichier <code>tests.yml</code> \u00e0 la racine de votre projet\u2009:</p> <pre><code>version: 1\ntests:\n  - name: Arguments check\n    tests:\n      - name: No errors if two arguments\n        args: [1, 2]\n        exit: 0\n      - name: Error if less than two arguments\n        args: [1]\n        exit: 1\n  - name: Stdout is the sum of arguments\n    args: [1, 2]\n    stdout: []\n  - name: Version on stderr\n    args: ['--version']\n    stderr:\n      - regex: '\\b\\d\\.\\d\\.\\d\\b'\n      - contains: 'Version'\n</code></pre> <p>Il faut ensuite installer Baygon\u2009:</p> <pre><code>$ pip install baygon\n</code></pre> <p>Et lancer les tests\u2009:</p> <pre><code>$ baygon program\n</code></pre>"}, {"location": "course-c/50-philosophy/funny/", "title": "Humour d'informaticien", "text": ""}, {"location": "course-c/50-philosophy/funny/#une-nouvelle-norme", "title": "Une nouvelle norme\u2009?", "text": "<p>Parfois un d\u00e9veloppeur a une id\u00e9e brillante pour une nouvelle technologie, un nouveau protocol de communication, un nouveau format de fichier, etc. Il est persuad\u00e9 que ce nouveau standard plus simple, plus efficace, plus rapide, plus s\u00e9curis\u00e9, etc. va r\u00e9volutionner le monde de l'informatique et remplacer de sucro\u00eet plusieurs standards existants.</p> <p>H\u00e9las, le constat est souvent le m\u00eame\u2009: le nouveau standard ne sera qu'un \u00e9ni\u00e8me standard \u00e0 ajouter \u00e0 la liste des standards existants.</p> <p> XKCD Standards</p> <p></p>"}, {"location": "course-c/50-philosophy/funny/#unicode_1", "title": "Unicode", "text": "<p>Unicode est dirig\u00e9 par un consortium de grandes entreprises technologiques et de parties prenantes. Les fondateurs d'Unicode comprennent Joe Becker, qui travaillait pour Xerox dans les ann\u00e9es 80. Il avait une barbe et il se pourrait bien qu'il est le personnage figurant dans le premier et le troisi\u00e8me panneaux.</p> <p>Les emoji ont \u00e9t\u00e9 initialement ajout\u00e9s pour \u00eatre compatibles avec les encodages de messages texte au Japon. Mais ce n'est plus le cas. L'emoji homard (\ud83e\udd9e) a \u00e9t\u00e9 approuv\u00e9 en 2018, date de sortie de ce comics.</p> <p> XKCD Unicode</p>"}, {"location": "course-c/50-philosophy/funny/#vrais-programmeurs", "title": "Vrais programmeurs", "text": "<p>Un rappel \u00e0 aux guerres d'\u00e9diteurs de texte, en particulier Vim et Emacs... De toute mani\u00e8re Vim \u00e0 gagn\u00e9 la guerre, non\u2009?</p> <p> XKCD Real Programmers</p>"}, {"location": "course-c/50-philosophy/funny/#compilation", "title": "Compilation", "text": "<p>Compiler un programme est une t\u00e2che qui peut prendre du temps. Parfois, il est n\u00e9cessaire de compiler un programme plusieurs fois pour obtenir un programme fonctionnel. Selon la taille du programme, le d\u00e9veloppeur peut avoir le temps de faire une pause ou plusieurs, de prendre un caf\u00e9 ou plusieurs, de lire un livre, ou de justifier n'importe quelle autre activit\u00e9...</p> <p> XKCD Compiling</p>"}, {"location": "course-c/50-philosophy/philosophy/", "title": "Philosophie", "text": "<p>La philosophie d'un bon d\u00e9veloppeur repose sur plusieurs principes de programmation relevant majoritairement du bon sens de l'ing\u00e9nieur. Les vaudois l'appelant parfois\u2009: le bon sens paysan comme l'aurait sans doute confirm\u00e9 feu Jean Villard dit Gilles.</p>"}, {"location": "course-c/50-philosophy/philosophy/#rasoir-dockham", "title": "Rasoir d'Ockham", "text": "<p> Illustration humoristique du rasoir d'Ockham</p> <p>Le rasoir d'Ockham expose en substance que les multiples ne doivent pas \u00eatre utilis\u00e9s sans n\u00e9cessit\u00e9. C'est un principe d'\u00e9conomie, de simplicit\u00e9 et de parcimonie. Il peut \u00eatre r\u00e9sum\u00e9 par la devise Shadok : \u00ab\u2009Pourquoi faire simple quand on peut faire compliqu\u00e9\u2009?\u2009\u00bb</p> <p>En philosophie un rasoir est un principe qui permet de raser des explications improbables d'un ph\u00e9nom\u00e8ne. Ce principe tient son nom de Guillaume d'Ockham (XIVe si\u00e8cle) alors qu'il date probablement d'Emp\u00e9docle (\u1f18\u03bc\u03c0\u03b5\u03b4\u03bf\u03ba\u03bb\u1fc6\u03c2) vers 450 av. J.-C.</p> <p>Il trouve admirablement bien sa place en programmation o\u00f9 le programmeur ne peut conserver une vue d'ensemble sur un logiciel qui est par nature invisible \u00e0 ses yeux. Seuls la simplicit\u00e9 et l'art de la conception logicielle sauvent le d\u00e9veloppeur de la noyade, car un programme peut rester simple, quelle que soit sa taille et si chaque strate de conception reste \u00e9vidente et compr\u00e9hensible pour celui qui chercherait \u00e0 contribuer au projet d'autrui.</p>"}, {"location": "course-c/50-philosophy/philosophy/#leffet-dunning-kruger", "title": "L'effet Dunning-Kruger", "text": "<p>L'effet Dunning-Kruger est un biais cognitif qui se manifeste par une surestimation des comp\u00e9tences d'une personne. Les personnes les moins comp\u00e9tentes dans un domaine ont tendance \u00e0 surestimer leurs comp\u00e9tences, tandis que les personnes les plus comp\u00e9tentes ont tendance \u00e0 les sous-estimer.</p> <p> Illustration satirique de l'effet Dunning-Kruger</p> <p>J'ai vu bien souvent chez mes \u00e9tudiants et coll\u00e8gues ce biais de surconfiance, et je l'ai moi-m\u00eame exp\u00e9riment\u00e9. Il est difficile de se rendre compte de son propre niveau de comp\u00e9tence, et il est souvent n\u00e9cessaire de se confronter \u00e0 des pairs pour se rendre compte de ses lacunes. Soumettre son code \u00e0 la critique est par bien des \u00e9gard une perspective effrayante, mais c'est aussi une source d'enrichissement inestimable.</p> <p>Note</p> <p>L'effet Dunning-Kruger ne fait pas consensus au sein de la communaut\u00e9 scientifique, mais il est souvent cit\u00e9 en psychologie populaire.</p>"}, {"location": "course-c/50-philosophy/philosophy/#philosophie-de-conception", "title": "Philosophie de conception", "text": "<p>Ces principes sont des lignes directrices aidant le d\u00e9veloppeur \u00e0 organiser son code pour le rendre plus lisible, plus maintenable, et moins sensible aux erreurs humaines.</p> <p>Il ne suffit pas d'avoir un programme qui fonctionne, et un sup\u00e9rieur hi\u00e9rarchique heureux, l'attitude du programmeur transcende l'acte singulier de coder. Cette \u00e9tat d'esprit ne s'enseigne pas, elle vient avec l'ex\u00e9rience.</p> <p>Voici les quatre principes les plus connus\u2009:</p> <ul> <li> <p>DRY Ne vous r\u00e9p\u00e9tez pas.</p> <p>Do not repeat yourself.</p> </li> <li> <p>KISS Restez simple, stupide.</p> <p>Keep it simple, stupid.</p> </li> <li> <p>SSOT Une seule source de v\u00e9rit\u00e9.</p> <p>Single source of truth.</p> </li> <li> <p>YAGNI Vous n'en aurez pas besoin.</p> <p>You ain't gonna need it.</p> </li> </ul> <p></p>"}, {"location": "course-c/50-philosophy/philosophy/#dry_1", "title": "DRY", "text": "<p>Ne vous r\u00e9p\u00e9tez pas (Don't Repeat Yourself)! Je r\u00e9p\u00e8te, ne vous r\u00e9p\u00e9tez pas ! Il s'agit d'une philosophie de d\u00e9veloppement logiciel \u00e9vitant la redondance de code. L'excellent livre The Pragmatic Programmer de Andrew Hunt et David Thomas d\u00e9crit cette philosophie en ces termes\u2009:</p> <p>Dans un syst\u00e8me, toute connaissance doit avoir une repr\u00e9sentation unique, non ambigu\u00eb, faisant autorit\u00e9.</p> <p>En d'autres termes, le programmeur doit avoir sans cesse \u00e0 l'esprit une sonnette d'alarme pr\u00eate \u00e0 vrombir lorsque qu'il presse machinalement Ctrl+C ( Cmd+C ) suivi de Ctrl+V ( Cmd+V ). Dupliquez du code et, quelle que soit l'envergure de texte concern\u00e9 est toujours une mauvaise pratique, car c'est le plus souvent le signe \u00e9vident d'un code smell indiquant que le code peut \u00eatre simplifi\u00e9 et optimis\u00e9.</p> <p>Le code suivant comprend une erreur DRY car la fonction display est appel\u00e9e deux fois. Dans les deux cas de figure, la fonction <code>display</code> re\u00e7oit un pointeur sur un fichier, il est donc possible de simplifier ce code.</p> <pre><code>FILE *fp = NULL;\nif (argc &gt; 1) {\n    fp = fopen(argv[1], \"r\");\n    display(fp);\n}\nelse {\n    display(stdin);\n}\n</code></pre> <p>Voici la version corrig\u00e9e\u2009:</p> <pre><code>FILE *fp = argc &gt; 1 ? fopen(argv[1], \"r\") : stdin;\ndisplay(fp);\n</code></pre> <p></p>"}, {"location": "course-c/50-philosophy/philosophy/#kiss_1", "title": "KISS", "text": "<p>Keep it simple, stupid est une ligne directrice de conception qui encourage la simplicit\u00e9 d'un d\u00e9veloppement. Elle est similaire au rasoir d'Ockham, mais plus commune en informatique. \u00c9nonc\u00e9 par Eric Steven Raymond puis par le Zen de Python un programme ne doit faire qu'une chose, et une chose simple. C'est une philosophie grandement respect\u00e9e dans l'univers Unix/Linux. Chaque programme de base du shell (<code>ls</code>, <code>cat</code>, <code>echo</code>, <code>grep</code>...) ne fait qu'une t\u00e2che simple, le nom est court et simple \u00e0 retenir.</p> <p>La fonction suivante n'est pas KISS car elle est responsable de plusieurs t\u00e2ches\u2009: v\u00e9rifier les valeurs d'un set de donn\u00e9e et les afficher\u2009:</p> <pre><code>int process(Data *data, size_t size) {\n    // Check consistency and display\n    for (int i = 0; i &lt; size; i++) {\n        if (data[i].value &lt;= 0)\n            data[i].value = 1;\n\n        printf(\"%lf\\n\", 20 * log10(data[i].value));\n    }\n}\n</code></pre> <p>Il serait pr\u00e9f\u00e9rable de la d\u00e9couper en deux sous-fonctions\u2009:</p> <pre><code>#define TO_LOG(a) (20 * log10(a))\n\nint fix_data(Data *data, const size_t size) {\n    for (int i = 0; i &lt; size; i++) {\n        if (data[i].value &lt;= 0)\n            data[i].value = 1;\n    }\n}\n\nint display(const Data *data, const size_t size) {\n    for (int i = 0; i &lt; size; i++)\n        printf(\"%lf\\n\", TO_LOG(data[i].value));\n}\n</code></pre> <p></p>"}, {"location": "course-c/50-philosophy/philosophy/#yagni_1", "title": "YAGNI", "text": "<p>YAGNI est un anglicisme de you ain't gonna need it qui peut \u00eatre traduit par\u2009: vous n'en aurez pas besoin. C'est un principe tr\u00e8s connu en d\u00e9veloppent Agile XP (Extreme Programming) qui stipule qu'un d\u00e9veloppeur logiciel ne devrait pas impl\u00e9menter une fonctionnalit\u00e9 \u00e0 un logiciel tant que celle-ci n'est pas absolument n\u00e9cessaire.</p> <p>Ce principe combat le biais du d\u00e9veloppeur \u00e0 vouloir sans cesse d\u00e9marrer de nombreux chantiers sans se focaliser sur l'essentiel strictement n\u00e9cessaire d'un programme et permettant de satisfaire au cahier des charges convenu avec le partenaire/client.</p> <p></p>"}, {"location": "course-c/50-philosophy/philosophy/#ssot_1", "title": "SSOT", "text": "<p>Ce principe tient son acronyme de single source of truth. Il adresse principalement un d\u00e9faut de conception relatif aux m\u00e9tadonn\u00e9es que peuvent \u00eatre les param\u00e8tres d'un algorithme, le mod\u00e8le d'une base de donn\u00e9es ou la m\u00e9thode usit\u00e9e d'un programme \u00e0 collecter des donn\u00e9es.</p> <p>Un programme qui respecte ce principe \u00e9vite la duplication des donn\u00e9es. Des d\u00e9fauts courants de conception sont\u2009:</p> <ul> <li> <p>indiquer le nom d'un fichier source dans le fichier source\u2009;</p> <pre><code>/**\n * @file main.c\n */\n</code></pre> </li> <li> <p>stocker la m\u00eame image, le m\u00eame document dans diff\u00e9rents formats\u2009;</p> <pre><code>convert input.jpg -resize 800x800 image-small.jpg\nconvert input.jpg -resize 400x400 image-smaller.jpg\nconvert input.jpg -resize 10x10 image-tiny.jpg\ngit add image-small.jpg image-smaller.jpg image-tiny.jpg\n</code></pre> </li> <li> <p>stocker dans une base de donn\u00e9es le nom Doe, pr\u00e9nom John ainsi que le nom complet\u2009;</p> <pre><code>INSERT INTO users (first_name, last_name, full_name)\nVALUES ('John', 'Doe', 'John Doe');\n</code></pre> </li> <li> <p>avoir un commentaire C ayant deux v\u00e9rit\u00e9s contradictoires\u2009;</p> <pre><code>int height = 206; // Size of Haf\u00fe\u00f3r J\u00fal\u00edus Bj\u00f6rnsson which is 205 cm\n</code></pre> </li> <li> <p>conserver une copie des m\u00eames donn\u00e9es sous des formats diff\u00e9rents (un tableau de donn\u00e9es brutes et un tableau des m\u00eames donn\u00e9es, mais tri\u00e9es).</p> <pre><code>ssconvert data.csv data.xlsx\nlibreoffice --headless --convert-to pdf fichier.csv\ngit add data.csv data.xlsx data.pdf # Beurk !\ngit commit -m \"Add all data formats\"\n</code></pre> </li> </ul>"}, {"location": "course-c/50-philosophy/philosophy/#zen-de-python", "title": "Zen de Python", "text": "<p>Python est un langage de programmation qui devient tr\u00e8s populaire, il est certes moins performant que C, mais il se veut \u00eatre de tr\u00e8s haut niveau.</p> <p>Le Zen de Python est un ensemble de 19 principes publi\u00e9s en 1999 par Tim Peters. Largement accept\u00e9 par la communaut\u00e9 de d\u00e9veloppeurs et il est connu sous le nom de PEP 20.</p> <p>Voici le texte original anglais\u2009:</p> <p>Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one\u2014and preferably only one\u2014obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than right now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea\u2014let's do more of those\u2009!</p> <p>Un code est meilleur s'il est beau, esth\u00e9tique, que les noms des variables, l'alignement et la mise en forme sont coh\u00e9rents et forment une unit\u00e9.</p> <p>Un code se doit \u00eatre explicite, et r\u00e9ellement traduire l'intention du d\u00e9veloppeur. Il est ainsi pr\u00e9f\u00e9rable d'\u00e9crire <code>u = v / 4</code> plut\u00f4t que <code>u &gt;&gt;= 2</code>. De la m\u00eame mani\u00e8re, d\u00e9tecter si un nombre est pair est plus explicite avec <code>if (n % 2 == 0)</code> que <code>if (n &amp; 1)</code>.</p>"}, {"location": "course-c/50-philosophy/philosophy/#the-code-taste", "title": "The code taste", "text": "<p>Dans une conf\u00e9rence TED en 2016, le cr\u00e9ateur de Linux, Linus Torvald \u00e9voqua un principe nomm\u00e9 code taste traduisible par avoir du go\u00fbt pour le code.</p> <p>Il \u00e9voqua l'exemple C suivant et demanda \u00e0 l'auditoire si ce code est de bon go\u00fbt\u2009:</p> <pre><code>void remove_list_entry(List* list, Entry* entry)\n{\n    Entry* prev = NULL;\n    Entry* walk = list-&gt;head;\n\n    while (walk != entry) {\n        prev = walk;\n        walk = walk-&gt;next;\n    }\n\n    if (!prev)\n        list-&gt;head = entry-&gt;next;\n    else\n        prev-&gt;next = entry-&gt;next;\n}\n</code></pre> <p>Il r\u00e9pondit que ce code est de mauvais go\u00fbt, qu'il est vilain et moche, car ce test plac\u00e9 apr\u00e8s la boucle <code>while</code> jure avec le reste du code et que parce que ce code semble laid, il doit y avoir une meilleure impl\u00e9mentation de meilleur go\u00fbt. On dit dans ce cas de figure que le code sent, ce test est de trop, et il doit y avoir un moyen d'\u00e9viter de traiter un cas particulier en utilisant un algorithme meilleur.</p> <p>Enlever un \u00e9l\u00e9ment d'une liste cha\u00een\u00e9e n\u00e9cessite de traiter deux cas\u2009:</p> <ul> <li>Si l'\u00e9l\u00e9ment est au d\u00e9but de la liste, il faut modifier <code>head</code></li> <li>Sinon il faut modifier l'\u00e9l\u00e9ment pr\u00e9c\u00e9dent <code>prev-&gt;next</code></li> </ul> <p>Apr\u00e8s avoir longuement questionn\u00e9 l'auditoire, il pr\u00e9sente cette nouvelle impl\u00e9mentation\u2009:</p> <pre><code>void remove_list_entry(List* list, Entry* entry)\n{\n    Entry** indirect = &amp;head;\n\n    while ((*indirect) != entry)\n        indirect = &amp;(*indirect)-&gt;next;\n\n    *indirect = entry-&gt;next;\n}\n</code></pre> <p>La fonction originale de 10 lignes de code a \u00e9t\u00e9 r\u00e9duite \u00e0 4 lignes et bien que le nombre de lignes compte moins que la lisibilit\u00e9 du code, cette nouvelle impl\u00e9mentation \u00e9limine le traitement des cas d'exception en utilisant un adressage indirect beaucoup plus \u00e9l\u00e9gant.</p> <p>N\u00e9anmoins, le n\u00e9ophyte en programmation C pourrait \u00eatre d\u00e9rout\u00e9 par l'usage de double pointeurs et trouverait que la premi\u00e8re impl\u00e9mentation est plus lisible. Cela souligne l'importance de la connaissance des structures de donn\u00e9es et des algorithmes pour \u00e9crire du code de qualit\u00e9, on ne s'improvise pas d\u00e9veloppeur\u00a0: c'est un art.</p> <p>Un autre exemple similaire et plus simple \u00e0 comprendre est pr\u00e9sent\u00e9 par Brian Barto sur un article publi\u00e9 sur Medium. Il donne l'exemple de l'initialisation \u00e0 z\u00e9ro de la bordure d'un tableau bidimensionnel\u2009:</p> <pre><code>for (size_t row = 0; row &lt; GRID_SIZE; ++row)\n{\n    for (size_t col = 0; col &lt; GRID_SIZE; ++col)\n    {\n        if (row == 0)\n            grid[row][col] = 0; // Top Edge\n\n        if (col == 0)\n            grid[row][col] = 0; // Left Edge\n\n        if (col == GRID_SIZE - 1)\n            grid[row][col] = 0; // Right Edge\n\n        if (row == GRID_SIZE - 1)\n            grid[row][col] = 0; // Bottom Edge\n    }\n}\n</code></pre> <p>On constate plusieurs fautes de go\u00fbt\u2009:</p> <ol> <li><code>GRID_SIZE</code> pourrait \u00eatre diff\u00e9rent de la r\u00e9elle taille de <code>grid</code></li> <li>Les valeurs d'initialisation sont dupliqu\u00e9es</li> <li>La complexit\u00e9 de l'algorithme est de \\(O(n^2)\\) alors que l'on ne s'int\u00e9resse qu'\u00e0 la bordure du tableau.</li> </ol> <p>Voici une solution plus \u00e9l\u00e9gante\u2009:</p> <pre><code>const size_t length = sizeof(grid[0]) / sizeof(grid[0][0]);\nconst int init = 0;\n\nfor (size_t i = 0; i &lt; length; i++)\n{\n    grid[i][0] = grid[0][i] = init; // Top and Left\n    grid[length - 1][i] = grid[i][length - 1] = init; // Bottom and Right\n}\n</code></pre>"}, {"location": "course-c/50-philosophy/philosophy/#lodeur-du-code-code-smell", "title": "L'odeur du code (code smell)", "text": "<p>Un code sent si certains indicateurs sont au rouge. On appelle ces indicateurs des antipatterns. Voici quelques indicateurs les plus courants\u2009:</p> <ul> <li> <p>Mastodonte Une fonction est plus longue qu'un \u00e9cran de haut (~50 lignes)</p> </li> <li> <p>Un fichier est plus long que 1000 lignes.</p> </li> <li> <p>Ligne Dieu, une ligne beaucoup trop longue et de facto illisible.</p> </li> <li> <p>Une fonction \u00e0 plus de trois param\u00e8tres</p> <pre><code>void make_coffee(int size, int mode, int mouture, int cup_size,\n    bool with_milk, bool cow_milk, int number_of_sugars);\n</code></pre> </li> <li> <p>Copier coller, du code est dupliqu\u00e9</p> </li> <li> <p>Les commentaires expliquent le comment du code et non le pourquoi</p> <pre><code>// Additionne une constante avec une autre pour ensuite l'utiliser\ndouble u = (a + cst);\nu /= 1.11123445143; // division par une constante inf\u00e9rieure \u00e0 2\n</code></pre> </li> <li> <p>Arbre de No\u00ebl, plus de deux structures de contr\u00f4les sont impliqu\u00e9es</p> <pre><code>if (a &gt; 2) {\n    if (b &lt; 8) {\n        if (c ==12) {\n            if (d == 0) {\n                exception(a, b, c, d);\n            }\n        }\n    }\n}\n</code></pre> </li> <li> <p>Usage de <code>goto</code></p> <pre><code>loop:\n    i +=1;\n    if (i &gt; 100)\n        goto end;\nhappy:\n    happy();\n    if (j &gt; 10):\n        goto sad;\nsad:\n    sad();\n    if (k &lt; 50):\n        goto happy;\nend:\n</code></pre> </li> <li> <p>Plusieurs variables avec des noms tr\u00e8s similaires</p> <pre><code>int advice = 11;\nint advise = 12;\n</code></pre> </li> <li> <p>Action \u00e0 distance par l'emploi immod\u00e9r\u00e9 de variables globales</p> <pre><code>void make_coffee() {\n    powerup_nuclear_reactor = true;\n    number_of_coffee_beans_to_harvest = 62;\n    ...\n}\n</code></pre> </li> <li> <p>Ancre de bateau, un composant inutilis\u00e9, mais gard\u00e9 dans le logiciel pour des raisons politiques (YAGNI)</p> </li> <li> <p>Cyclomatisme aigu, quand trop de structures de contr\u00f4les sont n\u00e9cessaires pour traiter un probl\u00e8me apparemment simple</p> </li> <li> <p>Attente active, une boucle qui ne contient qu'une instruction de test, attendant la condition</p> <pre><code>while (true) {\n    if (finished) break;\n}\n</code></pre> </li> <li> <p>Objet divin quand un composant logiciel assure trop de fonctions essentielles (KISS)</p> </li> <li> <p>Coul\u00e9e de lave lorsqu'un code immature est mis en production</p> <p>En novembre 1990 \u00e0 14h25, la soci\u00e9t\u00e9 AT&amp;T effecue une mise \u00e0 jour de son   r\u00e9seau t\u00e9l\u00e9phonique. Un bug dans le code de mise \u00e0 jour provoque un crash du   r\u00e9seau entra\u00eenant une interruption de service de 9 heures affectant quelque   50 millions d'appels et co\u00fbtant \u00e0 l'entreprise 60 millions de dollars. (Source\u00a0: The 1990 AT&amp;T Long Distance Network Collapse)</p> </li> <li> <p>Chirurgie au fusil de chasse quand l'ajout d'une fonctionnalit\u00e9 logicielle demande des changements multiples et disparates dans le code (Shotgun surgery).</p> </li> </ul>"}, {"location": "course-c/90-exercises/", "title": "Exercices de r\u00e9vision", "text": "<p>Exercise\u2009: Mot du jour</p> <p>\u00c9crire un programme qui retourne un mot parmi une liste de mot, de fa\u00e7on al\u00e9atoire.</p> <pre><code>#include &lt;time.h&gt;\n#include &lt;stdlib.h&gt;\n\nchar *words[] = {\"Alb\u00e9do\", \"Bigre\", \"Maringouin\", \"Pluripotent\", \"Entrechat\",\n    \"Caracoler\" \"Palinodie\", \"S\u00e9millante\", \"Atavisme\", \"Cyclothymie\",\n    \"Idiosyncratique\", \"Ent\u00e9l\u00e9chie\"};\n\n#if 0\n    srand(time(NULL));   // Initialization, should only be called once.\n    size_t r = rand() % sizeof(words) / sizeof(char*); // Generate random value\n#endif\n</code></pre> Solution <pre><code>#include &lt;time.h&gt;\n#include &lt;stdlib.h&gt;\n\nchar *words[] = {\n    \"Alb\u00e9do\", \"Bigre\", \"Maringouin\", \"Pluripotent\", \"Entrechat\",\n    \"Caracoler\" \"Palinodie\", \"S\u00e9millante\", \"Atavisme\", \"Cyclothymie\",\n    \"Idiosyncratique\", \"Ent\u00e9l\u00e9chie\"};\n\nint main(void)\n{\n    srand(time(NULL));\n    puts(words[rand() % (sizeof(words) / sizeof(char*))]);\n}\n</code></pre>"}, {"location": "course-cpp/garbage-collector/", "title": "Collecteur de d\u00e9chets (garbage collector)", "text": "<p>Le C est un langage primitif qui ne g\u00e8re pas automatiquement la lib\u00e9ration des ressources allou\u00e9es dynamiquement. L'exemple suivant est \u00e9vocateur\u2009:</p> <pre><code>int* get_number() {\n    int *num = malloc(sizeof(int));\n    *num = rand();\n}\n\nint main() {\n    for (int i = 0; i &lt; 100; i++) {\n        printf(\"%d\\n\", *get_number());\n    }\n}\n</code></pre> <p>La fonction <code>get_number</code> alloue dynamiquement un espace de la taille d'un entier et lui assigne une valeur al\u00e9atoire. Dans le programme principal, l'adresse retourn\u00e9e est d\u00e9r\u00e9f\u00e9renc\u00e9e pour \u00eatre affich\u00e9e sur la sortie standard.</p> <p>A la fin de l'ex\u00e9cution de la boucle for, une centaine d'espaces m\u00e9moire sont maintenant dans les limbes. Comme le pointeur retourn\u00e9 n'a jamais \u00e9t\u00e9 m\u00e9moris\u00e9, il n'est plus possible de lib\u00e9rer cet espace m\u00e9moire avec <code>free</code>.</p> <p>On dit que le programme \u00e0 une fuite m\u00e9moire. En admettant que ce programme reste r\u00e9sidant en m\u00e9moire, il peut arriver un moment o\u00f9 le programme peut aller jusqu'\u00e0 utiliser toute la RAM disponible. Dans ce cas, il est probable que <code>malloc</code> retourne <code>NULL</code> et qu'une erreur de segmentation apparaisse lors du <code>printf</code>.</p> <p>Allons plus loin dans notre exemple et consid\u00e9rons le code suivant\u2009:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint foo(int *new_value) {\n    static int *values[10] = { NULL };\n    static int count = 0;\n\n    if (rand() % 5 &amp;&amp; count &lt; sizeof(values) / sizeof(*values) - 1) {\n        values[count++] = new_value;\n    }\n\n    if (count &gt; 0)\n        printf(\"Foo aime %d\\n\", *values[rand() % count]);\n}\n\nint bar(int *new_value) {\n    static int *values[10] = { NULL };\n    static int count = 0;\n\n    if (rand() % 5 &amp;&amp; count &lt; sizeof(values) / sizeof(*values) - 1) {\n        values[count++] = new_value;\n    }\n\n    if (count &gt; 0)\n        printf(\"Bar aime %d\\n\", *values[rand() % count]);\n}\n\nint* get_number() {\n    int *number = malloc(sizeof(int));\n    *number = rand() % 1000;\n    return number;\n}\n\nint main() {\n    int experiment_iterations = 10;\n    for (int i = 0; i &lt; experiment_iterations; i++) {\n        int *num = get_number();\n        foo(num);\n        bar(num);\n        #if 0 // ...\n            free(num) ??\n        #endif\n    };\n}\n</code></pre> <p>La fonction <code>get_number</code> alloue dynamiquement un espace m\u00e9moire et assigne un nombre al\u00e9atoire. Les fonctions <code>foo</code> et <code>bar</code> re\u00e7oivent en param\u00e8tre un pointeur sur un entier. Chacune \u00e0 le choix de m\u00e9moriser ce pointeur et de clamer sur <code>stdout</code> qu'elle aime un des nombres m\u00e9moris\u00e9s.</p> <p>Au niveau du <code>#if 0</code> dans la fonction <code>main</code>, il est impossible de savoir si l'adresse point\u00e9e par <code>num</code> est encore utilis\u00e9e ou non. Il se peut que <code>foo</code> et <code>bar</code> utilisent cet espace m\u00e9moire, comme il se peut qu'aucun des deux ne l'utilise.</p> <p>Comment peut-on savoir si il est possible de lib\u00e9rer ou non <code>num</code> ?</p> <p>Une solution couramment utilis\u00e9e en C++ s'appelle un smart pointer. Il s'agit d'un pointeur qui contient en plus de l'adresse de la valeur, le nombre de r\u00e9f\u00e9rences utilis\u00e9es. De cette mani\u00e8re il est possible en tout temps de savoir si le pointeur est r\u00e9f\u00e9renc\u00e9 quelque part. Dans le cas o\u00f9 le nombre de r\u00e9f\u00e9rence tombe \u00e0 z\u00e9ro, il est possible de lib\u00e9rer la ressource.</p> <p>Dans un certain nombre de langage de programmation comme Python ou Java, il existe un m\u00e9canisme automatique nomm\u00e9 Garbage Collector et qui, p\u00e9riodiquement, fait un tour de toutes les allocations dynamique pour savoir si elle sont encore r\u00e9f\u00e9renc\u00e9es ou non. Le cas \u00e9ch\u00e9ant, le gc d\u00e9cide lib\u00e9rer la ressource m\u00e9moire. De cette mani\u00e8re il n'est plus n\u00e9cessaire de faire la chasse aux ressources allou\u00e9es.</p> <p>En revanche, en C, il n'existe aucun m\u00e9canisme aussi sophistiqu\u00e9 alors prenez garde \u00e0 bien lib\u00e9rer les ressources utilis\u00e9es et \u00e0 \u00e9viter d'\u00e9crire des fonctions qui allouent du contenu m\u00e9moire dynamiquement.</p>"}, {"location": "course-cpp/shared-memory/", "title": "Shared memory", "text": ""}, {"location": "course-cpp/shared-memory/#memoire-partagee", "title": "M\u00e9moire partag\u00e9e", "text": "<p>Nous le verrons plus loin au chapitre sur la MMU, mais la m\u00e9moire d'un processus m\u00e9moire (programme) ne peut pas \u00eatre acc\u00e9d\u00e9e par un autre programme. Le syst\u00e8me d'exploitation l'en emp\u00eache.</p> <p>Lorsque l'on souhaite communiquer entre plusieurs programmes, il est possible d'utiliser diff\u00e9rentes m\u00e9thodes\u2009:</p> <ul> <li>les flux (fichiers, stdin, stdout...)</li> <li>la m\u00e9moire partag\u00e9e</li> <li>les sockets</li> </ul> <p>Vous avez d\u00e9j\u00e0 vu les flux au chapitre pr\u00e9c\u00e9dent, et les sockets ne font pas partie de ce cours d'introduction.</p> <p>Notons que la m\u00e9moire partag\u00e9e est un m\u00e9canisme propre \u00e0 chaque syst\u00e8me d'exploitation. Sous POSIX elle est normalis\u00e9e et donc un programme compatible POSIX et utilisant la m\u00e9moire partag\u00e9e pourra fonctionner sous Linux, WSL ou macOS, mais pas sous Windows.</p> <p>C'est principalement l'appel syst\u00e8me <code>mmap</code> qui est utilis\u00e9. Il permet de mapper ou d\u00e9mapper des fichiers ou des p\u00e9riph\u00e9riques dans la m\u00e9moire.</p> <pre><code>void *mmap(\n    void *addr,\n    size_t length, // Size in bytes\n    int prot,      // Access protection (read/write/execute)\n    int flags,     // Attributs (shared/private/anonymous...)\n    int fd,\n    int offset\n);\n</code></pre> <p>Voici un exemple permettant de r\u00e9server un espace partag\u00e9 en \u00e9criture et en lecture entre deux processus\u2009:</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/mman.h&gt;\n\nvoid* create_shared_memory(size_t size) {\n    // Accessible en lecture et \u00e9criture\n    int protection = PROT_READ | PROT_WRITE;\n\n    // D'autres processus peuvent acc\u00e9der \u00e0 cet espace\n    // lequel est anonyme\n    // so only this process and its children will be able to use it:\n    int visibility = MAP_SHARED | MAP_ANONYMOUS;\n\n    // The remaining parameters to `mmap()` are not important for this use case,\n    // but the manpage for `mmap` explains their purpose.\n    return mmap(NULL, size, protection, visibility, -1, 0);\n}\n</code></pre>"}, {"location": "course-cpp/shared-memory/#file-memory-mapping", "title": "File memory mapping", "text": "<p>Traditionnellement lorsque l'on souhaite travailler sur un fichier, il convient de l'ouvrir avec <code>fopen</code> et de lire son contenu. Lorsque cela est n\u00e9cessaire, ce fichier est copi\u00e9 en m\u00e9moire\u2009:</p> <pre><code>FILE *fp = fopen(\"foo\", \"r\");\nfseek(fp, 0, SEEK_END);\nint filesize = ftell(fp);\nfseek(fp, 0, SEEK_SET);\nchar *file = malloc(filesize);\nfread(file, filesize, sizeof(char), fp);\nfclose(fp);\n</code></pre> <p>Cette copie n'est pas n\u00e9cessairement n\u00e9cessaire. Une approche POSIX, qui n'est donc pas couverte par le standard C99 consiste \u00e0 lier le fichier dans un espace m\u00e9moire partag\u00e9.</p> <p>Ceci n\u00e9cessite l'utilisation de fonctions bas niveau.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;sys/mman.h&gt;\n\nint main() {\n    int fd = open(\"foo.txt\", O_RDWR, 0600);\n    char *addr = mmap(NULL, 100, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);\n    printf(\"Espace mapp\u00e9 \u00e0 %p\\n\", addr);\n    printf(\"Premiers caract\u00e8res du fichiers : %.*s...\\n\", 20, addr);\n}\n</code></pre> <p>Les avantages de cette m\u00e9thode sont\u2009:</p> <ul> <li>pas n\u00e9cessaire de copier l'int\u00e9gralit\u00e9 du fichier en m\u00e9moire\u2009;</li> <li>possibilit\u00e9 de partager le m\u00eame fichier ouvert entre plusieurs processus\u2009;</li> <li>possibilit\u00e9 laiss\u00e9e au syst\u00e8me d'exploitation d'utiliser la RAM ou non si les ressources m\u00e9moires deviennent tendues.</li> </ul>"}, {"location": "summary/summary/", "title": "R\u00e9sum\u00e9", "text": ""}, {"location": "summary/summary/#introduction", "title": "Introduction", "text": "<p>Le langage C a cr\u00e9\u00e9 en 1972 par Brian Kernighan et Dennis Ritchie est s'est d\u00e8s lors impos\u00e9 comme le standard industriel pour la programmation embarqu\u00e9e et pour tout d\u00e9veloppement n\u00e9cessitant de hautes performances.</p> <p>Le langage est standardis\u00e9 par l'ISO (standardisation internationale) et le standard le plus couramment utilis\u00e9 en 2019 est encore C99.</p> <p>Il faut retenir que le C est un langage dit\u2009:</p> <ul> <li>Imp\u00e9ratif: programmation en s\u00e9quences de commandes</li> <li>Structur\u00e9: programmation imp\u00e9rative avec des structures de contr\u00f4le imbriqu\u00e9es</li> <li>Proc\u00e9dural: programmation imp\u00e9rative avec appels de proc\u00e9dures</li> </ul> <p>Ce sont ses paradigmes de programmation</p>"}, {"location": "summary/summary/#cycle-de-developpement", "title": "Cycle de d\u00e9veloppement", "text": "<p>Le cycle de d\u00e9veloppement se compose toujours des phases\u2009: \u00e9tude, \u00e9criture du cahier des charges, de l'\u00e9criture des tests, de la conception du logiciel, du codage \u00e0 proprement parler et des validations finales. Le mod\u00e8le en cascade est un bon r\u00e9sum\u00e9 tr\u00e8s utilis\u00e9 dans l'industrie\u2009:</p> <p>:::{figure} {assets}/figures/dist/software-life-cycle/waterfall.* Mod\u00e8le en cascade :::</p>"}, {"location": "summary/summary/#cycle-de-compilation", "title": "Cycle de compilation", "text": "<p>Faire \u00e9voluer un logiciel est aussi un processus it\u00e9ratif\u2009:</p> <ul> <li>Editer le code avec un \u00e9diteur comme <code>vi</code> ou <code>vscode</code></li> <li> Compilation et pr\u00e9traitement <code>console $ gcc -std=c99 -O2 -Wall -c foo.c -o foo.o $ gcc -std=c99 -O2 -Wall -c bar.c -o bar.o</code> </li> <li> Edition des liens <code>console $ gcc -o foobar foo.o bar.o -lm</code> </li> <li>Tests</li> </ul>"}, {"location": "summary/summary/#make", "title": "Make", "text": "<p>Souvent, pour s'\u00e9viter de r\u00e9p\u00e9ter les m\u00eames commandes les d\u00e9veloppeurs utilisent un outil comme <code>make</code> qui tire des r\u00e8gles de compilations d'un fichier nomm\u00e9 <code>Makefile</code>. Cet outil permet d'automatiquement recompiler les fichiers qui ne sont plus \u00e0 jour et r\u00e9g\u00e9n\u00e9rer automatiquement l'ex\u00e9cutable. Certaines recettes de <code>make</code> sont souvent utilis\u00e9es comme\u2009:</p> <ul> <li><code>make all</code> Pour compiler tout le projet</li> <li><code>make clean</code> Pour supprimer tous les fichiers interm\u00e9diaires g\u00e9n\u00e9r\u00e9s</li> <li><code>make mrproper</code> Pour supprimer tous les fichiers interm\u00e9diaires ainsi que les ex\u00e9cutables produits.</li> <li><code>make test</code> Pour ex\u00e9cuter les tests de validation</li> </ul> <p>D'autres recettes peuvent \u00eatre \u00e9crites dans le fichier <code>Makefile</code>, mais la courbe d'apprentissage du langage de <code>make</code> est raide.</p>"}, {"location": "summary/summary/#linuxposix", "title": "Linux/POSIX", "text": "<p>Un certain nombre de commandes sont utilis\u00e9es durant ce cours et voici un r\u00e9sum\u00e9 de ces derni\u00e8res</p> Commande Description <code>cat</code> Affiche sur <code>stdout</code> le contenu d'un fichier <code>ls</code> Liste le contenu du r\u00e9pertoire courant <code>ls -al</code> Liste le contenu du r\u00e9pertoire courant avec plus de d\u00e9tails <code>echo</code> Affiche sur <code>stdout</code> les \u00e9l\u00e9ments pass\u00e9s par argument au programme <code>make</code> Outil d'aide \u00e0 la compilation utilisant le fichier <code>Makefile</code> <code>gcc</code> Compilateur open source largement utilis\u00e9 dans l'industrie <code>vi</code> \u00c9diteur de texte ultra puissant, mais difficile \u00e0 apprendre"}, {"location": "summary/summary/#programmation", "title": "Programmation", "text": ""}, {"location": "summary/summary/#diagramme-de-flux", "title": "Diagramme de flux", "text": "<p>Le diagramme de flux est beaucoup utilis\u00e9 pour exprimer un algorithme comme celui d'Euclide pour chercher le plus grand diviseur commun.</p> <p>:::{figure} {assets}/figures/dist/algorithm/euclide-gcd.* Algorithme de calcul du PGCD d'Euclide. :::</p>"}, {"location": "summary/summary/#langage-c", "title": "Langage C", "text": ""}, {"location": "summary/summary/#caracteres-non-imprimables", "title": "Caract\u00e8res non imprimables", "text": "Expression Nom Nom anglais Description <code>\\n</code> <code>LF</code> Line feed Retour \u00e0 la ligne <code>\\v</code> <code>VT</code> Vertical tab Tabulation verticale (entre les paragraphes) <code>\\f</code> <code>FF</code> New page Saut de page <code>\\t</code> <code>TAB</code> Horizontal tab Tabulation horizontale <code>\\r</code> <code>CR</code> Carriage return Retour charriot <code>\\b</code> <code>BS</code> Backspace Retour en arri\u00e8re, effacement d'un caract\u00e8re"}, {"location": "summary/summary/#fin-de-lignes", "title": "Fin de lignes", "text": "<p>Les caract\u00e8res de fin de ligne d\u00e9pendent du syst\u00e8me d'exploitation et sont appel\u00e9s EOL: End Of Line.</p> Expression Nom Syst\u00e8me d'exploitation <code>\\r\\n</code> <code>CRLF</code> Windows <code>\\r</code> <code>CR</code> Anciens Macintoshs (\\&lt; 2000) <code>\\n</code> <code>LF</code> Linux/Unix/POSIX"}, {"location": "summary/summary/#identificateurs", "title": "Identificateurs", "text": "<p>:::{figure} {assets}/figures/dist/grammar/identifier.* Grammaire d'un identificateur C :::</p> <p>Le format des identificateurs peut \u00e9galement \u00eatre exprim\u00e9 par une expression r\u00e9guli\u00e8re\u2009:</p> <pre><code>^[a-zA-Z_][a-zA-Z0-9_]*$\n</code></pre>"}, {"location": "summary/summary/#variable", "title": "Variable", "text": "<p>Une variable poss\u00e8de 6 param\u00e8tres\u2009: nom, type, valeur, adresse, port\u00e9e, visibilit\u00e9.</p> <p>Elle peut \u00eatre\u2009: globale et dans ce cas elle est automatiquement initialis\u00e9e \u00e0 0\u2009:</p> <pre><code>int foo;\n\nint main(void) {\n    return foo;\n}\n</code></pre> <p>Ou elle peut \u00eatre locale et dans ce cas il est n\u00e9cessaire de l'initialiser \u00e0 une valeur\u2009:</p> <pre><code>int main(void) {\n    int foo = 0;\n    return foo;\n}\n</code></pre> <p>Il est possible de d\u00e9clarer plusieurs variables d'un m\u00eame type sur la m\u00eame ligne\u2009:</p> <pre><code>int i, j, k;\nint m = 32, n = 22;\n</code></pre> <p>Les conventions de nommage pour une variable sont\u2009: <code>camelCase</code> et <code>snake_case</code>, certains utilisent la notation <code>PascalCase</code>.</p> <p>Les termes <code>toto</code>, <code>tata</code>, <code>foo</code>, <code>bar</code> sont souvent utilis\u00e9s comme noms g\u00e9n\u00e9riques et sont appel\u00e9s termes m\u00e9tasyntaxiques.</p>"}, {"location": "summary/summary/#constantes-litterales", "title": "Constantes litt\u00e9rales", "text": "<p>Une constante litt\u00e9rale est une grandeur exprimant une valeur donn\u00e9e qui n'est pas calcul\u00e9e \u00e0 l'ex\u00e9cution\u2009:</p> Expression Type Description <code>6</code> <code>int</code> Valeur d\u00e9cimale <code>12u</code> <code>unsigned int</code> Valeur non sign\u00e9e en notation d\u00e9cimale <code>6l</code> <code>long</code> Valeur longue en notation d\u00e9cimale <code>010</code> <code>int</code> Valeur octale <code>0xa</code> <code>int</code> Valeur hexad\u00e9cimale <code>0b111</code> <code>int</code> Valeur binaire (uniquement <code>gcc</code>, pas standard C99) <code>12.</code> <code>double</code> Nombre r\u00e9el <code>'a'</code> <code>char</code> Caract\u00e8re <code>\"salut\"</code> <code>char*</code> Cha\u00eene de caract\u00e8re"}, {"location": "summary/summary/#commentaires", "title": "Commentaires", "text": "<p>Il existe deux types de commentaires\u2009:</p> <ul> <li>Les commentaires de lignes (depuis C99)</li> </ul> <pre><code>// This is a single line comment.\n</code></pre> <ul> <li>Les commentaires de blocs</li> </ul> <pre><code>/* This is a\n   Multi-line comment */\n</code></pre>"}, {"location": "summary/summary/#fonction-main", "title": "Fonction main", "text": "<p>La fonction main peut s'\u00e9rire sous deux formes\u2009:</p> <pre><code>int main(void) {\n    return 0;\n}\n</code></pre> <pre><code>int main(int argc, char *argv[]) {\n    return 0;\n}\n</code></pre>"}, {"location": "summary/summary/#numeration", "title": "Num\u00e9ration", "text": "<p>Les donn\u00e9es dans l'ordinateur sont stock\u00e9es sous forme binaire et le type d'une variable permet de d\u00e9finir son interpr\u00e9tation.</p> <ul> <li> Une valeur enti\u00e8re et non sign\u00e9e est exprim\u00e9e sous la forme binaire pure\u2009: <code>text \u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510 \u25020\u25021\u25020\u25021\u25020\u25020\u25021\u25021\u2502 = 0b1010011 = 83 \u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518</code> </li> <li> Une valeur enti\u00e8re et sign\u00e9e est exprim\u00e9e en compl\u00e9ment \u00e0 deux\u2009: <code>text \u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510     \u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510 \u25021\u25021\u25020\u25021\u25020\u25020\u25021\u25021\u2502 = ! \u25020\u25020\u25021\u25020\u25021\u25021\u25020\u25020\u2502 = (-1) * (0b101100 + 1) = -45 \u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518     \u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518</code> </li> <li> Une valeur r\u00e9elle ou flottante est exprim\u00e9e selon le standard IEEE-754 et comporte un bit de signe, un exposant et une mantisse. <code>\u250c Signe 1 bit \u2502        \u250c Exposant 8 bits \u2502        \u2502                             \u250c Mantisse 23 bits \u2534 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 \u251e\u2500\u2540\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\u250c\u2500\u2540\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2510\u250c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u252c\u2500\u2526 \u25020\u25020\u25020\u25021\u25020\u25020\u25020\u25020\u2502\u25020\u25021\u25020\u25020\u25021\u25020\u25020\u25020\u2502\u25021\u25021\u25020\u25021\u25021\u25021\u25021\u25021\u2502\u25020\u25021\u25020\u25020\u25020\u25020\u25020\u25021\u2502 \u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518\u2514\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2534\u2500\u2518</code> </li> </ul>"}, {"location": "summary/summary/#operateurs", "title": "Op\u00e9rateurs", "text": "<p>Les op\u00e9rateurs appliquent une op\u00e9ration entre une ou plusieurs valeurs\u2009:</p> <ul> <li>Les op\u00e9rateurs unaire s'appliquent \u00e0 un seul op\u00e9rande (<code>!12</code>, <code>~23</code>)</li> <li>Les op\u00e9rateurs standards s'appliquent \u00e0 deux op\u00e9randes (<code>12 ^ 32</code>)</li> </ul> <p>Les op\u00e9rateurs ont une priorit\u00e9 et une direction d'associativit\u00e9\u2009:</p> <pre><code>u = ++a + b * c++ &gt;&gt; 3 ^ 2\n\nRang  Op\u00e9rateur  Associativit\u00e9\n----  ---------  -------------\n 1    ()++       --&gt;\n 2    ++()       &lt;--\n 2    +          &lt;--\n 2    *          &lt;--\n 5    &gt;&gt;         --&gt;\n 9    ^          --&gt;\n14    =          --&gt;\n</code></pre> <p>Donc la priorit\u00e9 de ces op\u00e9rations sera\u2009:</p> <pre><code>(u = ((((++a) + (b * (c++))) &gt;&gt; 3) ^ 2))\n</code></pre> <p>Dans le cas des op\u00e9rateurs de pr\u00e9 et post incr\u00e9mentation, ils sont en effet les plus prioritaires mais leur action est d\u00e9cal\u00e9e dans le temps au pr\u00e9c\u00e9dent/suivant point de s\u00e9quence. C'est-\u00e0-dire\u2009:</p> <pre><code>a += 1;\n(u = (((a + (b * c)) &gt;&gt; 3) ^ 2));\nc += 1;\n</code></pre>"}, {"location": "summary/summary/#valeur-gauche", "title": "Valeur gauche", "text": "<p>Une valeur gauche lvalue d\u00e9fini ce qui peut se trouver \u00e0 gauche d'une affectation. C'est un terme qui appara\u00eet souvent dans les erreurs de compilation. L'exemple suivant retourne l'erreur\u2009: lvalue required as increment operand car le r\u00e9sultat de <code>a + b</code> n'a pas d'emplacement m\u00e9moire et il n'est pas possible de l'assigner \u00e0 quelque chose pour effectuer l'op\u00e9ration de pr\u00e9-incr\u00e9mentation.</p> <pre><code>c = ++(a + b);\n</code></pre> <p>Dans cet exemple <code>c</code> est une valeur gauche</p>"}, {"location": "summary/summary/#types-de-donnees", "title": "Types de donn\u00e9es", "text": "<p>Dans 90% des cas, voici les types qu'un d\u00e9veloppeur utilisera en C et sur le mod\u00e8le de donn\u00e9e LP64</p> Type Profondeur Description <code>char</code> 8-bit Caract\u00e8re ou valeur d\u00e9cimale <code>int</code> 32-bit Entier sign\u00e9 <code>unsigned int</code> 32-bit Entier non sign\u00e9 <code>long long</code> 64-bit Entier sign\u00e9 <code>float</code> 32-bit Nombre r\u00e9el (23 bit de mantisse) <code>double</code> 64-bit Nombre r\u00e9el (54 bit de mantisse) <p>Pour s'assurer d'une taille donn\u00e9e on peut utiliser les types standard C99 en incluant la biblioth\u00e8que <code>&lt;stdint.h&gt;</code></p> <pre><code>#include &lt;stdint.h&gt;\n\nint main(void) {\n    int8_t foo = 0;  // Valeur sign\u00e9e sur 8-bit\n    uint32_t bar = 0;  // Valeur non sign\u00e9e sur 32-bit\n\n    uint_least16_t = 0;  // Valeur non sign\u00e9e d'au moins 16-bit\n}\n</code></pre> <p>Les valeurs sign\u00e9es sont exprim\u00e9es en compl\u00e9ment \u00e0 deux c'est-\u00e0-dire que les valeurs maximales et minimales sont pour un entier 8-bit de <code>-128</code> \u00e0 <code>+128</code>.</p> <p>La construction des types standards\u2009:</p> <p>:::{figure} {assets}/figures/dist/datatype/ansi-integers.* :alt\u2009: \"Entiers standardis\\xE9s C89\" :width\u2009: 100 % :::</p> <p>La construction des types portables\u2009:</p> <p>:::{figure} {assets}/figures/dist/datatype/c99-integers.* :alt\u2009: \"Entiers standardis\\xE9s C99\" :width\u2009: 100 % :::</p>"}, {"location": "summary/summary/#caracteres", "title": "Caract\u00e8res", "text": "<p>Un caract\u00e8re est une valeur binaire cod\u00e9e sur 8-bit et dont l'interpr\u00e9tation est confi\u00e9e \u00e0 une table de correspondance nomm\u00e9e ASCII\u2009:</p> <p>:::{figure} {assets}/figures/dist/encoding/ascii.* Table ANSI INCITS 4-1986 (standard actuel) :::</p> <p>Seul ces valeurs sont garanties d'\u00eatre stock\u00e9es sur 8-bit. Pour les caract\u00e8res accentu\u00e9s ou les \u00e9motic\u00f4nes, la mani\u00e8re dont ils sont cod\u00e9s en m\u00e9moire d\u00e9pend de l'encodage des caract\u00e8res. Souvent on utilise le type d'encodage utf-8.</p> <p>Les \u00e9critures suivantes sont donc strictement identiques\u2009:</p> <pre><code>char a;\n\na = 'a';\na = 0x61;\na = 97;\na = 0141;\n</code></pre>"}, {"location": "summary/summary/#chaine-de-caractere", "title": "Cha\u00eene de caract\u00e8re", "text": "<p>Une cha\u00eene de caract\u00e8re est exprim\u00e9e avec des guillemets double. Une cha\u00eene de caract\u00e8re comporte toujours un caract\u00e8re terminal <code>\\0</code>.</p> <pre><code>char str[] = \"Hello\";\n</code></pre> <p>La taille en m\u00e9moire de cette cha\u00eene de caract\u00e8re est de 6 bytes, 5 caract\u00e8res et un caract\u00e8re de terminaison.</p>"}, {"location": "summary/summary/#booleens", "title": "Bool\u00e9ens", "text": "<p>En C la valeur <code>0</code> est consid\u00e9r\u00e9e comme fausse (false) et une valeur diff\u00e9rente de <code>0</code> est consid\u00e9r\u00e9e comme vraie (true). Toutes les assertions suivantes sont vraies\u2009:</p> <pre><code>if (42) { /* ... */ }\nif (!0) { /* ... */ }\nif (true &amp;&amp; true || false) { /* ... */ }\n</code></pre> <p>Pour utiliser les mots cl\u00e9s <code>true</code> et <code>false</code> il faut utiliser la biblioth\u00e8que <code>&lt;stdbool.h&gt;</code></p>"}, {"location": "summary/summary/#promotion-implicite", "title": "Promotion implicite", "text": "<p>Un type est automatiquement et tacitement promu dans le type le plus g\u00e9n\u00e9ral\u2009:</p> <pre><code>char a;\nint b;\nlong long c;\nunsigned int d;\n\na + b // R\u00e9sultat promu en `int`\na + c // R\u00e9sultat promu en `long long`\nb + d // R\u00e9sultat promu en `int`\n</code></pre> <p>Attention aux valeurs en virgule flottante\u2009:</p> <pre><code>int a = 9, b = 2;\ndouble b;\n\na / b;  // R\u00e9sultat de type entier, donc 4 et non 4.5\n(float)a / b;  // R\u00e9sultat de type float donc 4.5\nb / a;  // R\u00e9sultat en type double (promotion)\n</code></pre>"}, {"location": "summary/summary/#transtypage", "title": "Transtypage", "text": "<p>Pr\u00e9fixer une variable ou une valeur avec <code>(int)</code> comme dans\u2009: <code>(int)a</code> permet de convertir explicitement cette variable dans le type donn\u00e9.</p> <p>Le transtypage peut \u00eatre implicite par exemple dans <code>int a = 4.5</code></p> <p>Ou plus sp\u00e9cifiquement dans\u2009:</p> <pre><code>float u = 0.0;\nprintf(\"%f\", b); // Promotion implicite de `float` en `double`\n</code></pre>"}, {"location": "summary/summary/#structure-de-controle", "title": "Structure de contr\u00f4le", "text": ""}, {"location": "summary/summary/#sequence", "title": "S\u00e9quence", "text": "<p>Une s\u00e9quence est d\u00e9termin\u00e9e par un bloc de code entre accolades\u2009:</p> <pre><code>{\n    int a = 12;\n    b += a;\n}\n</code></pre>"}, {"location": "summary/summary/#si-sinon", "title": "Si, sinon", "text": "<pre><code>if (condition)\n{\n    // Si vrai\n}\nelse\n{\n    // Sinon\n}\n</code></pre>"}, {"location": "summary/summary/#si-sinon-si-sinon", "title": "Si, sinon si, sinon", "text": "<pre><code>if (condition)\n{\n    // Si vrai\n}\nelse if (autre_condition)\n{\n    // Sinon si autre condition valide\n}\nelse\n{\n    // Sinon\n}\n</code></pre>"}, {"location": "summary/summary/#boucle-for", "title": "Boucle For", "text": "<pre><code>for (int i = 0; i &lt; 10; i++)\n{\n    // Block ex\u00e9cut\u00e9 10 fois\n}\n\nk = i; // Erreur car `i` n'est plus accessible ici...\n</code></pre>"}, {"location": "summary/summary/#boucle-while", "title": "Boucle While", "text": "<pre><code>int i = 10;\n\nwhile (i &gt; 0) {\n    i--;\n}\n</code></pre>"}, {"location": "summary/summary/#programmes-et-processus", "title": "Programmes et Processus", "text": "\u00c9l\u00e9ment Description <code>stdin</code> Entr\u00e9e standard <code>stdout</code> Sortie standard <code>stderr</code> Sortie d'erreur standard <code>argc</code> Nombre d'arguments <code>argv</code> Valeurs des arguments <code>exit-status</code> Status de sortie d'un programme <code>$?</code> <code>signaux</code> Interaction avec le syst\u00e8me d'exploitation <p>:::{figure} {assets}/figures/dist/process/program.* R\u00e9sum\u00e9 des interactions avec un programme :::</p>"}, {"location": "summary/summary/#entrees-sorties", "title": "Entr\u00e9es Sorties", "text": ""}, {"location": "summary/summary/#printf", "title": "<code>printf</code>", "text": "<p>Les sorties format\u00e9es utilisent <code>printf</code> dont le format est\u2009:</p> <pre><code>%[parameter][flags][width][.precision][length]type\n</code></pre> <code>parameter</code> (optionnel) <p>Num\u00e9ro de param\u00e8tre \u00e0 utiliser</p> <code>flags</code> (optionnel) <p>Modificateurs\u2009: pr\u00e9fixe, signe plus, alignement \u00e0 gauche ...</p> <code>width</code> (optionnel) <p>Nombre minimum de caract\u00e8res \u00e0 utiliser pour l'affichage de la sortie.</p> <code>.precision</code> (optionnel) <p>Nombre minimum de caract\u00e8res affich\u00e9s \u00e0 droite de la virgule. Essentiellement, valide pour les nombres \u00e0 virgule flottante.</p> <code>length</code> (optionnel) <p>Longueur en m\u00e9moire. Indique la longueur de la repr\u00e9sentation binaire.</p> <code>type</code> <p>Type de formatage souhait\u00e9</p> <p>:::{figure} {assets}/figures/dist/string/formats.* Formatage d'un marqueur :::</p>"}, {"location": "summary/summary/#techniques-de-programmation", "title": "Techniques de programmation", "text": ""}, {"location": "summary/summary/#masque-binaire", "title": "Masque binaire", "text": "<p>Pour tester si un bit est \u00e0 un\u2009:</p> <pre><code>if (c &amp; 0x040)\n</code></pre> <p>Pour forcer un bit \u00e0 z\u00e9ro\u2009:</p> <pre><code>c &amp;= ~0x02;\n</code></pre> <p>Pour forcer un bit \u00e0 un\u2009:</p> <pre><code>c |= 0x02;\n</code></pre>"}, {"location": "summary/summary/#permuter-deux-variables-sans-valeur-intermediaire", "title": "Permuter deux variables sans valeur interm\u00e9diaire", "text": "<pre><code>a = b ^ c;\nb = a ^ c;\na = b ^ c;\n</code></pre>"}, {"location": "tools/bash/", "title": "Bash (Ligne de commande)", "text": "<p>La ma\u00eetrise de la ligne de commande n'est pas indispensable pour ce cours, mais la compr\u00e9hension de quelques commandes est utile pour bien comprendre les exemples donn\u00e9s.</p> <p>Dans un environnement POSIX l'interaction avec le syst\u00e8me s'effectue pour la plupart du temps via un terminal. Le programme utilis\u00e9 pour interagir avec le syst\u00e8me d'exploitation est appel\u00e9 un interpr\u00e9teur de commande. Sous Windows vous utilisez le programme <code>cmd.exe</code> ou <code>PowerShell.exe</code>. Sous Linux vous utilisez tr\u00e8s souvent un d\u00e9riv\u00e9 de Bourne shell nom \u00e9ponyme de Stephen Bourne et apparu en 1979. La compatibilit\u00e9 est toujours maintenue aujourd'hui via son successeur Bash dont le nom est un acronyme de Bourne-again shell.</p> <p>Bash est \u00e9crit en C et les sources sont naturellement disponibles sur internet. Lorsque vous lancez Bash, vous aurez un simple prompt\u2009:</p> <pre><code>$\n</code></pre> <p>Ce dernier vous invite \u00e0 taper une commande laquelle est le plus souvent le nom d'un programme. Voici un exemple\u2009:</p> <pre><code>$ cat foo.txt | hexdump -C -n100\n</code></pre>"}, {"location": "tools/bash/#navigation", "title": "Navigation", "text": "<p>Pour naviguer dans l'arborescence, le programme <code>cd</code> est utilis\u00e9. Il est l'acronyme de change directory. Ce programme prend en argument un chemin relatif ou absolu.</p> <pre><code>$ cd /usr\n/usr$ cd bin\n/usr/bin$ cd .\n/usr/bin$ cd ..\n/usr/$ cd /var/tmp\n/var/tmp$ cd\n~$\n</code></pre> <p>La derni\u00e8re commande est singuli\u00e8re\u2009: si <code>cd</code> est appel\u00e9 sans argument, il nous ram\u00e8ne dans notre r\u00e9pertoire personnel nomm\u00e9 home et abbr\u00e9g\u00e9 <code>~</code>.</p>"}, {"location": "tools/bash/#affichage", "title": "Affichage", "text": "<p>L'affichage du contenu courant de l'arborescence est possible avec le programme <code>ls</code> pour list structure.</p> <pre><code>$ ls /usr/bin/as*\n/usr/bin/as                 /usr/bin/asciitopgm     /usr/bin/assistant\n/usr/bin/asan_symbolize     /usr/bin/aspell         /usr/bin/asy\n/usr/bin/asan_symbolize-10  /usr/bin/aspell-import\n$ ls -al /usr/bin/as*\n-rwxr-xr-x 1 root root  38K 2020-04-20 07:12 /usr/bin/asan_symbolize-10\n-rwxr-xr-x 1 root root 9.9K 2016-04-23 13:53 /usr/bin/asciitopgm\n-rwxr-xr-x 1 root root 167K 2020-03-22 16:33 /usr/bin/aspell\n-rwxr-xr-x 1 root root 2.0K 2020-03-22 16:33 /usr/bin/aspell-import\nlrwxrwxrwx 1 root root    9 2020-03-22 16:55 /usr/bin/assistant -&gt; qtchooser\n-rwxr-xr-x 1 root root 4.3M 2020-02-10 15:52 /usr/bin/asy\n</code></pre> <p>On utilise souvent les options <code>a</code> (pour all) et <code>l</code> (pour long) permettant d'afficher les r\u00e9sultats avec plus de d\u00e9tails. Dans l'ordre on peut lire les permissions du fichier, le propri\u00e9taire, le groupe, la taille du fichier, sa date de derni\u00e8re modification et enfin son nom.</p>"}, {"location": "tools/bash/#pipe", "title": "Pipe", "text": "<p>Le signe pipe <code>|</code> permet de rediriger le flux de sortie d'un programme vers le flux d'entr\u00e9e d'un autre programme et ainsi les ex\u00e9cuter \u00e0 la cha\u00eene.</p> <p>% code-block\u2009::text % % $ echo \u00ab\u2009Bonjour\u2009\u00bb | cowsay</p> <p>Il se peut que vous souhaitiez rediriger la sortie d'erreur vers la sortie standard et ainsi concat\u00e9ner les deux flux sur l'entr\u00e9e standard d'un autre programme.</p> <p>% code-block\u2009::text % % $ echo \u00ab\u2009Bonjour\u2009\u00bb 2&gt;&amp;1 | cowsay</p>"}, {"location": "tools/config/", "title": "Fichiers de configuration", "text": ""}, {"location": "tools/config/#introduction", "title": "Introduction", "text": "<p>Dans un projet, vous aurez tr\u00e8s souvent un tas de fichiers de configuration. Ils commencent g\u00e9n\u00e9ralement par un point (<code>.</code>) pour les cacher dans le r\u00e9pertoire. C'est la mani\u00e8re dont les fichiers sont cach\u00e9s dans les syst\u00e8mes de fichiers Unix.</p>"}, {"location": "tools/config/#fichiers-populaires", "title": "Fichiers populaires", "text": ""}, {"location": "tools/config/#clang-format", "title": ".clang-format", "text": "<p>Ce fichier est au format YAML et contient des directives pour formater votre code automatiquement soit \u00e0 partir de VsCode si vous avez install\u00e9 l'extension Clang-Format et l'ex\u00e9cutable <code>clang-format</code> (<code>sudo apt install -y clang-format</code>). Clang-format est un utilitaire de la suite LLVM, proposant Clang un compilateur alternatif \u00e0 GCC.</p> <p>On voit que le texte pass\u00e9 sur <code>stdin</code> (jusqu'\u00e0 EOF) est ensuite format\u00e9 proprement\u2009:</p> <pre><code>$ clang-format --style=mozilla &lt;&lt;EOF\n#include &lt;stdio.h&gt;\nint\nmain\n()\n{printf(\"hello, world\\n\");}\nEOF\n#include &lt;stdio.h&gt;\nint\nmain()\n{\nprintf(\"hello, world\\n\");\n}\n</code></pre> <p>Par d\u00e9faut <code>clang-format</code> utilise le fichier de configuration nomm\u00e9 <code>.clang-format</code> qu'il trouve.</p> <p>Vous pouvez g\u00e9n\u00e9rer votre propre configuration facilement depuis un configurateur tel que clang-format configurator.</p>"}, {"location": "tools/config/#editor_config", "title": ".editor_config", "text": "<p>Ce fichier au format YAML permet de sp\u00e9cifier des recommandations pour l'\u00e9dition de fichiers sources. Vous pouvez y sp\u00e9cifier le type de fin de lignes CR ou CRLF, le type d'indentation (espaces ou tabulations) et le type d'encodage (ASCII ou UTF-8) pour chaque type de fichiers. EditorConfig est aujourd'hui support\u00e9 par la plupart des \u00e9diteurs de textes qui cherchent automatiquement un fichier de configuration nomm\u00e9 <code>.editor_config</code>.</p> <p>Dans Visual Studio Code, il faut installer l'extension EditorConfig for VS Code pour b\u00e9n\u00e9ficier de ce fichier.</p> <p>Pour les travaux pratiques, on se contente de sp\u00e9cifier les directives suivantes\u2009:</p> <pre><code>root = true\n\n[*]\nend_of_line = lf\ninsert_final_newline = true\nindent_style = space\nindent_size = 4\ncharset = utf-8\n\n[*.{json,yaml}]\nindent_style = space\nindent_size = 2\n\n[Makefile]\nindent_style = tab\n\n[*.{cmd,bat}]\nend_of_line = crlf\n</code></pre>"}, {"location": "tools/config/#gitattributes", "title": ".gitattributes", "text": "<p>Ce fichier permet \u00e0 Git de r\u00e9soudre certains probl\u00e8mes dans l'\u00e9dition de fichiers sous Windows ou POSIX lorsque le type de fichiers n'a pas le bon format. On se contente de d\u00e9finir quelle sera la fin de ligne standard pour certains types de fichiers\u2009:</p> <pre><code>* text=auto eol=lf\n*.{cmd,[cC][mM][dD]} text eol=crlf\n*.{bat,[bB][aA][tT]} text eol=crlf\n</code></pre>"}, {"location": "tools/config/#gitignore", "title": ".gitignore", "text": "<p>Ce fichier de configuration permet \u00e0 Git d'ignorer par d\u00e9faut certains fichiers et ainsi \u00e9viter qu'ils ne soient ajout\u00e9s par erreur au r\u00e9f\u00e9rentiel. Ici, on souhaite \u00e9viter d'ajouter les fichiers objets <code>.o</code> et les ex\u00e9cutables <code>*.out</code> :</p> <pre><code>*.out\n*.o\n*.d\n*.so\n*.lib\n</code></pre>"}, {"location": "tools/config/#vscodelaunchjson", "title": ".vscode/launch.json", "text": "<p>Ce fichier permet \u00e0 Visual Studio Code de savoir comment ex\u00e9cuter le programme en mode d\u00e9bogue. Il est au format JSON. Les lignes importantes sont <code>program</code> qui contient le nom de l'ex\u00e9cutable \u00e0 lancer <code>args</code> qui sp\u00e9cifie les arguments pass\u00e9s \u00e0 ce programme et <code>MiMode</code> qui est le nom du d\u00e9bogueur que vous utiliserez. Par d\u00e9faut nous utilisons GDB.</p> <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"Launch Main\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            \"program\": \"${workspaceFolder}/a.out\",\n            \"args\": [\"--foobar\", \"filename\", \"&lt;&lt;&lt;\", \"hello, world\"],\n            \"stopAtEntry\": true,\n            \"cwd\": \"${workspaceFolder}\",\n            \"environment\": [],\n            \"externalConsole\": false,\n            \"MIMode\": \"gdb\",\n            \"setupCommands\": [\n                {\n                    \"description\": \"Enable pretty-printing for gdb\",\n                    \"text\": \"-enable-pretty-printing\",\n                    \"ignoreFailures\": true\n                }\n            ],\n            \"preLaunchTask\": \"Build Main\"\n        }\n    ]\n}\n</code></pre>"}, {"location": "tools/config/#vscodetasksjson", "title": ".vscode/tasks.json", "text": "<p>Ce fichier contient les directives de compilation utilis\u00e9es par Visual Studio Code lors de l'ex\u00e9cution de la t\u00e2che build accessible par la touche <code>&lt;F5&gt;</code>. On y voit que la commande ex\u00e9cut\u00e9e est <code>make</code>. Donc la mani\u00e8re dont l'ex\u00e9cutable est g\u00e9n\u00e9r\u00e9 d\u00e9pend d'un <code>Makefile</code>.</p> <pre><code>{\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n        {\n            \"label\": \"Build Main\",\n            \"type\": \"shell\",\n            \"command\": \"make\",\n            \"group\": {\n                \"kind\": \"build\",\n                \"isDefault\": true\n            }\n        },\n        {\n            \"label\": \"Clean\",\n            \"type\": \"shell\",\n            \"command\": \"make clean\"\n        }\n    ]\n}\n</code></pre>"}, {"location": "tools/environment/", "title": "L'environnement de travail", "text": "<p>Vous \u00eates \u00e9tudiant et vous \u00eates perdus avec l'utilisation de Python, LaTeX, Git, etc. sous Windows, Linux ou encore Docker Ce document est fait pour vous. Il vous guidera dans l'installation et l'utilisation de ces outils. L'objectif est de comprendre les avantages et les inconv\u00e9nients de chaque outil et de vous permettre de les utiliser de mani\u00e8re efficace.</p>"}, {"location": "tools/environment/#preambule", "title": "Pr\u00e9ambule", "text": "<p>Les applications utilis\u00e9es typiquement par un ing\u00e9nieur aujourd'hui sont Python, Git, GCC, LaTeX ou m\u00eame Docker. Ces applications ont un point commun, c'est qu'elles ont d'abord \u00e9t\u00e9 \u00e9crites pour un environnement POSIX (Unix).</p> <p>POSIX est une norme internationale (IEEE 1003) qui d\u00e9finit l'interface de programmation d'un syst\u00e8me d'exploitation. Elle est bas\u00e9e sur UNIX. Elle est utilis\u00e9e pour les syst\u00e8mes d'exploitation de type UNIX. Windows n'est pas un syst\u00e8me qui respecte cette norme ce qui complique l'utilisation de ces applications.</p> <p>Afin de pouvoir porter Python ou Git sous Windows, il a fallu ajouter une couche d'abstraction pour rendre compatible le monde Linux avec le monde Windows. Historiquement le projet Cygwin n\u00e9 en 1995 a \u00e9t\u00e9 le premier \u00e0 proposer une telle couche. Il s'agissait d'un environnement POSIX pour Windows muni d'un terminal, d'un gestionnaire de paquets et d'une biblioth\u00e8que d'\u00e9mulation POSIX. Les outils en ligne de commande type <code>ls</code>, <code>cat</code> ou m\u00eame <code>grep</code> \u00e9taient propos\u00e9s. N\u00e9anmoins, Cygwin n'\u00e9tait pas parfait, il n\u00e9cessitait son propre environnement de travail et n'\u00e9tait pas bien int\u00e9gr\u00e9 \u00e0 Windows. Le projet MSYS a \u00e9t\u00e9 cr\u00e9\u00e9 en 2003 pour pallier \u00e0 ces probl\u00e8mes. Il s'agissait d'une couche d'abstraction POSIX pour Windows qui se voulait plus l\u00e9g\u00e8re. Au lieu de compiler des applications Linux qui devaient imp\u00e9rativement \u00eatre lanc\u00e9es sous Cygwin, MSYS int\u00e9grait la couche d'abstraction dans les applications elles-m\u00eames, ces derni\u00e8res \u00e9taient compil\u00e9es en <code>.exe</code> et pouvaient \u00eatre lanc\u00e9es directement depuis l'explorateur Windows. MSYS a \u00e9t\u00e9 un franc succ\u00e8s et a \u00e9t\u00e9 int\u00e9gr\u00e9 dans le projet MinGW (Minimalist GNU for Windows) qui est un portage de GCC pour Windows.</p> <p>Lorsque vous installez <code>Git</code> sous Windows et que vous visitez l'emplacement d'installation (<code>C:\\Program Files\\Git</code>), vous verrez des dossiers aux noms compatibles <code>POSIX</code> comme <code>bin</code>, <code>etc</code>, <code>lib</code>, <code>usr</code>, etc. Le dossier <code>bin</code> qui contient les ex\u00e9cutables contient <code>bash</code> qui n'est rien d'autre que le terminal utilis\u00e9 sous Linux. La raison est que <code>Git</code> ou m\u00eame <code>Python</code> sont des outils avant tout d\u00e9velopp\u00e9s pour les environnements Unix/Linux.</p> <p>Le choix de l'environnement de travail est donc compliqu\u00e9. Faut-il travailler sous Windows avec les limitations que le portage des applications Linux implique ou faut-il travailler sous Linux directement\u2009? Un ing\u00e9nieur reste  aujourd'hui attach\u00e9 au monde Windows car il d\u00e9pend de logiciels comme <code>SolidWorks</code> ou <code>Altium Designer</code> qui ne sont pas disponibles sous Linux. Il est donc n\u00e9cessaire de trouver un compromis.</p> <p>En 2016, Microsoft a annonc\u00e9 le support de Linux dans Windows 10. Il s'agissait d'une couche d'abstraction qui permettait de faire tourner des applications Linux directement sous Windows. Cette couche d'abstraction s'appelle Windows Subsystem for Linux (WSL). Elle est bas\u00e9e sur une technologie de virtualisation de conteneurs. WSL a \u00e9t\u00e9 un franc succ\u00e8s et il a tr\u00e8s vite \u00e9t\u00e9 adopt\u00e9 par les d\u00e9veloppeurs Web. Il fut de surcro\u00eet propos\u00e9 comme une alternative \u00e0 Cygwin et MSYS.</p> <p>WSL a \u00e9t\u00e9 am\u00e9lior\u00e9 au fil des ann\u00e9es et en 2019, Microsoft a annonc\u00e9 WSL 2. WSL 2 est bas\u00e9 sur une technologie de virtualisation de type 2 (hyperviseur) et non plus de type 1 (noyau Linux). WSL 2 est donc plus performant que WSL 1. Il est possible de faire tourner un serveur web ou m\u00eame un serveur de base de donn\u00e9es directement sous WSL 2. WSL 2 est maintenant une alternative cr\u00e9dible \u00e0 Linux.</p> <p>Il rend possible de travailler sous Windows et de faire tourner des applications Linux directement sous Windows.</p> <p>Le choix donn\u00e9 aux ing\u00e9nieurs est donc\u2009:</p> <ol> <li>Choix facile mais source d'incoh\u00e9rences: Travailler exclusivement sous Windows et installer <code>Python</code>, <code>Git</code>, <code>LaTeX</code> sous Windows. L'inconv\u00e9nient est que chacune de ses applications ne profitent pas d'une unit\u00e9 de travail commune. A force d'installer des applications, vous aurez dans votre syst\u00e8me plusieurs installation de Python, plusieurs ex\u00e9cutables Git ce qui peut vite devenir compliqu\u00e9 \u00e0 g\u00e9rer.</li> <li>Choix plus difficile mais offrant davantage de flexibilit\u00e9: Travailler sous WSL 2 et de faire tourner <code>Python</code>, <code>Git</code>, <code>LaTeX</code> sous Linux. L'avantage est que vous aurez une unit\u00e9 de travail commune. Vous pourrez installer des applications Linux directement depuis le gestionnaire de paquets de votre distribution Linux. N\u00e9anmoins vous devrez vous familiariser avec la ligne de commande Linux.</li> </ol>"}, {"location": "tools/environment/#le-terminal", "title": "Le terminal", "text": "<p>Historiquement sous Windows, le terminal \u00e9tait une application graphique appel\u00e9e <code>cmd</code>. Elle n'a pas \u00e9volu\u00e9e depuis Windows NT. Son interface est limit\u00e9e \u00e0 un nombre fini de caract\u00e8res par ligne et ne supportait que quelques couleurs. Elle ne supportait pas les caract\u00e8res Unicode et ne supportait pas les raccourcis clavier comme <code>Ctrl+C</code> ou <code>Ctrl+V</code>.</p> <p>Heursement Windows a \u00e9volu\u00e9 et propose PowerShell. PowerShell est un terminal plus moderne qui supporte les couleurs, les raccourcis clavier, les caract\u00e8res Unicode, etc. PowerShell est un terminal plus puissant que <code>cmd</code>.</p> <p>L'interface du terminal \u00e9tait \u00e9galement rudimentaire (pas d'onglets, pas de s\u00e9parateurs, etc.). Heureusement Windows propose depuis 2019 Windows Terminal. Windows Terminal est un terminal moderne multi-onglets qui supporte plusieurs terminaux (cmd, PowerShell, WSL, etc.). S'il n'est pas install\u00e9 vous pouvez le faire via le Microsoft Store.</p> <p> Interface de cmd.exe dans Windows Terminal</p> <p> Interface de PowerShell dans Windows Terminal</p> <p> Interface de Ubuntu dans Windows Terminal</p>"}, {"location": "tools/environment/#variables-denvironnement", "title": "Variables d'environnement", "text": "<p>Que vous soyez sous POSIX ou Windows, votre syst\u00e8me d'exploitation dispose de variables d'environnement. Il s'agit de variables qui sont accessibles par toutes les applications. Elles sont utilis\u00e9es pour stocker des informations comme le chemin d'acc\u00e8s \u00e0 un ex\u00e9cutable, le nom de l'utilisateur, le r\u00e9pertoire de travail, etc.</p> <p>La variable la plus importante est <code>PATH</code>. Elle contient une liste de chemins d'acc\u00e8s aux ex\u00e9cutables. Lorsque vous tapez une commande dans un terminal, le syst\u00e8me d'exploitation parcourt les chemins d'acc\u00e8s de la variable <code>PATH</code> pour trouver l'ex\u00e9cutable correspondant \u00e0 la commande. Si vous avez install\u00e9 Python, Git, LaTeX, etc. dans des r\u00e9pertoires diff\u00e9rents, il est n\u00e9cessaire de les ajouter \u00e0 la variable <code>PATH</code>. Parfois les installateurs le font automatiquement, parfois non. Il est donc n\u00e9cessaire de v\u00e9rifier manuellement.</p> <p>Une variable d'environnement n'est propag\u00e9e \u00e0 un processus que si ce dernier est lanc\u00e9 apr\u00e8s la modification de la variable. Si vous modifiez la variable <code>PATH</code> les processus d\u00e9j\u00e0 lanc\u00e9s ne verront pas la modification. Il est n\u00e9cessaire de fermer le terminal et de le rouvrir (relancer Visual Studio Code, votre terminal, etc.).</p> <p>Parfois si vous installez plusieurs version d'un m\u00eame logiciel comme <code>Python</code> vous pourriez avoir plusieurs variables d'environnement qui pointent vers des versions diff\u00e9rentes de Python. C'est une source de confusion et c'est un probl\u00e8me fr\u00e9quent sous Windows. Vous pouvez v\u00e9rifier quel est le chemin d'acc\u00e8s \u00e0 un ex\u00e9cutable avec la commande <code>where</code> sous Windows et <code>which</code> sous Linux.</p> Linux/WSL/MacOSWindows CMDPowerShell <pre><code>$ which python\n/usr/bin/python\n</code></pre> <pre><code>PS C:\\&gt; where python\nC:\\Python39\\python.exe\n</code></pre> <pre><code>PS C:\\&gt; Get-Command python\n</code></pre>"}, {"location": "tools/environment/#latex", "title": "LaTeX", "text": "<p>Sous Linux/WSL, le plus simple est d'installer LaTeX avec le gestionnaire de paquets de votre distribution Linux. Ouvrez un terminal et tapez la commande suivante\u2009:</p> <pre><code>sudo apt install texlive-full latexmk\n</code></pre> <p>Sous Windows c'est plus compliqu\u00e9. Il existe plusieurs distributions LaTeX pour Windows. La plus courante est MiKTeX. T\u00e9l\u00e9chargez l'installateur et suivez les instructions.</p>"}, {"location": "tools/environment/#commandes-principales", "title": "Commandes principales", "text": ""}, {"location": "tools/environment/#gcc", "title": "GCC", "text": "Commande Description <code>gcc</code> Compilateur C <code>g++</code> Compilateur C++ <code>make</code> Gestionnaire de compilation <p>Pour compiler un programme\u2009:</p> CC++Plusieurs fichiers CCompilation s\u00e9par\u00e9e <pre><code>gcc -o hello hello.c\n</code></pre> <pre><code>g++ -o hello hello.cpp\n</code></pre> <pre><code>gcc -o hello main.c functions.c\n</code></pre> <pre><code>gcc -c functions.c\ngcc -c main.c\ngcc -o hello main.o functions.o\n</code></pre>"}, {"location": "tools/environment/#linuxwsl", "title": "Linux/WSL", "text": "Commande Description <code>ls</code> Liste les fichiers du r\u00e9pertoire courant <code>cd</code> Change de r\u00e9pertoire <code>pwd</code> Affiche le r\u00e9pertoire courant <code>cat</code> Affiche le contenu d'un fichier <code>less</code> Affiche le contenu d'un fichier page par page <code>grep</code> Recherche une cha\u00eene de caract\u00e8res dans un fichier <code>find</code> Recherche un fichier dans un r\u00e9pertoire <code>man</code> Affiche le manuel d'une commande <code>which</code> Affiche le chemin d'acc\u00e8s \u00e0 un ex\u00e9cutable"}, {"location": "tools/environment/#afficher-les-fichiers-du-repertoire-courant", "title": "Afficher les fichiers du r\u00e9pertoire courant", "text": "<pre><code>ls -al # Par noms\nls -lt # Par date de modification\nls -lh # En format lisible\n</code></pre>"}, {"location": "tools/environment/#python", "title": "Python", "text": "Commande Description <code>python</code> Lance l'interpr\u00e9teur Python <code>pip</code> Gestionnaire de paquets Python <code>ipython</code> Lance l'interpr\u00e9teur IPython <code>jupyter lab</code> Lance l'environnement Jupyter Lab"}, {"location": "tools/environment/#latex_1", "title": "LaTeX", "text": "Commande Description <code>latexmk -xelatex</code> Compile un document LaTeX"}, {"location": "tools/filesystem/", "title": "Syst\u00e8me de fichier", "text": ""}, {"location": "tools/filesystem/#introduction", "title": "Introduction", "text": "<p> Fourmi portant des donn\u00e9es</p> <p>Un syst\u00e8me de fichier est une structure de donn\u00e9es qui permet de stocker des fichiers et des r\u00e9pertoires sur un support de stockage. Les syst\u00e8mes de fichiers sont utilis\u00e9s pour organiser les donn\u00e9es sur les disques durs, les cl\u00e9s USB, les cartes m\u00e9moire, etc.</p> <p>Nous savons maintenant que les donn\u00e9es informatiques sont stock\u00e9es sous forme binaire. Sur une cl\u00e9 USB ou un disque dur, c'est pareil. On aura des 0 et des 1 stock\u00e9s \u00e0 perte de vue sur le silicium. Si votre disque dur de 1 Tio est la surface de la terre, sans les oc\u00e9ans et d'environ \\(148.9\\) millions de \\(\\text{km}^2\\). Notre disque contient \\(2^{40}\\) octets, soit \\(2^{43}\\) bits\u2009:</p> \\[ N_{bits} = 8'796'093'022'208 \\] <p>Cela revient \u00e0 stocker environ 16 bits par millim\u00e8tre carr\u00e9. Une fourmi aurait sur son dos 2 \u00e0 3 octets de donn\u00e9es. Imaginez vous un instant prendre l'avion, le train, rev\u00eatir votre tenue d'explorateur pour chercher les fourmis qui portent les donn\u00e9es que vous cherchez\u2009?</p> <p>Oui ce n'est pas tr\u00e8s r\u00e9aliste, et le calcul que nous avons fourni est tr\u00e8s simplifi\u00e9. Mais cela permet de comprendre que les donn\u00e9es stock\u00e9es doivent \u00eatre organis\u00e9es car elles ne sont pas accessibles imm\u00e9diatement. Pour un disque dur, la t\u00eate de lecture doit parcourir le disque pour atteindre les donn\u00e9es. Sur une cl\u00e9 USB, la m\u00e9moire doit \u00eatre configur\u00e9e pour acc\u00e9der une r\u00e9gion pr\u00e9cise.</p> <p>Nous avons donc besoin d'une carte pour savoir o\u00f9 sont stock\u00e9es les donn\u00e9es. C'est le r\u00f4le du syst\u00e8me de fichier. Il permet de stocker les fichiers, les organiser en dossiers. N'importe qui n'aura pas acc\u00e8s \u00e0 toutes les donn\u00e9es, il faut les droits d'acc\u00e8s. Et les donn\u00e9es peuvent \u00eatre corrompues, d\u00e9truites par des rayonnements cosmiques. Il faut aussi g\u00e9rer les erreurs.</p> <p>Le premier syst\u00e8me de fichier a \u00e9t\u00e9 invent\u00e9 par IBM en 1956 pour le disque dur IBM 305 RAMAC. Il s'appelait le syst\u00e8me de fichier \u00e0 index. Il a \u00e9t\u00e9 invent\u00e9 par Hans Peter Luhn. Il permettait de stocker 5 Mo de donn\u00e9es sur un disque de 24 pouces. Depuis</p>"}, {"location": "tools/filesystem/#fat-et-les-autres", "title": "FAT et les autres", "text": "<p>Le syst\u00e8me de fichier FAT (File Allocation Table) est un syst\u00e8me de fichier simple et robuste. Il a \u00e9t\u00e9 invent\u00e9 par Microsoft en 1977 pour le syst\u00e8me d'exploitation MS-DOS. Il est toujours utilis\u00e9 aujourd'hui pour les cl\u00e9s USB, les cartes m\u00e9moire, etc. C'est tr\u00e8s certainement celui-ci qu'un ing\u00e9nieur embarqu\u00e9 utiliserait sur une carte SD interfac\u00e9e avec un microcontr\u00f4leur.</p> <p>L'API de FAT, c'est \u00e0 dire les fonctions primitives pour contr\u00f4ler le syst\u00e8me de fichier contient par exemple les fonctions suivantes\u2009:</p> <ul> <li><code>fopen</code> : Ouvrir un fichier \u00e0 partir d'un chemin</li> <li><code>fread</code> : Lire de donn\u00e9es depuis un fichier ouvert</li> <li><code>fseek</code> : Se d\u00e9placer dans un fichier ouvert</li> <li><code>fsize</code> : Obtenir la taille d'un fichier</li> <li><code>fopendir</code> : Ouvrir un r\u00e9pertoire</li> <li><code>frename</code> : Renommer un fichier</li> <li><code>fmkdir</code> : Cr\u00e9er un r\u00e9pertoire</li> <li>...</li> </ul> <p>Les syst\u00e8mes de fichiers les plus utilis\u00e9s aujourd'hui sont\u2009:</p> Syst\u00e8me de fichier Ann\u00e9e Utilisation FAT 1977 Cl\u00e9s USB, cartes m\u00e9moire FAT32 1996 Disques durs NTFS 1993 Windows ext4 2006 Linux APFS 2017 macOS Btrfs 2009 Linux ZFS 2005 Solaris, FreeBSD"}, {"location": "tools/filesystem/#organisation", "title": "Organisation", "text": "<p>Un syst\u00e8me de fichier comporte en g\u00e9n\u00e9ral\u2009:</p> <ul> <li>Des r\u00e9pertoires (des dossiers) qui contiennent des fichiers ou d'autres r\u00e9pertoires.</li> <li>Des fichiers qui contiennent des donn\u00e9es.</li> </ul> <p>Les r\u00e9pertoires sont organis\u00e9s en arborescence de mani\u00e8re hi\u00e9rarchique. Si vous avez dans votre maison, dans votre cuisine, dans votre frigo, au second rayonnage, sur la droite, une pomme. Vous pourriez \u00e9crire\u2009:</p> <pre><code>maison -&gt; cuisine -&gt; frigo -&gt; rayonnage2 -&gt; droite -&gt; pomme\n</code></pre> <p>Mais la pomme est un fruit, comment le savoir avec seulement un nom. C'est peut-\u00eatre une pomme de terre, une pomme de pin ou une pomme de douche. G\u00e9n\u00e9ralement, on ajoute une extension, c'est un suffixe qui permet de savoir de quel type de fichier il s'agit. Par exemple, <code>.txt</code> pour un fichier texte, <code>.jpg</code> pour une image, <code>.c</code> pour un fichier source en langage C, etc.</p> <p>Enfin, utiliser <code>-&gt;</code> pour indiquer la hi\u00e9rarchie n'est pas pratique. Tous les syst\u00e8mes de fichiers du monde utilisent le slash <code>/</code> pour s\u00e9parer les r\u00e9pertoires. Tous... sauf un qui r\u00e9siste encore et toujours \u00e0 l'envahisseur. Sur Windows, la convention est diff\u00e9rente, et c'est le backslash qui est utilis\u00e9 <code>\\</code>. C'est une source de confusion pour les d\u00e9veloppeurs qui doivent \u00e9crire des programmes compatibles avec les deux syst\u00e8mes d'exploitation.</p> <p>Reprenons. Notre pomme serait un fruit, une image de fruit. On indiquerait alors son chemin complet\u2009:</p> <pre><code>/maison/cuisine/frigo/rayonnage2/droite/pomme.jpg\n</code></pre> <p>Tient\u2009? Pourquoi un <code>slash</code> au d\u00e9but\u2009? C'est pour indiquer le r\u00e9pertoire racine\u2009: le r\u00e9pertoire d'origine, le point de d\u00e9part de l'arborescence. Evidemment si vous vous trouvez d\u00e9j\u00e0 dans la cuisine, vous n'avez pas besoin de pr\u00e9ciser <code>/maison/cuisine</code>. Vous pouvez simplement \u00e9crire <code>frigo/rayonnage2/droite/pomme.jpg</code>. Donc un chemin peut, ou non avoir un <code>slash</code> au d\u00e9but. On dit qu'il est absolu ou relatif.</p> <p>Windows</p> <p>Sur Windows, le r\u00e9pertoire racine est <code>C:\\</code> pour le disque dur principal. Donc un chemin absolu sur Windows ressemblerait \u00e0 <code>C:\\maison\\cuisine\\frigo\\rayonnage2\\droite\\pomme.jpg</code>.</p> <p>L'usage de <code>C</code> est historique. \u00c0 l'origine il n'y avait pas de disques durs mais des disquettes. Ceux qui avaient la chance d'avoir un lecteur de disquette avaient un unique lecteur <code>A</code>. Ceux qui voulaient faire des copies de disquettes devaient en avoir un deuxi\u00e8me, c'\u00e9tait le lecteur <code>B</code>. En g\u00e9n\u00e9ral, le disque dur \u00e9tait le troisi\u00e8me lecteur, le lecteur <code>C</code>. Et depuis Windows 95, c'est rest\u00e9 comme \u00e7a.</p>"}, {"location": "tools/filesystem/#navigation", "title": "Navigation", "text": "<p>Nous savons qu'un chemin est une suite de r\u00e9pertoires s\u00e9par\u00e9s par des slashes mais ce que nous ne savons pas c'est o\u00f9 on se trouve. Lorsque vous ouvrez un terminal, ou une application vous \u00eates dans un r\u00e9pertoire, c'est le r\u00e9pertoire courant, ou le r\u00e9pertoire de travail (working directory). Pour savoir o\u00f9 vous trouvez vous pouvez ouvrir un terminal et taper\u2009:</p> POSIXWindows <pre><code>$ pwd\n/home/username\n</code></pre> <pre><code>&gt; cd\nC:\\Users\\username\n</code></pre> <p>Mais si je suis dans la maison et que je veux aller dans le jardin\u2009? Je ne vais pas indiquer le chemin complet\u2009:</p> <pre><code>/universe/\n    galaxy/\n        solar-system/\n            earth/\n                europe/\n                    switzerland/\n                        vaud/\n                            yverdon-les-bains/\n                                maison/\n                                    jardin\n</code></pre> <p>Je ne peux pas non plus utiliser le chemin relatif <code>jardin</code> car le jardin n'est pas dans la maison. Ni d'ailleurs <code>/jardin</code> car celui-ci n'est pas \u00e0 la racine de l'univers. On voit qu'il est essentiel d'introduire une notion de parent\u00e9\u2009; ce que je souhaite faire c'est remonter d'un niveau pour aller dans le jardin.</p> <p>Il existe un fichier sp\u00e9cial qui permet de remonter d'un niveau c'est le fichier <code>..</code>.</p> <p>Et si je suis dans le jardin et que j'aimerais tondre la pelouse. J'aimerais appeler le programme <code>tondre</code> en lui donnant le chemin jusque l\u00e0 o\u00f9 je me trouve. Je pourrais \u00e9crire\u2009: <code>../jardin</code> mais c'est redondant, et cela implique de conna\u00eetre le nom de l\u00e0 ou je me trouve. Il existe pour cela un deuxi\u00e8me fichier sp\u00e9cial qui permet de d\u00e9signer le r\u00e9pertoire courant, c'est le fichier <code>.</code>.</p> <p>Enfin, si je souhaite me d\u00e9placer dans l'arborescence, je peux utiliser la commande <code>cd</code> pour change directory. Ce programme prend en argument un chemin absolu ou relatif.</p>"}, {"location": "tools/filesystem/#commandes-utiles", "title": "Commandes utiles", "text": "POSIXWindows CMDWindows PowerShell Commande Description Exemple <code>pwd</code> Affiche le r\u00e9pertoire courant <code>/home/username</code> <code>cd</code> Change de r\u00e9pertoire <code>cd /home/username</code> <code>ls</code> Liste les fichiers et r\u00e9pertoires <code>ls</code> <code>mkdir</code> Cr\u00e9e un r\u00e9pertoire <code>mkdir -p /home/username</code> <code>rmdir</code> Supprime un r\u00e9pertoire <code>rmdir /home/username</code> <code>touch</code> Cr\u00e9e un fichier vide <code>touch /home/username/file.txt</code> <code>rm</code> Supprime un fichier <code>rm /home/username/file.txt</code> <code>mv</code> D\u00e9place un fichier <code>mv /home/username/file.txt /home/username/backup/</code> <code>cp</code> Copie un fichier <code>cp /home/username/file.txt /home/username/backup/</code> Commande Description Exemple <code>cd</code> Affiche le r\u00e9pertoire courant <code>cd</code> <code>cd</code> Change de r\u00e9pertoire <code>cd C:\\Users\\username</code> <code>dir</code> Liste les fichiers et r\u00e9pertoires <code>dir</code> <code>mkdir</code> Cr\u00e9e un r\u00e9pertoire <code>mkdir C:\\Users\\username\\backup</code> <code>rmdir</code> Supprime un r\u00e9pertoire <code>rmdir C:\\Users\\username\\backup</code> <code>echo</code> Cr\u00e9e un fichier vide <code>echo. &gt; C:\\Users\\username\\file.txt</code> <code>del</code> Supprime un fichier <code>del C:\\Users\\username\\file.txt</code> <code>move</code> D\u00e9place un fichier <code>move C:\\Users\\username\\file.txt C:\\Users\\username\\backup\\</code> <code>copy</code> Copie un fichier <code>copy C:\\Users\\username\\file.txt C:\\Users\\username\\backup\\</code> Commande Description Exemple <code>pwd</code> Affiche le r\u00e9pertoire courant <code>pwd</code> <code>cd</code> Change de r\u00e9pertoire <code>cd C:\\Users\\username</code> <code>ls</code> Liste les fichiers et r\u00e9pertoires <code>ls</code> <code>mkdir</code> Cr\u00e9e un r\u00e9pertoire <code>mkdir C:\\Users\\username\\backup</code> <code>rmdir</code> Supprime un r\u00e9pertoire <code>rmdir C:\\Users\\username\\backup</code> <code>echo</code> Cr\u00e9e un fichier vide <code>echo. &gt; C:\\Users\\username\\file.txt</code> <code>rm</code> Supprime un fichier <code>rm C:\\Users\\username\\file.txt</code> <code>mv</code> D\u00e9place un fichier <code>mv C:\\Users\\username\\file.txt C:\\Users\\username\\backup\\</code> <code>cp</code> Copie un fichier <code>cp C:\\Users\\username\\file.txt C:\\Users\\username\\backup\\</code> <p>Windows</p> <p>On voit que Microsoft a appris de ses erreurs et a introduit <code>pwd</code> et <code>ls</code> dans PowerShell. C'est une bonne chose car ces commandes sont tr\u00e8s utiles. PowerShell est un shell plus moderne que CMD et plus puissant. Il est bas\u00e9 sur le framework .NET et permet d'interagir avec des objets .NET.</p> <p>Avertissement</p> <p>Les commandes <code>rm</code>, <code>mv</code>, <code>cp</code> sont tr\u00e8s dangereuses. Elles peuvent d\u00e9truire des donn\u00e9es. Il est important de faire attention \u00e0 ce que vous faites. Il est recommand\u00e9 de faire des sauvegardes r\u00e9guli\u00e8res de vos donn\u00e9es.</p>"}, {"location": "tools/filesystem/#permissions", "title": "Permissions", "text": "<p>Les syst\u00e8mes de fichiers modernes permettent de d\u00e9finir des permissions sur les fichiers et les r\u00e9pertoires. Ces permissions permettent de contr\u00f4ler qui peut lire, \u00e9crire ou ex\u00e9cuter un fichier. Les permissions sont d\u00e9finies pour trois cat\u00e9gories d'utilisateurs\u2009:</p> <ul> <li>Le propri\u00e9taire du fichier</li> <li>Le groupe auquel appartient le fichier</li> <li>Les autres utilisateurs</li> </ul> <p>Les permissions sont d\u00e9finies pour trois actions\u2009:</p> <ul> <li>Lire le fichier</li> <li>\u00c9crire dans le fichier</li> <li>Ex\u00e9cuter le fichier</li> </ul> <p>Les permissions sont repr\u00e9sent\u00e9es par des lettres\u2009:</p> <ul> <li><code>r</code> pour lire</li> <li><code>w</code> pour \u00e9crire</li> <li><code>x</code> pour ex\u00e9cuter</li> </ul> <p>Les permissions sont affich\u00e9es par la commande <code>ls -l</code> dans POSIX. Sous Windows ce n'est pas aussi simple. Les permissions sont affich\u00e9es par la commande <code>icacls</code> mais le format est diff\u00e9rent.</p> <p>NTFS</p> <p>Le syst\u00e8me de fichier NTFS (New Technology File System) de Microsoft permet de d\u00e9finir des permissions tr\u00e8s fines sur les fichiers et les r\u00e9pertoires. Il permet de d\u00e9finir des permissions pour des utilisateurs individuels ou des groupes d'utilisateurs. Il permet aussi de chiffrer les donn\u00e9es pour les prot\u00e9ger contre les acc\u00e8s non autoris\u00e9s.</p> <p>Les commandes sont donc beaucoup plus complexes et ne se r\u00e9duisent pas aux permissions que l'on explique ici.</p> <p>Cette granularit\u00e9 est tr\u00e8s utile dans un environnement professionnel o\u00f9 les donn\u00e9es sont sensibles mais cela peut \u00eatre un cauchemar pour les administrateurs syst\u00e8me et surtout cela rend le syst\u00e8me plus lent car il doit v\u00e9rifier toutes les permissions \u00e0 chaque acc\u00e8s disque.</p> <p>Pour changer une permission, on utilise la commande <code>chmod</code> dans POSIX. Sous Windows il est pr\u00e9f\u00e9rable de passer par l'interface graphique.</p> Description Exemple Ajouter l'ex\u00e9cution sur un fichier <code>$ chmod +x program</code> Retirer l'ex\u00e9cution sur un fichier <code>$ chmod -x program</code> Ajouter l'\u00e9criture pour le groupe <code>$ chmod g+w file</code> Retirer l'\u00e9criture pour les autres <code>$ chmod o-w file</code> Ajouter la lecture pour tous <code>$ chmod a+r file</code> Retirer tous les droits pour les autres <code>$ chmod o-rwx file</code> Changer les permissions pour tous <code>$ chmod 777 file</code> <p>Repr\u00e9sentation octale</p> <p>Dans un environnement POSIX, on peut repr\u00e9senter les permissions avec des chiffres. Chaque permission est repr\u00e9sent\u00e9e par un bit\u2009:</p> <ul> <li><code>r</code> : 4</li> <li><code>w</code> : 2</li> <li><code>x</code> : 1</li> </ul> <p>On additionne les bits pour obtenir la permission\u2009:</p> <ul> <li><code>rwx</code> : 7</li> <li><code>rw-</code> : 6</li> <li><code>r-x</code> : 5</li> </ul> <p>Chaque chiffre repr\u00e9sente dans l'ordre le propri\u00e9taire, le groupe et les autres. Ainsi la permission du fichier <code>~/.ssh/id_rsa</code> est <code>400</code> ce qui signifie que le propri\u00e9taire a le droit de lire le fichier mais ni d'\u00e9crire ni d'ex\u00e9cuter. Le groupe et les autres n'ont aucun droit. C'est normal c'est la cl\u00e9 priv\u00e9e SSH, elle ne doit \u00eatre lue que par le propri\u00e9taire.</p>"}, {"location": "tools/filesystem/#proprietaire-et-groupe", "title": "Propri\u00e9taire et groupe", "text": "<p>Chaque fichier a un propri\u00e9taire et un groupe. Le propri\u00e9taire est l'utilisateur qui a cr\u00e9\u00e9 le fichier. Le groupe est le groupe auquel appartient le fichier. Les utilisateurs peuvent appartenir \u00e0 plusieurs groupes. Les groupes permettent de d\u00e9finir des permissions pour plusieurs utilisateurs. Par exemple, un groupe <code>admin</code> pourrait avoir des droits d'\u00e9criture sur un r\u00e9pertoire.</p> <p>Pour changer le propri\u00e9taire d'un fichier, on utilise la commande <code>chown</code> dans POSIX. Sous Windows, il est pr\u00e9f\u00e9rable de passer par l'interface graphique.</p> Description Exemple Changer le propri\u00e9taire d'un fichier <code>$ chown username file</code> Changer le groupe d'un fichier <code>$ chgrp group file</code> Ajouter un utilisateur \u00e0 un groupe <code>$ usermod -aG group username</code> Retirer un utilisateur d'un groupe <code>$ gpasswd -d username group</code> Cr\u00e9er un groupe <code>$ groupadd group</code> Supprimer un groupe <code>$ groupdel group</code> Lister les groupes d'un utilisateur <code>$ groups username</code>"}, {"location": "tools/filesystem/#acl-access-control-list", "title": "ACL (Access Control List)", "text": "<p>Les syst\u00e8mes de fichiers modernes permettent de d\u00e9finir des ACL (Access Control List) sur les fichiers et les r\u00e9pertoires. Les ACL permettent de d\u00e9finir des permissions plus fines que les permissions POSIX. Les ACL permettent de d\u00e9finir des permissions pour des utilisateurs individuels ou des groupes d'utilisateurs. Les ACL sont plus complexes \u00e0 g\u00e9rer que les permissions POSIX mais elles permettent de d\u00e9finir des permissions plus pr\u00e9cises.</p> <p>En g\u00e9n\u00e9ral, les ACL sont g\u00e9r\u00e9es par des outils graphiques ou des commandes sp\u00e9cifiques. Les ACL sont stock\u00e9es dans les m\u00e9tadonn\u00e9es des fichiers et des r\u00e9pertoires. Les ACL sont utilis\u00e9es dans les environnements professionnels o\u00f9 les donn\u00e9es sont sensibles et o\u00f9 il est n\u00e9cessaire de d\u00e9finir des permissions tr\u00e8s pr\u00e9cises. Cela permet de se rapprocher de syst\u00e8mes de fichiers comme NTFS de Microsoft.</p> <p>Sur votre ordinateur ou dans votre carri\u00e8re professionnelle vous n'aurez tr\u00e8s certainement jamais besoin de g\u00e9rer des ACL. C'est un sujet complexe et r\u00e9serv\u00e9 aux administrateurs syst\u00e8me. Mais pour les plus curieux voici quelques exemples\u2009:</p> Description Exemple Afficher les ACL d'un fichier <code>$ getfacl file</code> Modifier les ACL d'un fichier <code>$ setfacl -m u:username:rwx file</code> Supprimer les ACL d'un fichier <code>$ setfacl -b file</code> Copier les ACL d'un fichier <code>$ getfacl file1 | setfacl --set-file=- file2</code> Sauvegarder les ACL d'un fichier <code>$ getfacl file &gt; file.acl</code> Restaurer les ACL d'un fichier <code>$ setfacl --restore=file.acl</code>"}, {"location": "tools/filesystem/#manipulation-bas-niveau", "title": "Manipulation bas niveau", "text": "<p>Une question que l'on peut se poser est s'il est possible d'acc\u00e9der aux donn\u00e9es brutes d'un disque dur (les 1 et les 0) : la r\u00e9ponse est oui. Il est possible d'acc\u00e9der aux donn\u00e9es brutes d'un disque dur en utilisant des outils sp\u00e9cifiques. Ces outils permettent de lire et d'\u00e9crire des donn\u00e9es directement sur le disque dur sans passer par le syst\u00e8me de fichiers.</p> <p>La commande <code>dd</code> dans POSIX permet de lire et d'\u00e9crire des donn\u00e9es brutes sur un disque dur. Cette commande est tr\u00e8s puissante et tr\u00e8s dangereuse. Elle permet de lire et d'\u00e9crire des donn\u00e9es directement sur le disque dur. Il est tr\u00e8s facile de d\u00e9truire des donn\u00e9es avec cette commande.</p> <p>On peut utiliser des fichiers sp\u00e9ciaux comme <code>/dev/zero</code> ou <code>/dev/random</code> pour g\u00e9n\u00e9rer des fichiers de donn\u00e9es.</p> <p>Par exemple cr\u00e9er un fichier de 1 Mio rempli de z\u00e9ros\u2009:</p> <pre><code>$ dd if=/dev/zero of=file bs=1M count=1\n</code></pre> <p>Ou cr\u00e9er un fichier de 100 bytes rempli de donn\u00e9es al\u00e9atoires\u2009:</p> <pre><code>$ dd if=/dev/random of=file bs=100 count=1\n</code></pre> <p>On peut aussi lire des donn\u00e9es brutes sur un disque dur. Par exemple lire les 100 premiers bytes d'un disque dur\u2009:</p> <pre><code>$ dd if=/dev/sda of=file bs=100 count=1\n</code></pre>"}, {"location": "tools/filesystem/#arborescence-posix", "title": "Arborescence POSIX", "text": "<p>L'arborescence POSIX est une convention pour organiser les fichiers et les r\u00e9pertoires sur un syst\u00e8me de fichiers. L'arborescence POSIX est utilis\u00e9e par la plupart des syst\u00e8mes d'exploitation bas\u00e9s sur UNIX. L'arborescence POSIX est organis\u00e9e de la mani\u00e8re suivante\u2009:</p> <ul> <li><code>/</code> : Le r\u00e9pertoire racine</li> <li><code>/bin</code> : Les programmes de base</li> <li><code>/boot</code> : Les fichiers de d\u00e9marrage</li> <li><code>/dev</code> : Les fichiers de p\u00e9riph\u00e9riques</li> <li><code>/etc</code> : Les fichiers de configuration</li> <li><code>/home</code> : Les r\u00e9pertoires des utilisateurs</li> <li><code>/lib</code> : Les biblioth\u00e8ques partag\u00e9es</li> <li><code>/media</code> : Les points de montage des p\u00e9riph\u00e9riques amovibles</li> <li><code>/mnt</code> : Les points de montage des p\u00e9riph\u00e9riques</li> <li><code>/opt</code> : Les logiciels optionnels</li> <li><code>/proc</code> : Les informations sur les processus</li> <li><code>/root</code> : Le r\u00e9pertoire de l'administrateur</li> <li><code>/tmp</code> : Les fichiers temporaires</li> <li><code>/usr</code> : Les programmes et les fichiers partag\u00e9s</li> <li><code>/var</code> : Les fichiers variables</li> <li><code>/srv</code> : Les donn\u00e9es des services</li> <li><code>/sys</code> : Les informations sur le noyau</li> </ul> <p>Windows</p> <p>Malheureusement Windows n'a pas vraiment de convention rigide pour l'organisation des fichiers et des r\u00e9pertoires. Chaque programme peut d\u00e9cider o\u00f9 il veut stocker ses fichiers de configuration, ses fichiers de donn\u00e9es, etc. Cela rend la maintenance et la sauvegarde des donn\u00e9es plus difficile. On peut n\u00e9anmoins retrouver quelques r\u00e9pertoires communs\u2009:</p> <ul> <li><code>C:\\Program Files</code> : Les programmes install\u00e9s</li> <li><code>C:\\Program Files (x86)</code> : Les programmes 32 bits install\u00e9s sur un syst\u00e8me 64 bits</li> <li><code>C:\\Users</code> : Les r\u00e9pertoires des utilisateurs</li> <li><code>C:\\Windows</code> : Les fichiers du syst\u00e8me d'exploitation</li> <li><code>C:\\Windows\\System32</code> : Les fichiers du syst\u00e8me d'exploitation 64 bits</li> <li><code>C:\\Windows\\SysWOW64</code> : Les fichiers du syst\u00e8me d'exploitation 32 bits sur un syst\u00e8me 64 bits</li> <li><code>C:\\Temp</code> : Les fichiers temporaires</li> <li><code>C:\\Users\\username\\AppData</code> : Les fichiers de configuration des programmes</li> <li><code>C:\\Users\\username\\Documents</code> : Les documents de l'utilisateur</li> <li><code>C:\\Users\\username\\Downloads</code> : Les fichiers t\u00e9l\u00e9charg\u00e9s</li> </ul>"}, {"location": "tools/gcc/", "title": "Compilateur C/C++", "text": "<p>Compiler un programme en C ou en C++ requiert un compilateur. Il s'agit d'un programme qui permet de traduire le code source en langage C ou C++ en un fichier objet (extension <code>.o</code> ou <code>.obj</code>), ou un fichier ex\u00e9cutable (extension <code>.exe</code> sous Windows ou sans extension dans un syst\u00e8me POSIX).</p> <p>Le compilateur le plus utilis\u00e9 pour le C est <code>gcc</code> (GNU Compiler Collection) et pour le C++ est <code>g++</code>. Ces deux compilateurs sont inclus dans la suite logicielle <code>gcc</code>. Pour installer <code>gcc</code> sous Ubuntu, il suffit de taper la commande suivante dans un terminal\u2009:</p> <pre><code>sudo apt-get install build-essential\n</code></pre> <p>Sous Windows, c'est plus compliqu\u00e9. GCC \u00e9tant un logiciel pr\u00e9vu pour un syst\u00e8me POSIX, il n'est pas directement compatible avec Windows. Il existe cependant des ports de GCC pour Windows, comme MinGW, Cygwin ou MSYS2. Ces ports permettent d'installer GCC sur Windows, mais il est plus \u00e9l\u00e9gant et plus pratique d'utiliser WSL si les applications que vous d\u00e9veloppez sont destin\u00e9es \u00e0 vos \u00e9tudes et ne seront pas distribu\u00e9es \u00e0 des utilisateurs Windows.</p> <p>Si vous souhaitez compiler sous Windows avec un compilateur Windows, vous pouvez utiliser Visual Studio qu'il ne faut pas confondre avec Visual Studio Code. Visual Studio est un IDE complet qui inclut un compilateur C/C++. Ce compilateur nomm\u00e9 <code>cl</code> est un compilateur propri\u00e9taire de Microsoft. Il est inclus dans Visual Studio et n'est pas disponible s\u00e9par\u00e9ment. Ce compilateur ne respecte pas toujours le standard C (ISO/IEC 9899) mais couvre presque en totalit\u00e9 la norme C++ (ISO/IEC 14882).</p>"}, {"location": "tools/gcc/#cycle-de-compilation", "title": "Cycle de compilation", "text": "<p>La compilation requiert plusieurs \u00e9tapes\u2009:</p> <ol> <li>Pr\u00e9traitement : Le pr\u00e9processeur remplace les macros par leur d\u00e9finition, inclut les fichiers d'en-t\u00eate, etc.</li> <li>Compilation : La compilation converti le code source en assembleur.</li> <li>Assemblage : L'assembleur converti le code assembleur en code objet, il lie les biblioth\u00e8ques statiques et r\u00e9soud les adresses des fonctions externes.</li> <li>\u00c9dition de liens : Le lien \u00e9dite les fichiers objets pour cr\u00e9er un fichier ex\u00e9cutable.</li> </ol> <p>Chacune de ces \u00e9tapes peut \u00eatre r\u00e9alis\u00e9e s\u00e9par\u00e9ment. Par exemple, pour compiler un programme en C, il est possible de g\u00e9n\u00e9rer le fichier objet sans l'\u00e9diter de liens. Cela permet de gagner du temps lors du d\u00e9veloppement, car seule la partie modifi\u00e9e du code est recompil\u00e9e\u2009:</p> <pre><code># G\u00e9n\u00e8re un fichier C\n$ cat &gt; main.c &lt;&lt;EOF\n#include &lt;stdio.h&gt;\nint main() {\n    printf(\"hello, world!\\n\");\n}\nEOF\n\n# \u00c9tape de pr\u00e9processeur\n$ gcc -E main.c -o main.i\n\n# \u00c9tape de compilation\n$ gcc -S main.i -o main.s\n\n# \u00c9tape d'assemblage\n$ gcc -c main.s -o main.o\n\n# \u00c9tape d'\u00e9dition de liens\n$ gcc main.o -o main\n</code></pre>"}, {"location": "tools/gcc/#compilation-separee", "title": "Compilation s\u00e9par\u00e9e", "text": "<p>La compilation s\u00e9par\u00e9e est une technique de d\u00e9veloppement qui consiste \u00e0 compiler chaque fichier source s\u00e9par\u00e9ment. Cela permet de r\u00e9duire le temps de compilation lors du d\u00e9veloppement, car seuls les fichiers modifi\u00e9s sont recompil\u00e9s. Cela permet \u00e9galement de r\u00e9duire la taille des fichiers objets, car les fonctions non utilis\u00e9es ne sont pas incluses dans le fichier objet.</p> <pre><code># G\u00e9n\u00e8re un fichier C\n$ cat &gt; main.c &lt;&lt;EOF\n#include \"add.h\"\n#include &lt;stdio.h&gt;\nint main() {\n    const int a = 2, b = 3;\n    printf(\"Somme de %d+%d = %d\\n\", a, b, add(a, b));\n}\nEOF\n\n$ cat &gt; add.h &lt;&lt;EOF\nint add(int a, int b);\nEOF\n\n$ cat &gt; add.c &lt;&lt;EOF\nint add(int a, int b) {\n    return a + b;\n}\nEOF\n\n# Compilation s\u00e9par\u00e9e des objets\n$ gcc -c main.c -o main.o\n$ gcc -c add.c -o add.o\n\n# \u00c9dition de liens\n$ gcc main.o add.o -o main\n</code></pre> <p>Notez que si vous avez deux fichiers C mais que vous ne souhaitez pas les compiler s\u00e9par\u00e9ment, vous pouvez les compiler en une seule commande\u2009:</p> <pre><code>$ gcc main.c add.c -o main\n</code></pre>"}, {"location": "tools/gcc/#options-de-compilation", "title": "Options de compilation", "text": "<p><code>gcc</code> et <code>g++</code> acceptent de nombreuses options de compilation. Les plus courantes sont\u2009:</p> Option Description <code>-c</code> Compile le code source en un fichier objet sans l'\u00e9diter de liens. <code>-o</code> Sp\u00e9cifie le nom du fichier de sortie. <code>-I</code> Sp\u00e9cifie un r\u00e9pertoire o\u00f9 chercher les fichiers d'en-t\u00eate. <code>-L</code> Sp\u00e9cifie un r\u00e9pertoire o\u00f9 chercher les biblioth\u00e8ques. <code>-l</code> Sp\u00e9cifie une biblioth\u00e8que \u00e0 lier. <code>-Wall</code> Active tous les avertissements. <code>-Werror</code> Traite les avertissements comme des erreurs. <code>-g</code> Inclut des informations de d\u00e9bogage dans le fichier objet. <code>-O</code> Optimise le code. <code>-std</code> Sp\u00e9cifie la norme du langage. <code>-pedantic</code> Respecte strictement la norme. <code>-D</code> D\u00e9finit une macro. <code>-U</code> Undefine une macro. <code>-E</code> Arr\u00eate apr\u00e8s l'\u00e9tape de pr\u00e9processeur. <code>-S</code> Arr\u00eate apr\u00e8s l'\u00e9tape de compilation. <code>-v</code> Affiche les commandes ex\u00e9cut\u00e9es par le compilateur. <p>Pour compiler un programme avec les optimisations maximales, dans la norme C17, avec tous les avertissements activ\u00e9s et trait\u00e9s comme des erreurs, vous pouvez utiliser la commande suivante\u2009:</p> <pre><code>$ gcc -std=c17 -O3 -Wall -Werror -pedantic main.c -o main\n</code></pre>"}, {"location": "tools/gcc/#bibliotheques", "title": "Biblioth\u00e8ques", "text": "<p>Les biblioth\u00e8ques sont des fichiers contenant des fonctions et des variables pr\u00e9d\u00e9finies. Il existe deux types de biblioth\u00e8ques\u2009: les biblioth\u00e8ques statiques et les biblioth\u00e8ques partag\u00e9es. Les biblioth\u00e8ques statiques ont l'extension <code>.a</code> sous POSIX et <code>.lib</code> sous Windows. Les biblioth\u00e8ques partag\u00e9es ont l'extension <code>.so</code> sous POSIX et <code>.dll</code> sous Windows.</p> <p>La biblioth\u00e8que standard du langage C est <code>libc</code>. Elle est incluse par d\u00e9faut dans tous les programmes C. Pour inclure une biblioth\u00e8que, il suffit de sp\u00e9cifier son nom avec l'option <code>-l</code>. Par exmple la biblioth\u00e8que <code>m</code> contient des fonctions math\u00e9matiques. Elle s'appelle <code>libm</code> sous Unix/Linux.</p> <p>Aussi si vous souhaitez calculer le sinus de 3.14, vous pouvez utiliser la fonction <code>sin</code> de la biblioth\u00e8que <code>m</code>, et par cons\u00e9quent vous devez lier cette biblioth\u00e8que \u00e0 votre programme\u2009:</p> <pre><code>$ gcc main.c -o main -lm\n</code></pre> <p>Notez que l'option <code>-lm</code> doit \u00eatre plac\u00e9e apr\u00e8s le nom du fichier source. En effet, <code>gcc</code> traite les options dans l'ordre o\u00f9 elles apparaissent sur la ligne de commande. Si l'option <code>-lm</code> est plac\u00e9e avant le nom du fichier source, <code>gcc</code> ne trouvera pas la fonction <code>sin</code> et \u00e9chouera.</p> <p>Voici quelques biblioth\u00e8ques couramment utilis\u00e9es\u2009:</p> Biblioth\u00e8que Description <code>libc</code> Biblioth\u00e8que standard du langage C. <code>libm</code> Fonctions math\u00e9matiques. <code>libpthread</code> Fonctions de threads POSIX. <code>libcurl</code> Client HTTP. <code>libssl</code> Biblioth\u00e8que de chiffrement SSL. <code>libcrypto</code> Biblioth\u00e8que de chiffrement. <code>libz</code> Compression de donn\u00e9es. <code>libpng</code> Traitement d'images PNG. <code>libsqlite3</code> Base de donn\u00e9es SQLite."}, {"location": "tools/gdb/", "title": "GDB (GNU Debugger)", "text": "<p>GDB est un d\u00e9bogueur en ligne de commande. Il permet de suivre l'ex\u00e9cution d'un programme pas \u00e0 pas, de mettre des points d'arr\u00eat, d'inspecter la m\u00e9moire, de modifier le contenu des variables, etc.</p>"}, {"location": "tools/git/", "title": "Git", "text": "<p> Fanart Git</p>"}, {"location": "tools/git/#introduction", "title": "Introduction", "text": "<p>Git est un outil de gestion de versions. Il a \u00e9t\u00e9 invent\u00e9 par Linus Torvalds en 2005 pour g\u00e9rer le d\u00e9veloppement du noyau Linux qui contient des millions de lignes de code devant \u00eatre modifi\u00e9es par des centaines de milliers de d\u00e9veloppeurs. Git a \u00e9t\u00e9 con\u00e7u pour \u00eatre rapide, efficace et pour g\u00e9rer des projets de toutes tailles. Il est aujourd'hui le syst\u00e8me de gestion de version le plus utilis\u00e9 au monde.</p> <p>Git est la suite logique des outils comme <code>CVS</code> ou Subversion qui \u00e9taient utilis\u00e9s pour g\u00e9rer des projets de d\u00e9veloppement de logiciels.</p> <p>Git est avant tout un outil en ligne de commande. Son utilisation passe par la commande <code>git</code> suivi d'une sous-commande (<code>clone</code>, <code>pull</code>, <code>push</code>, <code>commit</code>, etc.). Il est possible de l'utiliser avec une interface graphique mais l'interface en ligne de commande est plus puissante, plus rapide et plus flexible.</p> <p>Un d\u00e9p\u00f4t (r\u00e9f\u00e9rentiel) Git est un dossier qui contient un dossier cach\u00e9 <code>.git</code>. Ce dossier contient l'historique des modifications du projet. Ne supprimez pas ce dossier, vous perdriez l'historique de votre projet. Lorsque vous faites des commit (sauvegarde incr\u00e9mentationnelle), Git enregistre les modifications dans ce dossier cach\u00e9 et lorsque vous faites un push (envoi des modifications sur un serveur distant), Git envoie les modifications \u00e0 un serveur distant (GitHub, GitLab, Bitbucket, etc.).</p> <p>Par cons\u00e9quent, l'utilisation de Git est intrinc\u00e8quement li\u00e9e \u00e0 l'utilisation d'un serveur distant. Il est possible de travailler en local mais l'int\u00e9r\u00eat de Git est de pouvoir travailler en \u00e9quipe. Il est possible de travailler sur une branche (version parall\u00e8le du projet) et de fusionner les modifications avec la branche principale (master).</p> <p>Ceci implique de comprendre comment Git communique avec un serveur distant. Notons qu'il est possible de travailler avec plusieurs serveurs distants. Ils se configure avec la commande <code>git remote</code>. Deux protocoles de communication existent\u2009: <code>SSH</code> et <code>HTTPS</code>. Le protocole <code>SSH</code> est plus s\u00e9curis\u00e9 que <code>HTTPS</code> mais n\u00e9cessite l'\u00e9change de cl\u00e9s cryptographiques. Le protocole <code>HTTPS</code> est plus simple \u00e0 mettre en place mais demande un mot de passe ou un jeton d'authentification \u00e0 chaque communication avec le serveur distant. La solution recommand\u00e9e est d'utiliser <code>SSH</code>.</p>"}, {"location": "tools/git/#installation-de-git", "title": "Installation de Git", "text": "LinuxWindowsMacOS <p>Sous Linux, et particuli\u00e8rement Ubuntu, Git est probablement d\u00e9j\u00e0 install\u00e9 par d\u00e9faut. Si ce n'est pas le cas, avec Ubuntu ouvrez un terminal Bash et tapez la commande suivante\u2009:</p> <pre><code>sudo apt install git\n</code></pre> <p>[!NOTE] Selon la distribution Linux que vous utilisez, les gestionnaires de paquets n'ont pas le m\u00eame nom. Sous Fedora, le gestionnaire de paquets est <code>dnf</code> et sous Arch Linux, le gestionnaire de paquets est <code>pacman</code>. N\u00e9anmoins la commande reste tr\u00e8s similaire.</p> <p>Pour installer Git sous Windows, le plus simple est d'utiliser le nouveau gestionnaire de paquet de Windows appel\u00e9 <code>winget</code>. Ouvrez un terminal <code>PowerShell</code> et tapez la commande suivante issue de Winget Git/Git</p> <pre><code>winget install -e --id Git.Git\n</code></pre> <p>Sous MacOS, Git est probablement d\u00e9j\u00e0 install\u00e9. Si ce n'est pas le cas, vous pouvez installer Git avec Homebrew en tapant la commande suivante dans un terminal\u2009:</p> <pre><code>brew install git\n</code></pre>"}, {"location": "tools/git/#configuration-de-git", "title": "Configuration de Git", "text": ""}, {"location": "tools/git/#utilisateur-et-adresse-e-mail", "title": "Utilisateur et adresse e-mail", "text": "<p>La premi\u00e8re chose \u00e0 faire apr\u00e8s avoir install\u00e9 Git est de le configurer. Ouvrez un terminal et tapez les commandes suivantes en veillant bien \u00e0 remplacer <code>John Doe</code> par votre nom et <code>john.doe@acme.com</code> par votre adresse e-mail.</p> <pre><code>git config --global user.name \"John Doe\"\ngit config --global user.email john.doe@acme.com\n</code></pre> <p>Ces informations sont utilis\u00e9es pour chaque commit que vous ferez. Elles sont importantes car elles permettent de savoir qui a fait une modification dans le projet. Ne vous trompez pas dans votre nom ou votre adresse e-mail, il est difficile de changer ces informations une fois qu'elles ont \u00e9t\u00e9 enregistr\u00e9es dans un commit, et surtout si elle ont \u00e9t\u00e9 envoy\u00e9es sur un serveur distant.</p>"}, {"location": "tools/git/#methode-de-fusion-merge", "title": "M\u00e9thode de fusion (merge)", "text": "<p>Lorsque vous utilisez la commande <code>git pull</code> pour r\u00e9cup\u00e9rer les modifications d'un serveur distant, Git peut \u00eatre amen\u00e9 \u00e0 fusionner des modifications. Il est possible de choisir la m\u00e9thode de fusion. Les deux m\u00e9thodes les plus courantes sont <code>merge</code> et <code>rebase</code>. La m\u00e9thode <code>merge</code> est la m\u00e9thode par d\u00e9faut. La m\u00e9thode <code>rebase</code> est plus avanc\u00e9e et est utilis\u00e9e pour r\u00e9\u00e9crire l'historique du projet. Elle est plus propre mais elle peut \u00eatre source de probl\u00e8mes si elle est mal utilis\u00e9e. Git s'attend \u00e0 que vous configuriez laquelle des deux m\u00e9thodes vous pr\u00e9f\u00e9rez. Vous pouvez le faire avec la commande suivante\u2009:</p> <p>Pour le rebase\u2009:</p> <pre><code>git config --global pull.rebase true\n</code></pre> <p>Pour le merge\u2009:</p> <pre><code>git config --global pull.rebase false\n</code></pre> <p>Note</p> <p>La m\u00e9thode <code>rebase</code> est plus propre mais elle peut \u00eatre source de probl\u00e8mes si elle est mal utilis\u00e9e. Elle est recommand\u00e9e pour les projets personnels mais pas pour les projets en \u00e9quipe. En cas de doute privil\u00e9giez la m\u00e9thode <code>merge</code>.</p>"}, {"location": "tools/git/#affichage-de-lhistorique-des-commits-log", "title": "Affichage de l'historique des commits (log)", "text": "<p>Lorsque vous utilisez la commande <code>git log</code> pour afficher l'historique des commits, Git affiche les commits dans un format compact. Il est possible de personnaliser l'affichage de l'historique des commits. Vous pouvez le faire avec la commande suivante\u2009:</p> <pre><code>git config --global alias.lg \"log -n30 --boundary --graph --pretty=format:'%C(bold blue)%h%C(bold green)%&lt;|(20)% ar%C(reset)%C(white)% s %C(dim white)-% an%C(reset)%C(auto)% d%C(bold red)% N' --abbrev-commit --date=relative\"\n</code></pre> <p>D\u00e8s lors vous utiliserez le raccourcis <code>lg</code> pour afficher l'historique des commits (<code>git lg</code>).</p> <p>Pour afficher la date en format ISO 8601, vous pouvez utiliser la commande suivante\u2009:</p> <pre><code>git config --global alias.lga \"log -n30 --boundary --graph --pretty=format:'%C(bold blue)%h%C(bold green)%&lt;|(20)% ai%C(reset)%C(white)% s %C(dim white)-% an%C(reset)%C(auto)% d%C(bold red)' --abbrev-commit --date=iso\"\n</code></pre>"}, {"location": "tools/git/#configuration-ssh", "title": "Configuration SSH", "text": "<p>Comme nous l'avons vu, Git peut communiquer avec un serveur distant en utilisant le protocole <code>SSH</code>. Pour cela, il est n\u00e9cessaire de configurer une cl\u00e9 cryptographique.</p> <p>La premi\u00e8re chose \u00e0 faire est de v\u00e9rifier si vous avez d\u00e9j\u00e0 une cl\u00e9 SSH. Ouvrez un terminal et tapez la commande suivante\u2009:</p> <pre><code>$ ls -al ~/.ssh/*.pub\n-rw-r--r-- 1 ycr ycr 393 2023-09-06 08:38 /home/ycr/.ssh/id_rsa.pub\n</code></pre> <p>Le fichier <code>id_rsa.pub</code> est votre cl\u00e9 publique. Si vous ne voyez pas ce fichier, c'est que vous n'avez pas de cl\u00e9 SSH. Vous pouvez en g\u00e9n\u00e9rer une avec la commande suivante\u2009:</p> <pre><code>ssh-keygen\n</code></pre> <p>Sous Windows, la commande est la m\u00eame mais vous devez lancer <code>Git Bash</code> pour l'ex\u00e9cuter. Vous pouvez lancer <code>Git Bash</code> en tapant <code>Git Bash</code> dans le menu de recherche de Windows.</p>"}, {"location": "tools/git/#configuration-de-github", "title": "Configuration de GitHub", "text": "<p>Si vous utilisez GitHub, il est n\u00e9cessaire de configurer votre cl\u00e9 SSH dans votre compte GitHub. Pour cela, ouvrez un terminal et tapez la commande suivante\u2009:</p> <pre><code>$ cat ~/.ssh/id_rsa.pub\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC+yNp7af6zI8NINIFX1aRj+nzKksZ6XzBSkgA/iuPpYIGz5SSZOkwkvN0DnX8J42DcuEK/mnu3+f9Wh746823gxhXqtj+7Wv9z9DJ9O9qrsYlnxIMipoqepE/Xt+jE5Yv8ullIdsvZdzY611R5DFwrVswslz9OdmpH6nWCmnY/cGZva79ngdcvJLKFk++fl+Be1xshWt24svawRH7Fdxn8VyUKmP2Twy6iMo3MT9xGe5leV1CiTXfkzLYntNV50/dtzQN+pwcwRBdXBP9FdO9+IzieY6bUGttT6t2VcWoK6jFF+i94Chl/FeGvRU1X/QzSP3SYT2biNRNmznSIa2VD ycr@heig-vd\n</code></pre> <p>Copiez la cl\u00e9 publique et collez-la dans votre compte GitHub. Pour cela, ouvrez votre navigateur et allez sur GitHub. Connectez-vous \u00e0 votre compte et cliquez sur votre photo de profil en haut \u00e0 droite. Cliquez sur <code>Settings</code> puis sur <code>SSH and GPG keys</code>. Cliquez sur <code>New SSH key</code> et collez votre cl\u00e9 publique dans le champ <code>Key</code>. Donnez un nom \u00e0 votre cl\u00e9 et cliquez sur <code>Add SSH key</code>.</p>"}, {"location": "tools/git/#commandes-utiles", "title": "Commandes utiles", "text": "Commande Description <code>git init</code> Initialise un d\u00e9p\u00f4t Git dans le r\u00e9pertoire courant <code>git clone &lt;address&gt;</code> Clone un d\u00e9p\u00f4t distant dans le r\u00e9pertoire courant <code>git status</code> Affiche l'\u00e9tat du d\u00e9p\u00f4t <code>git add &lt;file&gt;</code> Ajoute des fichiers \u00e0 l'index <code>git commit -am \"message\"</code> Enregistre les modifications dans l'historique du d\u00e9p\u00f4t <code>git pull</code> R\u00e9cup\u00e8re les modifications du serveur distant <code>git push</code> Envoie les modifications sur le serveur distant <code>git log</code> Affiche l'historique des commits <code>git lg</code> Affiche l'historique des commits de mani\u00e8re plus lisible"}, {"location": "tools/make/", "title": "Make", "text": ""}, {"location": "tools/make/#introduction", "title": "Introduction", "text": "<p><code>make</code> est un outil de gestion de projet qui permet de compiler des programmes C/C++ de mani\u00e8re efficace. <code>make</code> utilise un fichier <code>Makefile</code> qui contient les r\u00e8gles de compilation.</p> <p>Le langage Make est tr\u00e8s ancien (1976) et n'est pas tr\u00e8s lisible aux yeux des d\u00e9butants. Cependant, il est tr\u00e8s puissant et permet de g\u00e9rer des projets de grande envergure. Voici un exemple de <code>Makefile</code> g\u00e9n\u00e9rique pour compiler un programme en C\u2009:</p> <pre><code>CC=gcc\nCFLAGS=-std=c17 -O3 -Wall -Werror -pedantic\nLDFLAGS=-lm\nEXEC=main\nSRCS=$(wildcard *.c)\nOBJS=$(SRCS:.c=.o)\n\nall: $(EXEC)\n\n!include $(OBJS:.o=.d)\n\n$(EXEC): $(OBJS)\n    $(CC) -o $@ $^ $(LDFLAGS)\n\n%.o: %.c\n    $(CC) -o $@ -c $&lt; $(CFLAGS) -MMD -MP\n\nclean:\n    $(RM) -f $(OBJS) $(EXEC) $(OBJS:.o=.d)\n\n.PHONY: all clean\n</code></pre> <p>Make utilise des variables sp\u00e9ciales et l'appel de macros. Les variables sont d\u00e9finies avec <code>VAR=valeur</code> et appel\u00e9es avec <code>$(VAR)</code>.</p> Variable Description <code>CC</code> Compilateur (convention) <code>CFLAGS</code> Options de compilation (convention) <code>LDFLAGS</code> Options d'\u00e9dition de liens (convention) <code>EXEC</code> Nom du fichier ex\u00e9cutable (convention) <code>SRCS</code> Liste des fichiers sources <code>OBJS</code> Liste des fichiers objets <code>$@</code> Nom de la cible <code>$^</code> Liste des d\u00e9pendances <code>$&lt;</code> Premi\u00e8re d\u00e9pendance <code>%.o</code> Jalon g\u00e9n\u00e9rique pour tous les fichiers en <code>.o</code> <code>$(wildcard *.foo)</code> Liste des fichiers <code>.foo</code> dans le r\u00e9pertoire courant <code>$(RM)</code> Commande de suppression de fichiers sur le syst\u00e8me courant <p>Le fonctionnement de Make est en soi assez simple. Des r\u00e8gles sont d\u00e9finies avec <code>cible: d\u00e9pendances</code> et les commandes \u00e0 ex\u00e9cuter pour g\u00e9n\u00e9rer la cible.</p> <p>Dans l'exemple ci-dessus, la r\u00e8gle <code>all</code> d\u00e9pend de <code>$(EXEC)</code>, autrement dit le fichier <code>main</code>. Pour g\u00e9n\u00e9rer <code>main</code>, Make recherche une autre r\u00e8gle du m\u00eame nom. Il trouve <code>main: $(OBJS)</code> qui d\u00e9pend de tous les fichiers objets. Pour g\u00e9n\u00e9rer un fichier objet, Make recherche une autre r\u00e8gle permettant de g\u00e9n\u00e9rer les fichiers objets n\u00e9cessaires. Il trouve <code>%.o: %.c</code> qui d\u00e9pend de tous les fichiers sources. Une fois les fichiers objets g\u00e9n\u00e9r\u00e9s, Make peut g\u00e9n\u00e9rer l'ex\u00e9cutable <code>main</code>.</p> <p>Make fonctionne de mani\u00e8re incr\u00e9mentale. Si un fichier source est modifi\u00e9, Make ne recompile que les fichiers objets n\u00e9cessaires. Cela permet de gagner du temps lors du d\u00e9veloppement. Il se base sur les dates de modification des fichiers pour d\u00e9terminer si un fichier doit \u00eatre recompil\u00e9 ou non.</p> <p>Ce mode de fonctionnement peut cr\u00e9er des probl\u00e8mes avec les fichiers d'en-t\u00eate. En effet, si un fichier d'en-t\u00eate est modifi\u00e9, Make ne recompile pas les fichiers sources qui incluent ce fichier d'en-t\u00eate puisque les fichiers d'en-t\u00eate n'apparaissent dans aucune r\u00e8gles. Pour r\u00e9soudre ce probl\u00e8me, il est possible de g\u00e9n\u00e9rer des fichiers de d\u00e9pendances avec l'option <code>-MMD -MP</code> du compilateur GCC. Ces fichiers de d\u00e9pendances sont inclus dans le <code>Makefile</code> avec l'option <code>!include $(OBJS:.o=.d)</code>. Ils contiennent la liste des fichiers d'en-t\u00eate inclus par chaque fichier source qui indique par exemple que l'objet <code>main.o</code> d\u00e9pend du fichier <code>add.h</code>. Ainsi, si <code>add.h</code> est modifi\u00e9, Make recompile <code>main.o</code> et reg\u00e9n\u00e8re l'ex\u00e9cutable <code>main</code>.</p>"}, {"location": "tools/make/#utilisation", "title": "Utilisation", "text": "<p>Pour utiliser Make, il suffit de cr\u00e9er un fichier <code>Makefile</code> dans le r\u00e9pertoire du projet. Ensuite, il suffit de taper la commande <code>make</code> dans un terminal pour compiler le projet. Pour nettoyer les fichiers temporaires, il suffit de taper la commande <code>make clean</code>.</p> <p>Voici l'exemple de cr\u00e9ation d'un programme en C avec deux fichiers C et un fichier d'en-t\u00eate\u2009:</p> main.cadd.hadd.c <pre><code>#include \"add.h\"\n#include &lt;stdio.h&gt;\n\nint main() {\n    const int a = 2, b = 3;\n    printf(\"Somme de %d+%d = %d\\n\", a, b, add(a, b));\n}\n</code></pre> <pre><code>#pragma once\nint add(int a, int b);\n</code></pre> <pre><code>int add(int a, int b) {\n    return a + b;\n}\n</code></pre> <p>Votre <code>Makefile</code> devrait ressembler \u00e0 ceci\u2009:</p> <pre><code>CC=gcc\nCFLAGS=-std=c17 -O3 -Wall -Werror -pedantic\nLDFLAGS=-lm # Si vous utilisez la librairie math\u00e9matique\nEXEC=main\n\nall: $(EXEC)\n\n$(EXEC): main.o add.o\n    $(CC) -o $@ $^ $(LDFLAGS)\n\n%.o: %.c | add.h\n    $(CC) -o $@ -c $&lt; $(CFLAGS)\n\nclean:\n    $(RM) -f *.o $(EXEC)\n</code></pre>"}, {"location": "tools/python/", "title": "Python", "text": "<p> Un python informaticien</p>"}, {"location": "tools/python/#introduction", "title": "Introduction", "text": "<p>Python est un langage de programmation comme le C mais il est plus haut niveau. Cela signifie que Python est plus facile \u00e0 apprendre et \u00e0 utiliser que le C. Python est un langage interpr\u00e9t\u00e9, ce qui signifie que le code source est ex\u00e9cut\u00e9 directement par un interpr\u00e9teur sans n\u00e9cessairement passer par une \u00e9tape de compilation.</p> <p>C'est un langage tr\u00e8s populaire pour l'enseignement de la programmation et pour la science des donn\u00e9es. Python est utilis\u00e9 dans de nombreux domaines, tels que l'intelligence artificielle, l'apprentissage automatique, l'analyse de donn\u00e9es, la programmation web, la programmation syst\u00e8me, etc.</p>"}, {"location": "tools/python/#installation-de-python", "title": "Installation de Python", "text": "<p>Sous Linux/WSL, l'installation de Python est tr\u00e8s simple. Ouvrez un terminal et tapez la commande suivante\u2009:</p> UbuntuMacOSWindows <pre><code>sudo apt install python3\n</code></pre> <pre><code>brew install python3\n</code></pre> <pre><code>winget install -e --id Python.Python.3.12\n</code></pre> <p>Sous Windows, vous devez choisir la version de Python que vous souhaitez installer. Il est recommand\u00e9 d'installer la version <code>3.12</code> de Python. Utilisez le gestionnaire de paquets <code>winget</code> pour installer Python.</p>"}, {"location": "tools/python/#configuration-des-variables-denviroonement", "title": "Configuration des variables d'enviroonement", "text": "<p>Selon la m\u00e9thode utilis\u00e9e pour installer Python, il est possible que les variables d'environnement ne soient pas configur\u00e9es automatiquement. Il y a deux entr\u00e9es \u00e0 configurer dans la variable <code>PATH</code> :</p> <ol> <li>Le chemin vers l'ex\u00e9cutable Python. Sous Linux/WSL, le chemin sera d\u00e9j\u00e0 configur\u00e9 (<code>/usr/bin</code>). Sous Windows, le chemin diff\u00e8re selon les \u00e9poques, les installateurs et les versions.</li> <li>Le chemin vers les paquets locaux install\u00e9s avec <code>pip</code>.</li> </ol> <p>Pour configurer sous Linux/WSL le chemin vers les paquets locaux install\u00e9s avec <code>pip</code>, ouvrez un terminal et tapez la commande suivante\u2009:</p> Linux/WSLWindows <pre><code>echo \"export PATH=\\\"\\$HOME/.local/bin:\\$PATH\\\"\" &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre> <p>Sous Windows, c'est plus compliqu\u00e9. Selon l'installation de Python vous devez identifier le chemin vers le dossier <code>Scripts</code> qui contient les ex\u00e9cutables Python install\u00e9s avec <code>pip</code>.</p> <p>Les conventions \u00e9voluent avec le temps. Voici un chemin possible\u2009:</p> <pre><code>C:\\Users\\username\\AppData\\Local\\Programs\\Python\\Python3x\\Scripts\n</code></pre>"}, {"location": "tools/python/#installation-des-paquets-principaux", "title": "Installation des paquets principaux", "text": "<p>Installons les paquets les plus couramment utilis\u00e9s avec Python. Ouvrez un terminal et tapez les commandes suivantes\u2009:</p> <pre><code>pip install ipython numpy matplotlib pandas jupyterlab black flake8\n</code></pre>"}, {"location": "tools/python/#environnement-virtuel", "title": "Environnement virtuel", "text": "<p>Lorsque vous installez des paquets avec PIP, un syst\u00e8me complexe de gestion de d\u00e9pendences est mis en place. Par exemple si vous installez <code>numpy</code>, <code>matplotlib</code> sera install\u00e9 automatiquement. Chaque paquet d\u00e9pend d'autres paquets.</p> <p>Il n'est pas rare d'avoir des conflits entre les versions des paquets. Par exemple, si vous avez un projet qui utilise <code>numpy</code> en version <code>1.20</code> et un autre projet qui utilise <code>numpy</code> en version <code>1.21</code>, vous aurez des probl\u00e8mes.</p> <p>Pour \u00e9viter ces probl\u00e8mes, il est recommand\u00e9 d'utiliser un environnement virtuel.</p> <p>Un environnement virtuel est un dossier local au projet sur lequel vous travaillez qui contient une installation de Python, un gestionnaire de paquets PIP et un ensemble de paquets. Chaque environnement virtuel est ind\u00e9pendant des autres. Vous pouvez avoir autant d'environnements virtuels que vous le souhaitez.</p> <p>La gestion d'environnement virtuels \u00e0 beaucoup \u00e9volu\u00e9 avec les versions de Python. Il existe plusieurs outils que l'on peut confondre\u2009:</p> <ul> <li><code>venv</code> est un module de la biblioth\u00e8que standard de Python depuis la version 3.3 qui permet de cr\u00e9er des environnements virtuels. Il est recommand\u00e9 d'utiliser <code>venv</code> pour les projets personnels.</li> <li><code>virtualenv</code> est un outil plus ancien disponible pour Python 2 et 3. Il n'est pas recommand\u00e9 de l'utiliser.</li> <li><code>poetry</code> est un outil externe. Utile pour tester des projets sur diff\u00e9rentes versions de Python\u2009; facilite la migration entre les versions.</li> </ul> <p>Pour cr\u00e9er un environnement virtuel avec <code>venv</code>, ouvrez un terminal et tapez les commandes suivantes\u2009:</p> Linux/WSLWindows <pre><code>python3 -m venv venv\nsource venv/bin/activate\n</code></pre> <pre><code>python -m venv venv\n.\\venv\\Scripts\\Activate\n</code></pre>"}, {"location": "tools/vscode/", "title": "Visual Studio Code", "text": "<p>Visual Studio Code est un \u00e9diteur de code source d\u00e9velopp\u00e9 par Microsoft. Il est gratuit, open-source et multiplateforme. Il est tr\u00e8s populaire pour le d\u00e9veloppement de logiciels, notamment pour les langages de programmation tels que C, C++, Python, Java, etc.</p> <p>Il s'inscrit dans une tr\u00e8s longue liste d'\u00e9diteurs de code source\u2009:</p> \u00c9diteur Ann\u00e9e Commentaire Inspir\u00e9 de ed 1971 \u00c9diteur de texte primitif en mode texte d\u00e9fini dans la norme POSIX - Vi 1976 \u00c9diteur de texte en mode texte d\u00e9fini dans la norme POSIX ed Emacs 1976 \u00c9diteur de texte extensible et personnalisable. TECO Vim 1991 Am\u00e9lioration de Vi, tr\u00e8s populaire des geek et devloppeurs Vi Nano 1999 \u00c9diteur de texte simple et convivial en ligne de commande - Sublime Text 2008 \u00c9diteur de texte propri\u00e9taire avec une version gratuite Vim Atom 2014 \u00c9diteur de texte open-source d\u00e9velopp\u00e9 par GitHub Sublime Text Visual Studio Code 2015 \u00c9diteur de texte open-source d\u00e9velopp\u00e9 par Microsoft Atom <p>Outre ces \u00e9diteurs on peut citer d'autres \u00e9diteurs de texte tels que Notepad++, TextPad, UltraEdit, etc. Si vous les utilisez, demandez-vous pourquoi...</p>"}, {"location": "tools/vscode/#raccourcis-clavier", "title": "Raccourcis clavier", "text": "<p>Parmis les tr\u00e8s nombreux raccourcis clavier de Visual Studio Code, voici les plus utiles\u2009:</p> Raccourci Description <code>Ctrl+P</code> Ouvrir un fichier (fuzzy search) <code>Ctrl+Shift+P</code> Ouvrir la palette de commandes (fuzzy search) <code>Ctrl+Shift+N</code> Nouvelle fen\u00eatre <code>Ctrl+Shift+F</code> Rechercher dans tous les fichiers <code>Ctrl+Shift+G</code> Ouvrir le contr\u00f4le de code source (pour faire un Git commit) <code>Ctrl+Shift+D</code> Ouvrir le contr\u00f4le de d\u00e9bogage <code>Ctrl+Shift+X</code> Ouvrir le gestionnaire d'extensions <code>Ctrl+Shift+V</code> Ouvrir un aper\u00e7u du fichier Markdown <code>Ctrl+K V</code> Ouvrir un aper\u00e7u c\u00f4te \u00e0 c\u00f4te du fichier Markdown <code>Ctrl+K Z</code> Activer/d\u00e9sactiver le mode Zen (plein \u00e9cran) <code>Ctrl+K S</code> Enregistrer sous... <code>Ctrl+K R</code> Ouvrir le dossier du fichier actuel <code>Ctrl+K Ctrl+O</code> Ouvre un dossier <code>Ctrl+D</code> S\u00e9lectionner le mot suivant (multicurseur) (r\u00e9p\u00e9ter) <code>Ctrl+U</code> Annuler la derni\u00e8re s\u00e9lection <code>Ctrl+J</code> Ouvrir un terminal int\u00e9gr\u00e9 <code>Ctrl+L</code> S\u00e9lectionner la ligne enti\u00e8re (r\u00e9p\u00e9ter) <code>Ctrl+Shift+L</code> S\u00e9lectionner toutes les occurrences du mot s\u00e9lectionn\u00e9 (multicurseur) <code>Alt+Click</code> Ins\u00e9rer un curseur <code>Ctrl+Alt+Up</code> Ins\u00e9rer un curseur au-dessus"}, {"location": "tools/vscode/#installation", "title": "Installation", "text": "<p>Pour installer Visual Studio Code, rendez-vous sur la page https://code.visualstudio.com/ et t\u00e9l\u00e9chargez la version correspondant \u00e0 votre syst\u00e8me d'exploitation. Une fois t\u00e9l\u00e9charg\u00e9, installez-le en suivant les instructions.</p> <p>Alternativement, utilisez <code>winget</code> depuis PowerShell\u2009:</p> <pre><code>winget install -e --id Microsoft.VisualStudioCode\n</code></pre>"}, {"location": "tools/vscode/#extensions", "title": "Extensions", "text": ""}, {"location": "tools/vscode/#wsl", "title": "WSL", "text": "<p>Si vous utilisez WSL vous devez installer l'extension <code>Remote - WSL</code> pour Visual Studio Code. Cette extension permet d'ouvrir un terminal int\u00e9gr\u00e9 dans WSL, d'ex\u00e9cuter des commandes dans WSL, de d\u00e9boguer des programmes dans WSL, etc.</p>"}, {"location": "tools/vscode/#remote-ssh", "title": "Remote - SSH", "text": "<p>Si vous utilisez SSH pour vous connecter \u00e0 un serveur distant par exemple vous connecter directement sur votre RaspberryPI, vous devez installer l'extension <code>Remote - SSH</code> pour Visual Studio Code. Cette extension permet d'ouvrir un terminal int\u00e9gr\u00e9 sur un serveur distant, d'ex\u00e9cuter des commandes sur le serveur distant, de d\u00e9boguer des programmes sur le serveur distant, etc.</p>"}, {"location": "tools/vscode/#cc", "title": "C/C++", "text": "<p>Si vous d\u00e9veloppez en C ou en C++, vous devez installer l'extension <code>C/C++</code> pour Visual Studio Code. Cette extension permet d'ajouter des fonctionnalit\u00e9s pour le d\u00e9veloppement en C et en C++ telles que la coloration syntaxique, l'autocompl\u00e9tion, la compilation, le d\u00e9bogage, etc.</p>"}, {"location": "tools/vscode/#python", "title": "Python", "text": "<p>Si vous d\u00e9veloppez en Python, vous devez installer l'extension <code>Python</code> pour Visual Studio Code. Cette extension permet d'ajouter des fonctionnalit\u00e9s pour le d\u00e9veloppement en Python telles que la coloration syntaxique, l'autocompl\u00e9tion, la compilation, le d\u00e9bogage, etc.</p>"}, {"location": "tools/vscode/#configuration-pour-le-debogueur", "title": "Configuration pour le debogueur", "text": "<p>Visual Studio Code n'a pas la notion de projet mais d'espace de travail workspace. Un espace de travail est simplement un r\u00e9pertoire. \u00c0 l'int\u00e9rieur de ce r\u00e9pertoire, on y trouvera\u2009:</p> <pre><code>.\n\u251c\u2500\u2500 .vscode\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 launch.json\n\u2514\u2500\u2500 main.c\n</code></pre> <p>Visual Studio Code peut en g\u00e9n\u00e9ral g\u00e9n\u00e9rer automatiquement le fichier <code>.vscode/launch.json</code> qui contient tout ce qu'il faut pour compiler et ex\u00e9cuter le programme\u2009:</p> <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"gcc\",\n            \"type\": \"cppdbg\",\n            \"request\": \"launch\",\n            \"program\": \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\",\n            \"args\": [],\n            \"stopAtEntry\": false,\n            \"cwd\": \"${workspaceFolder}\",\n            \"environment\": [],\n            \"externalConsole\": false,\n            \"MIMode\": \"gdb\",\n            \"miDebuggerPath\": \"C:\\\\ProgramData\\\\chocolatey\\\\lib\\\\mingw\\\\tools\\\\install\\\\mingw64\\\\bin\\\\gdb.exe\",\n            \"setupCommands\": [\n                {\n                    \"description\": \"Enable pretty-printing for gdb\",\n                    \"text\": \"-enable-pretty-printing\",\n                    \"ignoreFailures\": true\n                }\n            ],\n            \"preLaunchTask\": \"gcc.exe build active file\"\n        }\n    ]\n}\n</code></pre> <pre><code>{\n    \"version\": \"2.0.0\",\n    \"tasks\": [\n        {\n            \"type\": \"shell\",\n            \"label\": \"gcc.exe build active file\",\n            \"command\": \"C:\\\\ProgramData\\\\chocolatey\\\\lib\\\\mingw\\\\tools\\\\install\\\\mingw64\\\\bin\\\\gcc.exe\",\n            \"args\": [\n                \"-g\",\n                \"${file}\",\n                \"-o\",\n                \"${fileDirname}\\\\${fileBasenameNoExtension}.exe\"\n            ],\n            \"options\": {\n                \"cwd\": \"C:\\\\ProgramData\\\\chocolatey\\\\lib\\\\mingw\\\\tools\\\\install\\\\mingw64\\\\bin\"\n            },\n            \"problemMatcher\": [\n                \"$gcc\"\n            ]\n        }\n    ]\n}\n</code></pre>"}, {"location": "tools/utilities/binutils/", "title": "Binutils", "text": "<p>Les outils binaires (binutils) sont une collection de programmes install\u00e9s avec un compilateur et permettant d'aider au d\u00e9veloppement et au d\u00e9bogage. Certains de ces outils sont tr\u00e8s pratiques, mais nombreux sont les d\u00e9veloppeurs qui ne les connaissent pas.</p> <code>nm</code> <p>Liste tous les symboles dans un fichier objet (binaire). Ce programme appliqu\u00e9 sur le programme hello world de l'introduction donne\u2009:</p> <pre><code>$ nm a.out\n0000000000200dc8 d _DYNAMIC\n0000000000200fb8 d _GLOBAL_OFFSET_TABLE_\n00000000000006f0 R _IO_stdin_used\n                w _ITM_deregisterTMCloneTable\n                w _ITM_registerTMCloneTable\n\n...\n\n                U __libc_start_main@@GLIBC_2.2.5\n0000000000201010 D _edata\n0000000000201018 B _end\n00000000000006e4 T _fini\n00000000000004f0 T _init\n0000000000000540 T _start\n\n...\n\n000000000000064a T main\n                 U printf@@GLIBC_2.2.5\n00000000000005b0 t register_tm_clones\n</code></pre> <p>On observe notamment que la fonction <code>printf</code> est en provenance de la biblioth\u00e8que GLIBC 2.2.5, et qu'il y a une fonction <code>main</code>.</p> <code>strings</code> <p>Liste toutes les cha\u00eenes de caract\u00e8res imprimables dans un fichier binaire. On observe tous les symboles de d\u00e9bogue qui sont par d\u00e9faut int\u00e9gr\u00e9s au fichier ex\u00e9cutable. On lit \u00e9galement la cha\u00eene de caract\u00e8re <code>hello, world</code>. Attention donc \u00e0 ne pas laisser les \u00e9ventuels mots de passes ou num\u00e9ro de licence en clair dans un fichier binaire.</p> <pre><code>$ strings a.out\n/lib64/ld-linux-x86-64.so.2\nlibc.so.6\nprintf\n\n...\n\nAUATL\n[]A\\A]A^A_\nhello, world\n;*3$\"\nGCC: (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0\n\n...\n\n_IO_stdin_used\n__libc_csu_init\n__bss_start\nmain\n__TMC_END__\n_ITM_registerTMCloneTable\n__cxa_finalize@@GLIBC_2.2.5\n.symtab\n.strtab\n\n...\n\n.data\n.bss\n.comment\n</code></pre> <code>size</code> <p>Lister la taille des segments m\u00e9moires utilis\u00e9s. Ici le programme repr\u00e9sente 1517 bytes, les donn\u00e9es initialis\u00e9es 8 bytes, les donn\u00e9es variables 600 bytes, soit une somme d\u00e9cimale de 2125 bytes ou <code>84d</code> bytes.</p> <pre><code>$ size a.out\ntext    data     bss     dec     hex filename\n1517     600       8    2125     84d a.out\n</code></pre>"}]}